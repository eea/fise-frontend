{"ast":null,"code":"import { Editor, Range, Transforms } from 'slate';\nimport config from '@plone/volto/registry';\nimport { isCursorAtBlockEnd, splitEditorInTwoFragments, setEditorContent, createAndSelectNewBlockAfter, getCurrentListItem, createEmptyParagraph } from 'volto-slate/utils';\n\n/**\n * Handles `Enter` key on empty and non-empty list items.\n *\n * @param {Editor} editor The editor which should be modified by this extension\n * with a new version of the `insertBreak` method of the Slate editor.\n *\n * @description If the selection does not exist or is expanded, handle with the\n * default behavior. If the selection is inside a LI and it starts at a non-0\n * offset, split the LI. If the selection anchor is not in a LI or it is not at\n * offset 0, handle with the default behavior. Else delete the line before the\n * text cursor and then split the editor in two fragments, and convert them to\n * separate Slate Text blocks, based on the selection.\n */\nexport const breakList = editor => {\n  const {\n    insertBreak\n  } = editor;\n  editor.insertBreak = () => {\n    // If the selection does not exist or is expanded, handle with the default\n    // behavior.\n    if (!(editor.selection && Range.isCollapsed(editor.selection))) {\n      insertBreak();\n      return false;\n    }\n    const {\n      slate\n    } = config.settings;\n    const {\n      anchor\n    } = editor.selection;\n    const ref = Editor.rangeRef(editor, editor.selection, {\n      affinity: 'inward'\n    });\n\n    // If the selection is inside a LI and it starts at a non-0 offset, split\n    // the LI. (if one of the parents is a list item, break that list item)\n    const [listItem, listItemPath] = getCurrentListItem(editor);\n    if (listItem) {\n      // if there is text in the selection\n      if (Editor.string(editor, listItemPath)) {\n        Transforms.splitNodes(editor, {\n          at: editor.selection,\n          match: node => node.type === slate.listItemType,\n          always: true // in case cursor is at end of line\n        });\n\n        return true;\n      }\n    }\n\n    // If the selection anchor is not in a LI or it is not at offset 0, handle\n    // with the default behavior.\n    const [parent] = Editor.parent(editor, anchor.path); // , parentPath\n\n    if (parent.type !== slate.listItemType || anchor.offset > 0) {\n      insertBreak();\n      return; // applies default behaviour, as defined in insertBreak.js extension\n    }\n\n    if (parent) {\n      const blockProps = editor.getBlockProps();\n      const {\n        data\n      } = blockProps;\n      // Don't add new block if not allowed\n      if (data !== null && data !== void 0 && data.disableNewBlocks) {\n        return insertBreak();\n      }\n    }\n    Editor.deleteBackward(editor, {\n      unit: 'line'\n    });\n    // also account for empty nodes [{text: ''}]\n    if (Editor.isEmpty(editor, parent)) {\n      Transforms.removeNodes(editor, {\n        at: ref.current\n      });\n      createAndSelectNewBlockAfter(editor, [createEmptyParagraph()]);\n      return true;\n    }\n    Transforms.removeNodes(editor, {\n      at: ref.current\n    });\n    if (isCursorAtBlockEnd(editor)) {\n      createAndSelectNewBlockAfter(editor, [createEmptyParagraph()]);\n      return true;\n    }\n    const [top, bottom] = splitEditorInTwoFragments(editor, ref.current);\n    setEditorContent(editor, top);\n    createAndSelectNewBlockAfter(editor, bottom);\n    return true;\n  };\n  return editor;\n};","map":{"version":3,"names":["Editor","Range","Transforms","config","isCursorAtBlockEnd","splitEditorInTwoFragments","setEditorContent","createAndSelectNewBlockAfter","getCurrentListItem","createEmptyParagraph","breakList","editor","insertBreak","selection","isCollapsed","slate","settings","anchor","ref","rangeRef","affinity","listItem","listItemPath","string","splitNodes","at","match","node","type","listItemType","always","parent","path","offset","blockProps","getBlockProps","data","disableNewBlocks","deleteBackward","unit","isEmpty","removeNodes","current","top","bottom"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/blocks/Text/extensions/breakList.js"],"sourcesContent":["import { Editor, Range, Transforms } from 'slate';\nimport config from '@plone/volto/registry';\nimport {\n  isCursorAtBlockEnd,\n  splitEditorInTwoFragments,\n  setEditorContent,\n  createAndSelectNewBlockAfter,\n  getCurrentListItem,\n  createEmptyParagraph,\n} from 'volto-slate/utils';\n\n/**\n * Handles `Enter` key on empty and non-empty list items.\n *\n * @param {Editor} editor The editor which should be modified by this extension\n * with a new version of the `insertBreak` method of the Slate editor.\n *\n * @description If the selection does not exist or is expanded, handle with the\n * default behavior. If the selection is inside a LI and it starts at a non-0\n * offset, split the LI. If the selection anchor is not in a LI or it is not at\n * offset 0, handle with the default behavior. Else delete the line before the\n * text cursor and then split the editor in two fragments, and convert them to\n * separate Slate Text blocks, based on the selection.\n */\nexport const breakList = (editor) => {\n  const { insertBreak } = editor;\n\n  editor.insertBreak = () => {\n    // If the selection does not exist or is expanded, handle with the default\n    // behavior.\n    if (!(editor.selection && Range.isCollapsed(editor.selection))) {\n      insertBreak();\n      return false;\n    }\n\n    const { slate } = config.settings;\n    const { anchor } = editor.selection;\n\n    const ref = Editor.rangeRef(editor, editor.selection, {\n      affinity: 'inward',\n    });\n\n    // If the selection is inside a LI and it starts at a non-0 offset, split\n    // the LI. (if one of the parents is a list item, break that list item)\n    const [listItem, listItemPath] = getCurrentListItem(editor);\n    if (listItem) {\n      // if there is text in the selection\n      if (Editor.string(editor, listItemPath)) {\n        Transforms.splitNodes(editor, {\n          at: editor.selection,\n          match: (node) => node.type === slate.listItemType,\n          always: true, // in case cursor is at end of line\n        });\n\n        return true;\n      }\n    }\n\n    // If the selection anchor is not in a LI or it is not at offset 0, handle\n    // with the default behavior.\n    const [parent] = Editor.parent(editor, anchor.path); // , parentPath\n\n    if (parent.type !== slate.listItemType || anchor.offset > 0) {\n      insertBreak();\n      return; // applies default behaviour, as defined in insertBreak.js extension\n    }\n\n    if (parent) {\n      const blockProps = editor.getBlockProps();\n      const { data } = blockProps;\n      // Don't add new block if not allowed\n      if (data?.disableNewBlocks) {\n        return insertBreak();\n      }\n    }\n\n    Editor.deleteBackward(editor, { unit: 'line' });\n    // also account for empty nodes [{text: ''}]\n    if (Editor.isEmpty(editor, parent)) {\n      Transforms.removeNodes(editor, { at: ref.current });\n      createAndSelectNewBlockAfter(editor, [createEmptyParagraph()]);\n      return true;\n    }\n\n    Transforms.removeNodes(editor, { at: ref.current });\n\n    if (isCursorAtBlockEnd(editor)) {\n      createAndSelectNewBlockAfter(editor, [createEmptyParagraph()]);\n      return true;\n    }\n\n    const [top, bottom] = splitEditorInTwoFragments(editor, ref.current);\n    setEditorContent(editor, top);\n    createAndSelectNewBlockAfter(editor, bottom);\n\n    return true;\n  };\n\n  return editor;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}