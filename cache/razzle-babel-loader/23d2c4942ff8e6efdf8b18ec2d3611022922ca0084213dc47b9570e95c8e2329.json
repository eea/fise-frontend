{"ast":null,"code":"import { Editor, Transforms, Node } from 'slate'; // Range,\n\n/**\n * @description Creates or updates an existing $elementType. It also takes care\n * of the saved selection and uses PathRef.\n *\n * @param {Editor} editor The Slate editor for the context\n * @param {object} data Relevant data for this element\n *\n * @returns {boolean} true if an element was possibly inserted, false otherwise\n * (currently we do not check here if the element was already applied to the\n * editor)\n */\nexport const _insertElement = elementType => (editor, data) => {\n  if (editor.getSavedSelection()) {\n    const selection = editor.selection || editor.getSavedSelection();\n    const rangeRef = Editor.rangeRef(editor, selection);\n    const res = Array.from(Editor.nodes(editor, {\n      match: n => n.type === elementType,\n      mode: 'highest',\n      at: selection\n    }));\n    if (res.length) {\n      const [, path] = res[0];\n      Transforms.setNodes(editor, {\n        data\n      }, {\n        at: path ? path : null,\n        match: path ? n => n.type === elementType : null\n      });\n    } else {\n      Transforms.wrapNodes(editor, {\n        type: elementType,\n        data\n      }, {\n        split: true,\n        at: selection,\n        match: node => {\n          return Node.string(node).length !== 0;\n        }\n      } //,\n      );\n    }\n\n    const sel = JSON.parse(JSON.stringify(rangeRef.current));\n    Transforms.select(editor, sel);\n    editor.setSavedSelection(sel);\n    return true;\n  }\n  return false;\n};\n\n/**\n * Will unwrap a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - current node\n */\nexport const _unwrapElement = elementType => editor => {\n  const selection = editor.selection || editor.getSavedSelection();\n  const ref = Editor.rangeRef(editor, selection);\n  Transforms.select(editor, selection);\n  Transforms.unwrapNodes(editor, {\n    match: n => Array.isArray(elementType) ? elementType.includes(n.type) : n.type === elementType,\n    at: selection\n  });\n  const current = ref.current;\n  ref.unref();\n  return current;\n};\nexport const _isActiveElement = elementType => editor => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found;\n  try {\n    found = Array.from(Editor.nodes(editor, {\n      match: n => n.type === elementType,\n      at: selection\n    }) || []);\n  } catch (e) {\n    // eslint-disable-next-line\n    // console.warn('Error in finding active element', e);\n    return false;\n  }\n  if (found.length) return true;\n  if (selection) {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n    if (isAtStart) {\n      try {\n        found = Editor.previous(editor, {\n          at: path\n          // match: (n) => n.type === MENTION,\n        });\n      } catch (ex) {\n        found = [];\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Will look for a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - found node\n */\nexport const _getActiveElement = elementType => (editor, direction = 'any') => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found = [];\n  try {\n    found = Array.from(Editor.nodes(editor, {\n      match: n => Array.isArray(elementType) ? elementType.includes(n.type) : n.type === elementType,\n      at: selection\n    }));\n  } catch (e) {\n    return null;\n  }\n  if (found.length) return found[0];\n  if (!selection) return null;\n  if (direction === 'any' || direction === 'backward') {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.previous(editor, {\n          at: path\n        });\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.warn('Unable to find previous node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (Array.isArray(elementType) && elementType.includes(found[0].type) || found[0].type === elementType) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n  if (direction === 'any' || direction === 'forward') {\n    const {\n      path\n    } = selection.anchor;\n    const isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.next(editor, {\n          at: path\n        });\n      } catch (e) {\n        // eslint-disable-next-line\n        console.warn('Unable to find next node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (Array.isArray(elementType) && elementType.includes(found[0].type) || found[0].type === elementType) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n  return null;\n};","map":{"version":3,"names":["Editor","Transforms","Node","_insertElement","elementType","editor","data","getSavedSelection","selection","rangeRef","res","Array","from","nodes","match","n","type","mode","at","length","path","setNodes","wrapNodes","split","node","string","sel","JSON","parse","stringify","current","select","setSavedSelection","_unwrapElement","ref","unwrapNodes","isArray","includes","unref","_isActiveElement","found","e","anchor","isAtStart","offset","focus","previous","ex","_getActiveElement","direction","console","warn","next"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/components/ElementEditor/utils.js"],"sourcesContent":["import { Editor, Transforms, Node } from 'slate'; // Range,\n\n/**\n * @description Creates or updates an existing $elementType. It also takes care\n * of the saved selection and uses PathRef.\n *\n * @param {Editor} editor The Slate editor for the context\n * @param {object} data Relevant data for this element\n *\n * @returns {boolean} true if an element was possibly inserted, false otherwise\n * (currently we do not check here if the element was already applied to the\n * editor)\n */\nexport const _insertElement = (elementType) => (editor, data) => {\n  if (editor.getSavedSelection()) {\n    const selection = editor.selection || editor.getSavedSelection();\n\n    const rangeRef = Editor.rangeRef(editor, selection);\n\n    const res = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => n.type === elementType,\n        mode: 'highest',\n        at: selection,\n      }),\n    );\n\n    if (res.length) {\n      const [, path] = res[0];\n      Transforms.setNodes(\n        editor,\n        { data },\n        {\n          at: path ? path : null,\n          match: path ? (n) => n.type === elementType : null,\n        },\n      );\n    } else {\n      Transforms.wrapNodes(\n        editor,\n        { type: elementType, data },\n        {\n          split: true,\n          at: selection,\n          match: (node) => {\n            return Node.string(node).length !== 0;\n          },\n        }, //,\n      );\n    }\n\n    const sel = JSON.parse(JSON.stringify(rangeRef.current));\n    Transforms.select(editor, sel);\n    editor.setSavedSelection(sel);\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Will unwrap a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - current node\n */\nexport const _unwrapElement = (elementType) => (editor) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  const ref = Editor.rangeRef(editor, selection);\n\n  Transforms.select(editor, selection);\n  Transforms.unwrapNodes(editor, {\n    match: (n) =>\n      Array.isArray(elementType)\n        ? elementType.includes(n.type)\n        : n.type === elementType,\n    at: selection,\n  });\n\n  const current = ref.current;\n  ref.unref();\n\n  return current;\n};\n\nexport const _isActiveElement = (elementType) => (editor) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found;\n  try {\n    found = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => n.type === elementType,\n        at: selection,\n      }) || [],\n    );\n  } catch (e) {\n    // eslint-disable-next-line\n    // console.warn('Error in finding active element', e);\n    return false;\n  }\n  if (found.length) return true;\n\n  if (selection) {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      try {\n        found = Editor.previous(editor, {\n          at: path,\n          // match: (n) => n.type === MENTION,\n        });\n      } catch (ex) {\n        found = [];\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Will look for a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - found node\n */\nexport const _getActiveElement = (elementType) => (\n  editor,\n  direction = 'any',\n) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found = [];\n\n  try {\n    found = Array.from(\n      Editor.nodes(editor, {\n        match: (n) =>\n          Array.isArray(elementType)\n            ? elementType.includes(n.type)\n            : n.type === elementType,\n        at: selection,\n      }),\n    );\n  } catch (e) {\n    return null;\n  }\n\n  if (found.length) return found[0];\n\n  if (!selection) return null;\n\n  if (direction === 'any' || direction === 'backward') {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.previous(editor, {\n          at: path,\n        });\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.warn('Unable to find previous node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (\n          (Array.isArray(elementType) && elementType.includes(found[0].type)) ||\n          found[0].type === elementType\n        ) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n\n  if (direction === 'any' || direction === 'forward') {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.next(editor, {\n          at: path,\n        });\n      } catch (e) {\n        // eslint-disable-next-line\n        console.warn('Unable to find next node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (\n          (Array.isArray(elementType) && elementType.includes(found[0].type)) ||\n          found[0].type === elementType\n        ) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n\n  return null;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}