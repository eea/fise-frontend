{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport config from '@plone/volto/registry';\nimport { Node } from 'slate';\nimport { getAllBlocks } from '@plone/volto-slate/utils';\n\n/**\n * remove <?xml version=\"1.0\"?> from the string\n * @param {*} footnote - xml format\n * @returns string\n */\nexport const makeFootnote = footnote => {\n  return footnote ? footnote.replace('<?xml version=\"1.0\"?>', '') : '';\n};\n\n/**\n * Will open accordion if contains footnote reference\n * @param {string} footnoteId\n */\nexport const openAccordionIfContainsFootnoteReference = footnoteId => {\n  if (false) {\n    const footnote = document.querySelector(footnoteId);\n    if (footnote !== null && footnote.closest('.accordion') !== null) {\n      const comp = footnote.closest('.accordion').querySelector('.title');\n      if (!comp.className.includes('active')) {\n        comp.click();\n      }\n    }\n  }\n  return true;\n};\nconst blockTypesOperations = {\n  metadataSection: (block, properties) => {\n    const fields = block.fields;\n    return fields.filter(field => {\n      var _field$field;\n      return (field === null || field === void 0 ? void 0 : (_field$field = field.field) === null || _field$field === void 0 ? void 0 : _field$field.widget) === 'slate';\n    }).reduce((accumulator, currentField) => {\n      const fieldId = currentField.field.id;\n      const propertiesBlocks = (properties[fieldId] || []).map(propertyBlockValue => ({\n        '@type': 'slate',\n        id: fieldId,\n        value: [propertyBlockValue]\n      }));\n      return [...accumulator, ...propertiesBlocks];\n    }, []);\n  },\n  metadata: (block, properties) => {\n    var _block$data, _properties$fId;\n    const fId = block.data.id;\n    return (block === null || block === void 0 ? void 0 : (_block$data = block.data) === null || _block$data === void 0 ? void 0 : _block$data.widget) === 'slate' ? [{\n      '@type': 'slate',\n      id: fId,\n      value: (_properties$fId = properties[fId]) !== null && _properties$fId !== void 0 && _properties$fId.length ? properties[fId] : null\n    }] : [];\n  },\n  slateTable: block => {\n    var _block$table;\n    return ((block === null || block === void 0 ? void 0 : (_block$table = block.table) === null || _block$table === void 0 ? void 0 : _block$table.rows) || []).reduce((accumulator, currentRow) => {\n      const cellsBlocks = (currentRow.cells || []).map(cell => _objectSpread({\n        '@type': 'slate'\n      }, cell));\n      return [...accumulator, ...cellsBlocks];\n    }, []);\n  },\n  defaultOperation: block => {\n    return [block];\n  }\n};\n\n/**\n * Extends volto-slate getAllBlocks functionality also to SlateJSONFields\n * inserted within blocks via Metadata / Metadata section block\n * @param {Object} properties metadata properties received by the View component\n * @returns {Array} Returns a flat array of blocks and slate fields\n */\nexport const getAllBlocksAndSlateFields = properties => {\n  const blocks = getAllBlocks(properties, []);\n  return blocks.reduce((accumulator, currentblock) => {\n    return [...accumulator, ...(blockTypesOperations[currentblock['@type']] ? blockTypesOperations[currentblock['@type']](currentblock, properties) : blockTypesOperations.defaultOperation(currentblock))];\n  }, []);\n};\n\n/**\n * Will make an object with keys for every zoteroId and some uid that are unique\n * or referenced multiple times\n * - objects will have a refs object if more footnotes reference the same one\n * - for citations, same zoteroId\n * - for footnotes, identical text\n * @param {Object} blocks\n * @returns {Object} notesObjResult\n */\nexport const makeFootnoteListOfUniqueItems = blocks => {\n  const {\n    footnotes\n  } = config.settings;\n  let notesObjResult = {};\n  blocks.filter(b => b['@type'] in config.settings.blocksWithFootnotesSupport).forEach(element => {\n    const mapping = config.settings.blocksWithFootnotesSupport[element['@type']] || ['value'];\n    mapping.forEach(key => {\n      const value = element[key];\n      if (!value) return;\n      value.forEach(item => {\n        // Node.elements(item) returns an iterable generator of nodes\n        Array.from(Node.elements(item)).forEach(([node]) => {\n          if (footnotes.includes(node.type) && node.data) {\n            // for citations (Zotero items) create refs for same zoteroId\n            if (node.data.zoteroId) {\n              iterateZoteroObj(notesObjResult, node.data);\n              // itereate the extra obj for multiple citations\n              if (node.data.extra) {\n                node.data.extra.forEach(zoteroObjItem =>\n                // send the uid of the parent\n                // of the word the will have the reference indice\n                iterateZoteroObj(notesObjResult, zoteroObjItem, node.data.uid));\n              }\n              // for footnotes - create refs, on identical text\n            } else {\n              iterateFootnoteObj(notesObjResult, node.data);\n              if (node.data.extra) {\n                node.data.extra.forEach(footnoteObjItem =>\n                // since is called in case of extra, the parent is needed\n                iterateFootnoteObj(notesObjResult, footnoteObjItem, node.data.uid));\n              }\n            }\n          }\n        });\n      });\n    });\n  });\n  return notesObjResult;\n};\n\n/**\n * Will change the notesObjResultTemp to add new property if the zoteroId is new or add to the existing ones refs\n * @param {Object} notesObjResultTemp - the object that will configure the zotero items\n * @param {Object} zoteroObj - the footnote object\n * @param {string} zoteroObj.zoteroId - id of the zotero citation\n * @param {string} zoteroObj.uid - id of the slate item\n * @param {string} zoteroObj.footnote - xml citation from zotero\n * @param {string} parentUid - will be needed because html element (the word) that references multiple citations\n * will have the id as the main uid, the ids from the extra will not matter in this case\n */\nconst iterateZoteroObj = (notesObjResultTemp, zoteroObj, parentUid) => {\n  const uid = parentUid || zoteroObj.uid;\n  // add new zoteroId\n  if (!notesObjResultTemp[zoteroObj.zoteroId]) {\n    notesObjResultTemp[zoteroObj.zoteroId] = _objectSpread(_objectSpread({}, zoteroObj), {}, {\n      uid\n    });\n    // if zoteroId and refs exist then add the uid to the refs\n  } else if (notesObjResultTemp[zoteroObj.zoteroId].refs) {\n    notesObjResultTemp[zoteroObj.zoteroId].refs[uid] = true;\n  } else {\n    // if zoteroId exists but not refs, add its own uid also in refs for easier parsing in html\n    notesObjResultTemp[zoteroObj.zoteroId].refs = {\n      [notesObjResultTemp[zoteroObj.zoteroId].uid]: true,\n      [uid]: true\n    };\n  }\n};\n\n/**\n * Will change the notesObjResultTemp to add new property if the footnote uid is new or add to the refs of the existing ones\n * Some footnotes will always be in extra, so we need parentId to know where to find it in render\n * @param {Object} notesObjResultTemp - the object that will configure the zotero items\n * @param {Object} node - the footnote object\n * @param {string} node.zoteroId - id of the zotero citation\n * @param {string} node.parentUid - id of the parent footnote\n * @param {string} node.uid - id of the slate item\n * @param {string} node.footnote - xml citation from zotero\n * @param {string} parentUid - will be needed because html element (the word) that references multiple citations\n * will have the id as the main uid, the ids from the extra will not matter in this case\n */\nconst iterateFootnoteObj = (notesObjResultTemp, node, parentUid) => {\n  const uid = parentUid || node.uid;\n  const found = Object.keys(notesObjResultTemp).find(noteId => {\n    return notesObjResultTemp[noteId].footnote === node.footnote;\n  });\n  // has not yet been added\n  if (!found) {\n    // will use the parentUid instead of own uid for render to be able to reference to the correct element\n    //(word containing the footnotes)\n    notesObjResultTemp[node.uid] = parentUid ? _objectSpread(_objectSpread({}, node), {}, {\n      parentUid\n    }) : _objectSpread({}, node);\n    // the element is found, just add it's own uid to the list of refs, the parent is already known\n  } else if (notesObjResultTemp[found].refs) {\n    notesObjResultTemp[found].refs[uid] = true;\n  } else {\n    // element found but doesn't have refs yet, this means that it is a parent, so add it's existing uid and the current one\n    notesObjResultTemp[found].refs = {\n      [found]: true,\n      [uid]: true\n    };\n  }\n};","map":{"version":3,"names":["config","Node","getAllBlocks","makeFootnote","footnote","replace","openAccordionIfContainsFootnoteReference","footnoteId","document","querySelector","closest","comp","className","includes","click","blockTypesOperations","metadataSection","block","properties","fields","filter","field","widget","reduce","accumulator","currentField","fieldId","id","propertiesBlocks","map","propertyBlockValue","value","metadata","fId","data","length","slateTable","table","rows","currentRow","cellsBlocks","cells","cell","defaultOperation","getAllBlocksAndSlateFields","blocks","currentblock","makeFootnoteListOfUniqueItems","footnotes","settings","notesObjResult","b","blocksWithFootnotesSupport","forEach","element","mapping","key","item","Array","from","elements","node","type","zoteroId","iterateZoteroObj","extra","zoteroObjItem","uid","iterateFootnoteObj","footnoteObjItem","notesObjResultTemp","zoteroObj","parentUid","refs","found","Object","keys","find","noteId"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@eeacms/volto-slate-footnote/src/editor/utils.js"],"sourcesContent":["import config from '@plone/volto/registry';\nimport { Node } from 'slate';\nimport { getAllBlocks } from '@plone/volto-slate/utils';\n\n/**\n * remove <?xml version=\"1.0\"?> from the string\n * @param {*} footnote - xml format\n * @returns string\n */\nexport const makeFootnote = (footnote) => {\n  return footnote ? footnote.replace('<?xml version=\"1.0\"?>', '') : '';\n};\n\n/**\n * Will open accordion if contains footnote reference\n * @param {string} footnoteId\n */\nexport const openAccordionIfContainsFootnoteReference = (footnoteId) => {\n  if (typeof window !== 'undefined') {\n    const footnote = document.querySelector(footnoteId);\n    if (footnote !== null && footnote.closest('.accordion') !== null) {\n      const comp = footnote.closest('.accordion').querySelector('.title');\n      if (!comp.className.includes('active')) {\n        comp.click();\n      }\n    }\n  }\n\n  return true;\n};\n\nconst blockTypesOperations = {\n  metadataSection: (block, properties) => {\n    const fields = block.fields;\n\n    return fields\n      .filter((field) => field?.field?.widget === 'slate')\n      .reduce((accumulator, currentField) => {\n        const fieldId = currentField.field.id;\n        const propertiesBlocks = (properties[fieldId] || []).map(\n          (propertyBlockValue) => ({\n            '@type': 'slate',\n            id: fieldId,\n            value: [propertyBlockValue],\n          }),\n        );\n        return [...accumulator, ...propertiesBlocks];\n      }, []);\n  },\n  metadata: (block, properties) => {\n    const fId = block.data.id;\n\n    return block?.data?.widget === 'slate'\n      ? [\n          {\n            '@type': 'slate',\n            id: fId,\n            value: properties[fId]?.length ? properties[fId] : null,\n          },\n        ]\n      : [];\n  },\n  slateTable: (block) => {\n    return (block?.table?.rows || []).reduce((accumulator, currentRow) => {\n      const cellsBlocks = (currentRow.cells || []).map((cell) => ({\n        '@type': 'slate',\n        ...cell,\n      }));\n      return [...accumulator, ...cellsBlocks];\n    }, []);\n  },\n  defaultOperation: (block) => {\n    return [block];\n  },\n};\n\n/**\n * Extends volto-slate getAllBlocks functionality also to SlateJSONFields\n * inserted within blocks via Metadata / Metadata section block\n * @param {Object} properties metadata properties received by the View component\n * @returns {Array} Returns a flat array of blocks and slate fields\n */\nexport const getAllBlocksAndSlateFields = (properties) => {\n  const blocks = getAllBlocks(properties, []);\n  return blocks.reduce((accumulator, currentblock) => {\n    return [\n      ...accumulator,\n      ...(blockTypesOperations[currentblock['@type']]\n        ? blockTypesOperations[currentblock['@type']](currentblock, properties)\n        : blockTypesOperations.defaultOperation(currentblock)),\n    ];\n  }, []);\n};\n\n/**\n * Will make an object with keys for every zoteroId and some uid that are unique\n * or referenced multiple times\n * - objects will have a refs object if more footnotes reference the same one\n * - for citations, same zoteroId\n * - for footnotes, identical text\n * @param {Object} blocks\n * @returns {Object} notesObjResult\n */\nexport const makeFootnoteListOfUniqueItems = (blocks) => {\n  const { footnotes } = config.settings;\n  let notesObjResult = {};\n\n  blocks\n    .filter((b) => b['@type'] in config.settings.blocksWithFootnotesSupport)\n    .forEach((element) => {\n      const mapping = config.settings.blocksWithFootnotesSupport[\n        element['@type']\n      ] || ['value'];\n\n      mapping.forEach((key) => {\n        const value = element[key];\n        if (!value) return;\n\n        value.forEach((item) => {\n          // Node.elements(item) returns an iterable generator of nodes\n          Array.from(Node.elements(item)).forEach(([node]) => {\n            if (footnotes.includes(node.type) && node.data) {\n              // for citations (Zotero items) create refs for same zoteroId\n              if (node.data.zoteroId) {\n                iterateZoteroObj(notesObjResult, node.data);\n                // itereate the extra obj for multiple citations\n                if (node.data.extra) {\n                  node.data.extra.forEach((zoteroObjItem) =>\n                    // send the uid of the parent\n                    // of the word the will have the reference indice\n                    iterateZoteroObj(\n                      notesObjResult,\n                      zoteroObjItem,\n                      node.data.uid,\n                    ),\n                  );\n                }\n                // for footnotes - create refs, on identical text\n              } else {\n                iterateFootnoteObj(notesObjResult, node.data);\n                if (node.data.extra) {\n                  node.data.extra.forEach((footnoteObjItem) =>\n                    // since is called in case of extra, the parent is needed\n                    iterateFootnoteObj(\n                      notesObjResult,\n                      footnoteObjItem,\n                      node.data.uid,\n                    ),\n                  );\n                }\n              }\n            }\n          });\n        });\n      });\n    });\n\n  return notesObjResult;\n};\n\n/**\n * Will change the notesObjResultTemp to add new property if the zoteroId is new or add to the existing ones refs\n * @param {Object} notesObjResultTemp - the object that will configure the zotero items\n * @param {Object} zoteroObj - the footnote object\n * @param {string} zoteroObj.zoteroId - id of the zotero citation\n * @param {string} zoteroObj.uid - id of the slate item\n * @param {string} zoteroObj.footnote - xml citation from zotero\n * @param {string} parentUid - will be needed because html element (the word) that references multiple citations\n * will have the id as the main uid, the ids from the extra will not matter in this case\n */\nconst iterateZoteroObj = (notesObjResultTemp, zoteroObj, parentUid) => {\n  const uid = parentUid || zoteroObj.uid;\n  // add new zoteroId\n  if (!notesObjResultTemp[zoteroObj.zoteroId]) {\n    notesObjResultTemp[zoteroObj.zoteroId] = {\n      ...zoteroObj,\n      uid,\n    };\n    // if zoteroId and refs exist then add the uid to the refs\n  } else if (notesObjResultTemp[zoteroObj.zoteroId].refs) {\n    notesObjResultTemp[zoteroObj.zoteroId].refs[uid] = true;\n  } else {\n    // if zoteroId exists but not refs, add its own uid also in refs for easier parsing in html\n    notesObjResultTemp[zoteroObj.zoteroId].refs = {\n      [notesObjResultTemp[zoteroObj.zoteroId].uid]: true,\n      [uid]: true,\n    };\n  }\n};\n\n/**\n * Will change the notesObjResultTemp to add new property if the footnote uid is new or add to the refs of the existing ones\n * Some footnotes will always be in extra, so we need parentId to know where to find it in render\n * @param {Object} notesObjResultTemp - the object that will configure the zotero items\n * @param {Object} node - the footnote object\n * @param {string} node.zoteroId - id of the zotero citation\n * @param {string} node.parentUid - id of the parent footnote\n * @param {string} node.uid - id of the slate item\n * @param {string} node.footnote - xml citation from zotero\n * @param {string} parentUid - will be needed because html element (the word) that references multiple citations\n * will have the id as the main uid, the ids from the extra will not matter in this case\n */\nconst iterateFootnoteObj = (notesObjResultTemp, node, parentUid) => {\n  const uid = parentUid || node.uid;\n  const found = Object.keys(notesObjResultTemp).find((noteId) => {\n    return notesObjResultTemp[noteId].footnote === node.footnote;\n  });\n  // has not yet been added\n  if (!found) {\n    // will use the parentUid instead of own uid for render to be able to reference to the correct element\n    //(word containing the footnotes)\n    notesObjResultTemp[node.uid] = parentUid\n      ? { ...node, parentUid }\n      : { ...node };\n    // the element is found, just add it's own uid to the list of refs, the parent is already known\n  } else if (notesObjResultTemp[found].refs) {\n    notesObjResultTemp[found].refs[uid] = true;\n  } else {\n    // element found but doesn't have refs yet, this means that it is a parent, so add it's existing uid and the current one\n    notesObjResultTemp[found].refs = {\n      [found]: true,\n      [uid]: true,\n    };\n  }\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}