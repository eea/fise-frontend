{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport isUrl from 'is-url';\nimport imageExtensions from 'image-extensions';\nimport { blockTagDeserializer } from 'volto-slate/editor/deserialize';\nimport { getBaseUrl } from '@plone/volto/helpers';\nimport { v4 as uuid } from 'uuid';\nimport { Transforms } from 'slate';\nimport { IMAGE } from 'volto-slate/constants';\nexport const insertImage = (editor, url, {\n  typeImg = IMAGE\n} = {}) => {\n  const image = {\n    type: typeImg,\n    url,\n    children: [{\n      text: ''\n    }]\n  };\n  Transforms.insertNodes(editor, image);\n};\nexport const isImageUrl = url => {\n  if (!isUrl(url)) return false;\n  const ext = new URL(url).pathname.split('.').pop();\n  return imageExtensions.includes(ext);\n};\nexport const onImageLoad = (editor, reader) => () => {\n  const data = reader.result;\n\n  // if (url) insertImage(editor, url);\n  const fields = data.match(/^data:(.*);(.*),(.*)$/);\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    uploadContent,\n    pathname\n  } = blockProps;\n\n  // TODO: we need a way to get the uploaded image URL\n  // This would be easier if we would have block transformers-based image\n  // blocks\n  const url = getBaseUrl(pathname);\n  const uploadId = uuid();\n  const uploadFileName = `clipboard-${uploadId}`;\n  const uploadTitle = `Clipboard image`;\n  const content = {\n    '@type': 'Image',\n    title: uploadTitle,\n    image: {\n      data: fields[3],\n      encoding: fields[2],\n      'content-type': fields[1],\n      filename: uploadFileName\n    }\n  };\n  uploadContent(url, content, block).then(data => {\n    const dlUrl = data.image.download;\n    insertImage(editor, dlUrl);\n  });\n};\nexport const withDeserializers = editor => {\n  var _editor$dataTransferH;\n  editor.htmlTagsToSlate = _objectSpread(_objectSpread({}, editor.htmlTagsToSlate), {}, {\n    // We don't want H1 tags when pasting, we rewrite them as H2\n    H1: blockTagDeserializer('h2')\n  });\n  const handleFiles = ((_editor$dataTransferH = editor.dataTransferHandlers) === null || _editor$dataTransferH === void 0 ? void 0 : _editor$dataTransferH.files) || (() => true);\n  editor.dataTransferHandlers = _objectSpread(_objectSpread({}, editor.dataTransferHandlers), {}, {\n    files: files => {\n      const unprocessed = [];\n      for (const file of files) {\n        const reader = new FileReader();\n        const [mime] = file.type.split('/');\n        if (mime === 'image') {\n          reader.addEventListener('load', onImageLoad(editor, reader));\n          reader.readAsDataURL(file);\n        } else {\n          unprocessed.push(file);\n        }\n      }\n      return handleFiles(unprocessed);\n    }\n  });\n  return editor;\n};","map":{"version":3,"names":["isUrl","imageExtensions","blockTagDeserializer","getBaseUrl","v4","uuid","Transforms","IMAGE","insertImage","editor","url","typeImg","image","type","children","text","insertNodes","isImageUrl","ext","URL","pathname","split","pop","includes","onImageLoad","reader","data","result","fields","match","blockProps","getBlockProps","block","uploadContent","uploadId","uploadFileName","uploadTitle","content","title","encoding","filename","then","dlUrl","download","withDeserializers","htmlTagsToSlate","H1","handleFiles","dataTransferHandlers","files","unprocessed","file","FileReader","mime","addEventListener","readAsDataURL","push"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/blocks/Text/extensions/withDeserializers.js"],"sourcesContent":["import isUrl from 'is-url';\nimport imageExtensions from 'image-extensions';\nimport { blockTagDeserializer } from 'volto-slate/editor/deserialize';\nimport { getBaseUrl } from '@plone/volto/helpers';\nimport { v4 as uuid } from 'uuid';\nimport { Transforms } from 'slate';\n\nimport { IMAGE } from 'volto-slate/constants';\n\nexport const insertImage = (editor, url, { typeImg = IMAGE } = {}) => {\n  const image = { type: typeImg, url, children: [{ text: '' }] };\n  Transforms.insertNodes(editor, image);\n};\n\nexport const isImageUrl = (url) => {\n  if (!isUrl(url)) return false;\n\n  const ext = new URL(url).pathname.split('.').pop();\n\n  return imageExtensions.includes(ext);\n};\n\nexport const onImageLoad = (editor, reader) => () => {\n  const data = reader.result;\n\n  // if (url) insertImage(editor, url);\n  const fields = data.match(/^data:(.*);(.*),(.*)$/);\n  const blockProps = editor.getBlockProps();\n  const { block, uploadContent, pathname } = blockProps;\n\n  // TODO: we need a way to get the uploaded image URL\n  // This would be easier if we would have block transformers-based image\n  // blocks\n  const url = getBaseUrl(pathname);\n  const uploadId = uuid();\n  const uploadFileName = `clipboard-${uploadId}`;\n  const uploadTitle = `Clipboard image`;\n  const content = {\n    '@type': 'Image',\n    title: uploadTitle,\n    image: {\n      data: fields[3],\n      encoding: fields[2],\n      'content-type': fields[1],\n      filename: uploadFileName,\n    },\n  };\n\n  uploadContent(url, content, block).then((data) => {\n    const dlUrl = data.image.download;\n    insertImage(editor, dlUrl);\n  });\n};\n\nexport const withDeserializers = (editor) => {\n  editor.htmlTagsToSlate = {\n    ...editor.htmlTagsToSlate,\n\n    // We don't want H1 tags when pasting, we rewrite them as H2\n    H1: blockTagDeserializer('h2'),\n  };\n\n  const handleFiles = editor.dataTransferHandlers?.files || (() => true);\n\n  editor.dataTransferHandlers = {\n    ...editor.dataTransferHandlers,\n    files: (files) => {\n      const unprocessed = [];\n      for (const file of files) {\n        const reader = new FileReader();\n        const [mime] = file.type.split('/');\n        if (mime === 'image') {\n          reader.addEventListener('load', onImageLoad(editor, reader));\n          reader.readAsDataURL(file);\n        } else {\n          unprocessed.push(file);\n        }\n      }\n\n      return handleFiles(unprocessed);\n    },\n  };\n\n  return editor;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}