{"ast":null,"code":"import _toConsumableArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _omit from \"lodash/omit\";\nimport ReactDOM from 'react-dom';\nimport { v4 as uuid } from 'uuid';\nimport { addBlock, changeBlock, getBlocksFieldname, getBlocksLayoutFieldname } from '@plone/volto/helpers';\nimport { Transforms, Editor, Node, Text, Path } from 'slate';\nimport { serializeNodesToText } from 'volto-slate/editor/render';\nimport config from '@plone/volto/registry';\nfunction fromEntries(pairs) {\n  var res = {};\n  pairs.forEach(function (p) {\n    res[p[0]] = p[1];\n  });\n  return res;\n}\n\n// TODO: should be made generic, no need for \"prevBlock.value\"\nexport function mergeSlateWithBlockBackward(editor, prevBlock, event) {\n  // To work around current architecture limitations, read the value from\n  // previous block. Replace it in the current editor (over which we have\n  // control), join with current block value, then use this result for previous\n  // block, delete current block\n\n  var prev = prevBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, {\n    edge: 'start'\n  });\n  var rangeRef;\n  var end;\n  Editor.withoutNormalizing(editor, function () {\n    // insert block #0 contents in block #1 contents, at the beginning\n    Transforms.insertNodes(editor, prev, {\n      at: Editor.start(editor, [])\n    });\n\n    // the contents that should be moved into the `ul`, as the last `li`\n    rangeRef = Editor.rangeRef(editor, {\n      anchor: Editor.start(editor, [1]),\n      focus: Editor.end(editor, [1])\n    });\n    var source = rangeRef.current;\n    end = Editor.end(editor, [0]);\n    var endPoint;\n    Transforms.insertNodes(editor, {\n      text: ''\n    }, {\n      at: end\n    });\n    end = Editor.end(editor, [0]);\n    Transforms.splitNodes(editor, {\n      at: end,\n      always: true,\n      height: 1,\n      mode: 'highest',\n      match: function match(n) {\n        return n.type === 'li' || Text.isText(n);\n      }\n    });\n    endPoint = Editor.end(editor, [0]);\n    Transforms.moveNodes(editor, {\n      at: source,\n      to: endPoint.path,\n      mode: 'all',\n      match: function match(n, p) {\n        return p.length === 2;\n      }\n    });\n  });\n  var _Editor$node = Editor.node(editor, [1]),\n    _Editor$node2 = _slicedToArray(_Editor$node, 1),\n    n = _Editor$node2[0];\n  if (Editor.isEmpty(editor, n)) {\n    Transforms.removeNodes(editor, {\n      at: [1]\n    });\n  }\n  rangeRef.unref();\n  var _Editor$last = Editor.last(editor, [0]),\n    _Editor$last2 = _slicedToArray(_Editor$last, 2),\n    lastPath = _Editor$last2[1];\n  end = Editor.start(editor, Path.parent(lastPath));\n  return end;\n}\nexport function mergeSlateWithBlockForward(editor, nextBlock, event) {\n  // To work around current architecture limitations, read the value from next\n  // block. Replace it in the current editor (over which we have control), join\n  // with current block value, then use this result for next block, delete\n  // current block\n\n  var next = nextBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, {\n    edge: 'end'\n  });\n  Transforms.insertNodes(editor, next, {\n    at: Editor.end(editor, [])\n  });\n  Editor.deleteForward(editor, {\n    unit: 'character'\n  });\n}\nexport function syncCreateSlateBlock(value) {\n  var id = uuid();\n  var block = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(value)),\n    plaintext: serializeNodesToText(value)\n  };\n  return [id, block];\n}\nexport function createImageBlock(url, index, props) {\n  var properties = props.properties,\n    onChangeField = props.onChangeField,\n    onSelectBlock = props.onSelectBlock;\n  var blocksFieldname = getBlocksFieldname(properties);\n  var blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  var _addBlock = addBlock(properties, 'image', index + 1),\n    _addBlock2 = _slicedToArray(_addBlock, 2),\n    id = _addBlock2[0],\n    formData = _addBlock2[1];\n  var newFormData = changeBlock(formData, id, {\n    '@type': 'image',\n    url: url\n  });\n  ReactDOM.unstable_batchedUpdates(function () {\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(id);\n  });\n}\nexport var createAndSelectNewBlockAfter = function createAndSelectNewBlockAfter(editor, blockValue) {\n  var blockProps = editor.getBlockProps();\n  var onSelectBlock = blockProps.onSelectBlock,\n    properties = blockProps.properties,\n    index = blockProps.index,\n    onChangeField = blockProps.onChangeField;\n  var _addBlock3 = addBlock(properties, 'slate', index + 1),\n    _addBlock4 = _slicedToArray(_addBlock3, 2),\n    blockId = _addBlock4[0],\n    formData = _addBlock4[1];\n  var options = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(blockValue)),\n    plaintext: serializeNodesToText(blockValue)\n  };\n  var newFormData = changeBlock(formData, blockId, options);\n  var blocksFieldname = getBlocksFieldname(properties);\n  var blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  // console.log('layout', blocksLayoutFieldname, newFormData);\n\n  ReactDOM.unstable_batchedUpdates(function () {\n    blockProps.saveSlateBlockSelection(blockId, 'start');\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(blockId);\n  });\n};\nexport function getNextVoltoBlock(index, properties) {\n  // TODO: look for any next slate block\n  // join this block with previous block, if previous block is slate\n  var blocksFieldname = getBlocksFieldname(properties);\n  var blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  var blocks_layout = properties[blocksLayoutFieldname];\n  if (index === blocks_layout.items.length) return;\n  var nextBlockId = blocks_layout.items[index + 1];\n  var nextBlock = properties[blocksFieldname][nextBlockId];\n  return [nextBlock, nextBlockId];\n}\nexport function getPreviousVoltoBlock(index, properties) {\n  // TODO: look for any prev slate block\n  if (index === 0) return;\n  var blocksFieldname = getBlocksFieldname(properties);\n  var blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  var blocks_layout = properties[blocksLayoutFieldname];\n  var prevBlockId = blocks_layout.items[index - 1];\n  var prevBlock = properties[blocksFieldname][prevBlockId];\n  return [prevBlock, prevBlockId];\n}\n\n// //check for existing img children\n// const checkContainImg = (elements) => {\n//   var check = false;\n//   elements.forEach((e) =>\n//     e.children.forEach((c) => {\n//       if (c && c.type && c.type === 'img') {\n//         check = true;\n//       }\n//     }),\n//   );\n//   return check;\n// };\n\n// //check for existing table children\n// const checkContainTable = (elements) => {\n//   var check = false;\n//   elements.forEach((e) => {\n//     if (e && e.type && e.type === 'table') {\n//       check = true;\n//     }\n//   });\n//   return check;\n// };\n\n/**\n * The editor has the properties `dataTransferHandlers` (object) and\n * `dataTransferFormatsOrder` and in `dataTransferHandlers` are functions which\n * sometimes must call this function. Some types of data storeable in Slate\n * documents can be and should be put into separate Volto blocks. The\n * `deconstructToVoltoBlocks` function scans the contents of the Slate document\n * and, through configured Volto block emitters, it outputs separate Volto\n * blocks into the same Volto page form. The `deconstructToVoltoBlocks` function\n * should be called only in key places where it is necessary.\n *\n * @example See the `src/editor/extensions/insertData.js` file.\n *\n * @param {Editor} editor The Slate editor object which should be deconstructed\n * if possible.\n *\n * @returns {Promise}\n */\nexport function deconstructToVoltoBlocks(editor) {\n  // Explodes editor content into separate blocks\n  // If the editor has multiple top-level children, split the current block\n  // into multiple slate blocks. This will delete and replace the current\n  // block.\n  //\n  // It returns a promise that, when resolved, will pass a list of Volto block\n  // ids that were affected\n  //\n  // For the Volto blocks manipulation we do low-level changes to the context\n  // form state, as that ensures a better performance (no un-needed UI updates)\n\n  if (!editor.getBlockProps) return;\n  var blockProps = editor.getBlockProps();\n  var slate = config.settings.slate;\n  var voltoBlockEmiters = slate.voltoBlockEmiters;\n  return new Promise(function (resolve, reject) {\n    if (!(editor !== null && editor !== void 0 && editor.children)) return;\n    if (editor.children.length === 1) {\n      return resolve([blockProps.block]);\n    }\n    var _editor$getBlockProps = editor.getBlockProps(),\n      properties = _editor$getBlockProps.properties,\n      onChangeField = _editor$getBlockProps.onChangeField,\n      onSelectBlock = _editor$getBlockProps.onSelectBlock;\n    var blocksFieldname = getBlocksFieldname(properties);\n    var blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n    var index = blockProps.index;\n    var blocks = [];\n\n    // TODO: should use Editor.levels() instead of Node.children\n    var pathRefs = Array.from(Node.children(editor, [])).map(function (_ref) {\n      var _ref2 = _slicedToArray(_ref, 2),\n        path = _ref2[1];\n      return Editor.pathRef(editor, path);\n    });\n    var _iterator = _createForOfIteratorHelper(pathRefs),\n      _step;\n    try {\n      var _loop = function _loop() {\n        var pathRef = _step.value;\n        // extra nodes are always extracted after the text node\n        var extras = voltoBlockEmiters.map(function (emit) {\n          return emit(editor, pathRef);\n        }).flat(1);\n\n        // The node might have been replaced with a Volto block\n        if (pathRef.current) {\n          var _Editor$node3 = Editor.node(editor, pathRef.current),\n            _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n            childNode = _Editor$node4[0];\n          if (childNode && !Editor.isEmpty(editor, childNode)) blocks.push(syncCreateSlateBlock([childNode]));\n        }\n        blocks = [].concat(_toConsumableArray(blocks), _toConsumableArray(extras));\n      };\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        _loop();\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    var blockids = blocks.map(function (b) {\n      return b[0];\n    });\n\n    // TODO: add the placeholder block, because we remove it\n    // (when we remove the current block)\n\n    var blocksData = _omit(_objectSpread(_objectSpread({}, properties[blocksFieldname]), fromEntries(blocks)), blockProps.block);\n    var layoutData = _objectSpread(_objectSpread({}, properties[blocksLayoutFieldname]), {}, {\n      items: [].concat(_toConsumableArray(properties[blocksLayoutFieldname].items.slice(0, index)), _toConsumableArray(blockids), _toConsumableArray(properties[blocksLayoutFieldname].items.slice(index))).filter(function (id) {\n        return id !== blockProps.block;\n      })\n    });\n\n    // TODO: use onChangeFormData instead of this API style\n    ReactDOM.unstable_batchedUpdates(function () {\n      onChangeField(blocksFieldname, blocksData);\n      onChangeField(blocksLayoutFieldname, layoutData);\n      onSelectBlock(blockids[blockids.length - 1]);\n      // resolve(blockids);\n      // or rather this?\n      Promise.resolve().then(resolve(blockids));\n    });\n  });\n}","map":{"version":3,"names":["ReactDOM","v4","uuid","addBlock","changeBlock","getBlocksFieldname","getBlocksLayoutFieldname","Transforms","Editor","Node","Text","Path","serializeNodesToText","config","fromEntries","pairs","res","forEach","p","mergeSlateWithBlockBackward","editor","prevBlock","event","prev","value","collapse","edge","rangeRef","end","withoutNormalizing","insertNodes","at","start","anchor","focus","source","current","endPoint","text","splitNodes","always","height","mode","match","n","type","isText","moveNodes","to","path","length","node","isEmpty","removeNodes","unref","last","lastPath","parent","mergeSlateWithBlockForward","nextBlock","next","deleteForward","unit","syncCreateSlateBlock","id","block","JSON","parse","stringify","plaintext","createImageBlock","url","index","props","properties","onChangeField","onSelectBlock","blocksFieldname","blocksLayoutFieldname","formData","newFormData","unstable_batchedUpdates","createAndSelectNewBlockAfter","blockValue","blockProps","getBlockProps","blockId","options","saveSlateBlockSelection","getNextVoltoBlock","blocks_layout","items","nextBlockId","getPreviousVoltoBlock","prevBlockId","deconstructToVoltoBlocks","slate","settings","voltoBlockEmiters","Promise","resolve","reject","children","blocks","pathRefs","Array","from","map","pathRef","extras","emit","flat","childNode","push","blockids","b","blocksData","layoutData","slice","filter","then"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/utils/volto-blocks.js"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport { v4 as uuid } from 'uuid';\nimport {\n  addBlock,\n  changeBlock,\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers';\nimport { Transforms, Editor, Node, Text, Path } from 'slate';\nimport { serializeNodesToText } from 'volto-slate/editor/render';\nimport { omit } from 'lodash';\nimport config from '@plone/volto/registry';\n\nfunction fromEntries(pairs) {\n  const res = {};\n  pairs.forEach((p) => {\n    res[p[0]] = p[1];\n  });\n  return res;\n}\n\n// TODO: should be made generic, no need for \"prevBlock.value\"\nexport function mergeSlateWithBlockBackward(editor, prevBlock, event) {\n  // To work around current architecture limitations, read the value from\n  // previous block. Replace it in the current editor (over which we have\n  // control), join with current block value, then use this result for previous\n  // block, delete current block\n\n  const prev = prevBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, { edge: 'start' });\n\n  let rangeRef;\n  let end;\n\n  Editor.withoutNormalizing(editor, () => {\n    // insert block #0 contents in block #1 contents, at the beginning\n    Transforms.insertNodes(editor, prev, {\n      at: Editor.start(editor, []),\n    });\n\n    // the contents that should be moved into the `ul`, as the last `li`\n    rangeRef = Editor.rangeRef(editor, {\n      anchor: Editor.start(editor, [1]),\n      focus: Editor.end(editor, [1]),\n    });\n\n    const source = rangeRef.current;\n\n    end = Editor.end(editor, [0]);\n\n    let endPoint;\n\n    Transforms.insertNodes(editor, { text: '' }, { at: end });\n\n    end = Editor.end(editor, [0]);\n\n    Transforms.splitNodes(editor, {\n      at: end,\n      always: true,\n      height: 1,\n      mode: 'highest',\n      match: (n) => n.type === 'li' || Text.isText(n),\n    });\n\n    endPoint = Editor.end(editor, [0]);\n\n    Transforms.moveNodes(editor, {\n      at: source,\n      to: endPoint.path,\n      mode: 'all',\n      match: (n, p) => p.length === 2,\n    });\n  });\n\n  const [n] = Editor.node(editor, [1]);\n\n  if (Editor.isEmpty(editor, n)) {\n    Transforms.removeNodes(editor, { at: [1] });\n  }\n\n  rangeRef.unref();\n\n  const [, lastPath] = Editor.last(editor, [0]);\n\n  end = Editor.start(editor, Path.parent(lastPath));\n\n  return end;\n}\n\nexport function mergeSlateWithBlockForward(editor, nextBlock, event) {\n  // To work around current architecture limitations, read the value from next\n  // block. Replace it in the current editor (over which we have control), join\n  // with current block value, then use this result for next block, delete\n  // current block\n\n  const next = nextBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, { edge: 'end' });\n  Transforms.insertNodes(editor, next, {\n    at: Editor.end(editor, []),\n  });\n\n  Editor.deleteForward(editor, { unit: 'character' });\n}\n\nexport function syncCreateSlateBlock(value) {\n  const id = uuid();\n  const block = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(value)),\n    plaintext: serializeNodesToText(value),\n  };\n  return [id, block];\n}\n\nexport function createImageBlock(url, index, props) {\n  const { properties, onChangeField, onSelectBlock } = props;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const [id, formData] = addBlock(properties, 'image', index + 1);\n  const newFormData = changeBlock(formData, id, { '@type': 'image', url });\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(id);\n  });\n}\n\nexport const createAndSelectNewBlockAfter = (editor, blockValue) => {\n  const blockProps = editor.getBlockProps();\n\n  const { onSelectBlock, properties, index, onChangeField } = blockProps;\n\n  const [blockId, formData] = addBlock(properties, 'slate', index + 1);\n\n  const options = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(blockValue)),\n    plaintext: serializeNodesToText(blockValue),\n  };\n\n  const newFormData = changeBlock(formData, blockId, options);\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  // console.log('layout', blocksLayoutFieldname, newFormData);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    blockProps.saveSlateBlockSelection(blockId, 'start');\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(blockId);\n  });\n};\n\nexport function getNextVoltoBlock(index, properties) {\n  // TODO: look for any next slate block\n  // join this block with previous block, if previous block is slate\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const blocks_layout = properties[blocksLayoutFieldname];\n\n  if (index === blocks_layout.items.length) return;\n\n  const nextBlockId = blocks_layout.items[index + 1];\n  const nextBlock = properties[blocksFieldname][nextBlockId];\n\n  return [nextBlock, nextBlockId];\n}\n\nexport function getPreviousVoltoBlock(index, properties) {\n  // TODO: look for any prev slate block\n  if (index === 0) return;\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const blocks_layout = properties[blocksLayoutFieldname];\n  const prevBlockId = blocks_layout.items[index - 1];\n  const prevBlock = properties[blocksFieldname][prevBlockId];\n\n  return [prevBlock, prevBlockId];\n}\n\n// //check for existing img children\n// const checkContainImg = (elements) => {\n//   var check = false;\n//   elements.forEach((e) =>\n//     e.children.forEach((c) => {\n//       if (c && c.type && c.type === 'img') {\n//         check = true;\n//       }\n//     }),\n//   );\n//   return check;\n// };\n\n// //check for existing table children\n// const checkContainTable = (elements) => {\n//   var check = false;\n//   elements.forEach((e) => {\n//     if (e && e.type && e.type === 'table') {\n//       check = true;\n//     }\n//   });\n//   return check;\n// };\n\n/**\n * The editor has the properties `dataTransferHandlers` (object) and\n * `dataTransferFormatsOrder` and in `dataTransferHandlers` are functions which\n * sometimes must call this function. Some types of data storeable in Slate\n * documents can be and should be put into separate Volto blocks. The\n * `deconstructToVoltoBlocks` function scans the contents of the Slate document\n * and, through configured Volto block emitters, it outputs separate Volto\n * blocks into the same Volto page form. The `deconstructToVoltoBlocks` function\n * should be called only in key places where it is necessary.\n *\n * @example See the `src/editor/extensions/insertData.js` file.\n *\n * @param {Editor} editor The Slate editor object which should be deconstructed\n * if possible.\n *\n * @returns {Promise}\n */\nexport function deconstructToVoltoBlocks(editor) {\n  // Explodes editor content into separate blocks\n  // If the editor has multiple top-level children, split the current block\n  // into multiple slate blocks. This will delete and replace the current\n  // block.\n  //\n  // It returns a promise that, when resolved, will pass a list of Volto block\n  // ids that were affected\n  //\n  // For the Volto blocks manipulation we do low-level changes to the context\n  // form state, as that ensures a better performance (no un-needed UI updates)\n\n  if (!editor.getBlockProps) return;\n\n  const blockProps = editor.getBlockProps();\n  const { slate } = config.settings;\n  const { voltoBlockEmiters } = slate;\n\n  return new Promise((resolve, reject) => {\n    if (!editor?.children) return;\n\n    if (editor.children.length === 1) {\n      return resolve([blockProps.block]);\n    }\n    const { properties, onChangeField, onSelectBlock } = editor.getBlockProps();\n    const blocksFieldname = getBlocksFieldname(properties);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n    const { index } = blockProps;\n    let blocks = [];\n\n    // TODO: should use Editor.levels() instead of Node.children\n    const pathRefs = Array.from(Node.children(editor, [])).map(([, path]) =>\n      Editor.pathRef(editor, path),\n    );\n\n    for (const pathRef of pathRefs) {\n      // extra nodes are always extracted after the text node\n      let extras = voltoBlockEmiters\n        .map((emit) => emit(editor, pathRef))\n        .flat(1);\n\n      // The node might have been replaced with a Volto block\n      if (pathRef.current) {\n        const [childNode] = Editor.node(editor, pathRef.current);\n        if (childNode && !Editor.isEmpty(editor, childNode))\n          blocks.push(syncCreateSlateBlock([childNode]));\n      }\n      blocks = [...blocks, ...extras];\n    }\n\n    const blockids = blocks.map((b) => b[0]);\n\n    // TODO: add the placeholder block, because we remove it\n    // (when we remove the current block)\n\n    const blocksData = omit(\n      {\n        ...properties[blocksFieldname],\n        ...fromEntries(blocks),\n      },\n      blockProps.block,\n    );\n    const layoutData = {\n      ...properties[blocksLayoutFieldname],\n      items: [\n        ...properties[blocksLayoutFieldname].items.slice(0, index),\n        ...blockids,\n        ...properties[blocksLayoutFieldname].items.slice(index),\n      ].filter((id) => id !== blockProps.block),\n    };\n\n    // TODO: use onChangeFormData instead of this API style\n    ReactDOM.unstable_batchedUpdates(() => {\n      onChangeField(blocksFieldname, blocksData);\n      onChangeField(blocksLayoutFieldname, layoutData);\n      onSelectBlock(blockids[blockids.length - 1]);\n      // resolve(blockids);\n      // or rather this?\n      Promise.resolve().then(resolve(blockids));\n    });\n  });\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}