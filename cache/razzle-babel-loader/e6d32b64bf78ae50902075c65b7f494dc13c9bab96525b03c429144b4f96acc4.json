{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n/**\n * Vocabularies actions.\n * @module actions/vocabularies/vocabularies\n */\n\nimport { GET_VOCABULARY, GET_VOCABULARY_TOKEN_TITLE } from '@plone/volto/constants/ActionTypes';\nimport { getVocabName } from '@plone/volto/helpers/Vocabularies/Vocabularies';\nimport qs from 'query-string';\n\n/**\n * Get vocabulary given a URL (coming from a Schema) or from a vocabulary name.\n * @function getVocabulary\n * @param {string} vocabNameOrURL Full API URL of vocabulary or vocabulary name\n * @param {string} query Only include results containing this string.\n * @param {number} start Start of result batch.\n * @param {number} b_size The size of the batch.\n * @param {string} subrequest Name of the subrequest.\n * @returns {Object} Get vocabulary action.\n */\nexport function getVocabulary({\n  vocabNameOrURL,\n  query = null,\n  start = 0,\n  size,\n  subrequest\n}) {\n  const vocabulary = getVocabName(vocabNameOrURL);\n  let queryString = `b_start=${start}${size ? '&b_size=' + size : ''}`;\n  if (query) {\n    queryString = `${queryString}&title=${query}`;\n  }\n  return {\n    type: GET_VOCABULARY,\n    vocabulary: vocabNameOrURL,\n    start,\n    request: {\n      op: 'get',\n      path: `/@vocabularies/${vocabulary}?${queryString}`\n    },\n    subrequest\n  };\n}\n\n/**\n * Get the title value given a token from vocabulary given a vocabulary URL\n * (coming from a Schema) or from a vocabulary name.\n * @function getVocabularyTokenTitle\n * @param {string} vocabNameOrURL Full API URL of vocabulary or vocabulary name\n * @param {string} token Only include results containing this string.\n * @returns {Object} Get vocabulary action.\n */\nexport function getVocabularyTokenTitle({\n  vocabNameOrURL,\n  token = null,\n  tokens = null,\n  subrequest\n}) {\n  // In case we have a URL, we have to get the vocabulary name\n  const vocabulary = getVocabName(vocabNameOrURL);\n  const queryString = _objectSpread(_objectSpread({}, token && {\n    token\n  }), tokens && {\n    tokens\n  });\n  return {\n    type: GET_VOCABULARY_TOKEN_TITLE,\n    vocabulary: vocabNameOrURL,\n    token,\n    tokens,\n    subrequest,\n    request: {\n      op: 'get',\n      path: `/@vocabularies/${vocabulary}?b_size=-1&${qs.stringify(queryString, {\n        encode: false\n      })}`\n    }\n  };\n}","map":{"version":3,"names":["GET_VOCABULARY","GET_VOCABULARY_TOKEN_TITLE","getVocabName","qs","getVocabulary","vocabNameOrURL","query","start","size","subrequest","vocabulary","queryString","type","request","op","path","getVocabularyTokenTitle","token","tokens","stringify","encode"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/actions/vocabularies/vocabularies.js"],"sourcesContent":["/**\n * Vocabularies actions.\n * @module actions/vocabularies/vocabularies\n */\n\nimport {\n  GET_VOCABULARY,\n  GET_VOCABULARY_TOKEN_TITLE,\n} from '@plone/volto/constants/ActionTypes';\nimport { getVocabName } from '@plone/volto/helpers/Vocabularies/Vocabularies';\nimport qs from 'query-string';\n\n/**\n * Get vocabulary given a URL (coming from a Schema) or from a vocabulary name.\n * @function getVocabulary\n * @param {string} vocabNameOrURL Full API URL of vocabulary or vocabulary name\n * @param {string} query Only include results containing this string.\n * @param {number} start Start of result batch.\n * @param {number} b_size The size of the batch.\n * @param {string} subrequest Name of the subrequest.\n * @returns {Object} Get vocabulary action.\n */\nexport function getVocabulary({\n  vocabNameOrURL,\n  query = null,\n  start = 0,\n  size,\n  subrequest,\n}) {\n  const vocabulary = getVocabName(vocabNameOrURL);\n\n  let queryString = `b_start=${start}${size ? '&b_size=' + size : ''}`;\n\n  if (query) {\n    queryString = `${queryString}&title=${query}`;\n  }\n  return {\n    type: GET_VOCABULARY,\n    vocabulary: vocabNameOrURL,\n    start,\n    request: {\n      op: 'get',\n      path: `/@vocabularies/${vocabulary}?${queryString}`,\n    },\n    subrequest,\n  };\n}\n\n/**\n * Get the title value given a token from vocabulary given a vocabulary URL\n * (coming from a Schema) or from a vocabulary name.\n * @function getVocabularyTokenTitle\n * @param {string} vocabNameOrURL Full API URL of vocabulary or vocabulary name\n * @param {string} token Only include results containing this string.\n * @returns {Object} Get vocabulary action.\n */\nexport function getVocabularyTokenTitle({\n  vocabNameOrURL,\n  token = null,\n  tokens = null,\n  subrequest,\n}) {\n  // In case we have a URL, we have to get the vocabulary name\n  const vocabulary = getVocabName(vocabNameOrURL);\n  const queryString = {\n    ...(token && { token }),\n    ...(tokens && { tokens }),\n  };\n\n  return {\n    type: GET_VOCABULARY_TOKEN_TITLE,\n    vocabulary: vocabNameOrURL,\n    token,\n    tokens,\n    subrequest,\n    request: {\n      op: 'get',\n      path: `/@vocabularies/${vocabulary}?b_size=-1&${qs.stringify(\n        queryString,\n        {\n          encode: false,\n        },\n      )}`,\n    },\n  };\n}\n"],"mappings":";;;AAAA;AACA;AACA;AACA;;AAEA,SACEA,cAAc,EACdC,0BAA0B,QACrB,oCAAoC;AAC3C,SAASC,YAAY,QAAQ,gDAAgD;AAC7E,OAAOC,EAAE,MAAM,cAAc;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAa,CAAC;EAC5BC,cAAc;EACdC,KAAK,GAAG,IAAI;EACZC,KAAK,GAAG,CAAC;EACTC,IAAI;EACJC;AACF,CAAC,EAAE;EACD,MAAMC,UAAU,GAAGR,YAAY,CAACG,cAAc,CAAC;EAE/C,IAAIM,WAAW,GAAI,WAAUJ,KAAM,GAAEC,IAAI,GAAG,UAAU,GAAGA,IAAI,GAAG,EAAG,EAAC;EAEpE,IAAIF,KAAK,EAAE;IACTK,WAAW,GAAI,GAAEA,WAAY,UAASL,KAAM,EAAC;EAC/C;EACA,OAAO;IACLM,IAAI,EAAEZ,cAAc;IACpBU,UAAU,EAAEL,cAAc;IAC1BE,KAAK;IACLM,OAAO,EAAE;MACPC,EAAE,EAAE,KAAK;MACTC,IAAI,EAAG,kBAAiBL,UAAW,IAAGC,WAAY;IACpD,CAAC;IACDF;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,uBAAuB,CAAC;EACtCX,cAAc;EACdY,KAAK,GAAG,IAAI;EACZC,MAAM,GAAG,IAAI;EACbT;AACF,CAAC,EAAE;EACD;EACA,MAAMC,UAAU,GAAGR,YAAY,CAACG,cAAc,CAAC;EAC/C,MAAMM,WAAW,mCACXM,KAAK,IAAI;IAAEA;EAAM,CAAC,GAClBC,MAAM,IAAI;IAAEA;EAAO,CAAC,CACzB;EAED,OAAO;IACLN,IAAI,EAAEX,0BAA0B;IAChCS,UAAU,EAAEL,cAAc;IAC1BY,KAAK;IACLC,MAAM;IACNT,UAAU;IACVI,OAAO,EAAE;MACPC,EAAE,EAAE,KAAK;MACTC,IAAI,EAAG,kBAAiBL,UAAW,cAAaP,EAAE,CAACgB,SAAS,CAC1DR,WAAW,EACX;QACES,MAAM,EAAE;MACV,CAAC,CACD;IACJ;EACF,CAAC;AACH"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}