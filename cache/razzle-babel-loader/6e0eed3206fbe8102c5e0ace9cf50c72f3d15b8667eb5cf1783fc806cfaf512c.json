{"ast":null,"code":"import _toPairs from \"lodash/toPairs\";\nimport _pickBy from \"lodash/pickBy\";\nimport _map from \"lodash/map\";\nimport _join from \"lodash/join\";\nimport _isArray from \"lodash/isArray\";\nimport _concat from \"lodash/concat\";\nimport _compact from \"lodash/compact\";\nimport redraft from 'redraft';\nimport config from '@plone/volto/registry';\nvar url = require('url');\n\n// NOTE: this needs to be improvded to recursively convert the query to qs\n// Right now it fails on a query such as:\n// {custom_query: [{o:'any', i: 'portal_type', v: 'Document'}]}\n\nexport function dataToQueryString(data) {\n  var queryArray = [];\n  var arrayOptions = _pickBy(data, function (item) {\n    return _isArray(item);\n  });\n  queryArray = _concat(queryArray, data ? _join(_map(_toPairs(_pickBy(data, function (item) {\n    return !_isArray(item);\n  })), function (item) {\n    if (item[0] === 'SearchableText') {\n      // Adds the wildcard to the SearchableText param\n      item[1] = \"\".concat(item[1], \"*\");\n    }\n    return _join(item, '=');\n  }), '&') : '');\n  queryArray = _concat(queryArray, arrayOptions ? _join(_map(_pickBy(arrayOptions), function (item, key) {\n    return _join(item.map(function (value) {\n      return \"\".concat(key, \":list=\").concat(value);\n    }), '&');\n  }), '&') : '');\n  var querystring = _join(_compact(queryArray), '&');\n  return querystring;\n}\n\n// if URL matches a defined cors proxy destination, then use the cors proxy\nexport function useCorsproxy(targetUrl) {\n  var allowed_cors_destinations = config.settings.allowed_cors_destinations || [];\n  var parsed = url.parse(targetUrl);\n  var nextUrl = allowed_cors_destinations.indexOf(parsed.host) === -1 ? targetUrl : \"/cors-proxy/\".concat(targetUrl);\n  // console.log('url is', nextUrl, parsed.host, allowed_cors_destinations);\n  return nextUrl;\n}\nexport function renderDraft(draftValue) {\n  return draftValue ? redraft(draftValue, config.settings.ToHTMLRenderers, config.settings.ToHTMLOptions) : '';\n}","map":{"version":3,"names":["redraft","config","url","require","dataToQueryString","data","queryArray","arrayOptions","item","key","map","value","querystring","useCorsproxy","targetUrl","allowed_cors_destinations","settings","parsed","parse","nextUrl","indexOf","host","renderDraft","draftValue","ToHTMLRenderers","ToHTMLOptions"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-addons-forest/src/helpers.js"],"sourcesContent":["import redraft from 'redraft';\nimport { compact, concat, isArray, join, map, pickBy, toPairs } from 'lodash';\nimport config from '@plone/volto/registry';\nconst url = require('url');\n\n// NOTE: this needs to be improvded to recursively convert the query to qs\n// Right now it fails on a query such as:\n// {custom_query: [{o:'any', i: 'portal_type', v: 'Document'}]}\n\nexport function dataToQueryString(data) {\n  let queryArray = [];\n  const arrayOptions = pickBy(data, (item) => isArray(item));\n\n  queryArray = concat(\n    queryArray,\n    data\n      ? join(\n          map(toPairs(pickBy(data, (item) => !isArray(item))), (item) => {\n            if (item[0] === 'SearchableText') {\n              // Adds the wildcard to the SearchableText param\n              item[1] = `${item[1]}*`;\n            }\n            return join(item, '=');\n          }),\n          '&',\n        )\n      : '',\n  );\n\n  queryArray = concat(\n    queryArray,\n    arrayOptions\n      ? join(\n          map(pickBy(arrayOptions), (item, key) =>\n            join(\n              item.map((value) => `${key}:list=${value}`),\n              '&',\n            ),\n          ),\n          '&',\n        )\n      : '',\n  );\n\n  const querystring = join(compact(queryArray), '&');\n  return querystring;\n}\n\n// if URL matches a defined cors proxy destination, then use the cors proxy\nexport function useCorsproxy(targetUrl) {\n  const allowed_cors_destinations =\n    config.settings.allowed_cors_destinations || [];\n  const parsed = url.parse(targetUrl);\n  const nextUrl =\n    allowed_cors_destinations.indexOf(parsed.host) === -1\n      ? targetUrl\n      : `/cors-proxy/${targetUrl}`;\n  // console.log('url is', nextUrl, parsed.host, allowed_cors_destinations);\n  return nextUrl;\n}\n\nexport function renderDraft(draftValue) {\n  return draftValue\n    ? redraft(\n        draftValue,\n        config.settings.ToHTMLRenderers,\n        config.settings.ToHTMLOptions,\n      )\n    : '';\n}\n"],"mappings":";;;;;;;AAAA,OAAOA,OAAO,MAAM,SAAS;AAE7B,OAAOC,MAAM,MAAM,uBAAuB;AAC1C,IAAMC,GAAG,GAAGC,OAAO,CAAC,KAAK,CAAC;;AAE1B;AACA;AACA;;AAEA,OAAO,SAASC,iBAAiB,CAACC,IAAI,EAAE;EACtC,IAAIC,UAAU,GAAG,EAAE;EACnB,IAAMC,YAAY,GAAG,QAAOF,IAAI,EAAE,UAACG,IAAI;IAAA,OAAK,SAAQA,IAAI,CAAC;EAAA,EAAC;EAE1DF,UAAU,GAAG,QACXA,UAAU,EACVD,IAAI,GACA,MACE,KAAI,SAAQ,QAAOA,IAAI,EAAE,UAACG,IAAI;IAAA,OAAK,CAAC,SAAQA,IAAI,CAAC;EAAA,EAAC,CAAC,EAAE,UAACA,IAAI,EAAK;IAC7D,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,gBAAgB,EAAE;MAChC;MACAA,IAAI,CAAC,CAAC,CAAC,aAAMA,IAAI,CAAC,CAAC,CAAC,MAAG;IACzB;IACA,OAAO,MAAKA,IAAI,EAAE,GAAG,CAAC;EACxB,CAAC,CAAC,EACF,GAAG,CACJ,GACD,EAAE,CACP;EAEDF,UAAU,GAAG,QACXA,UAAU,EACVC,YAAY,GACR,MACE,KAAI,QAAOA,YAAY,CAAC,EAAE,UAACC,IAAI,EAAEC,GAAG;IAAA,OAClC,MACED,IAAI,CAACE,GAAG,CAAC,UAACC,KAAK;MAAA,iBAAQF,GAAG,mBAASE,KAAK;IAAA,CAAE,CAAC,EAC3C,GAAG,CACJ;EAAA,EACF,EACD,GAAG,CACJ,GACD,EAAE,CACP;EAED,IAAMC,WAAW,GAAG,MAAK,SAAQN,UAAU,CAAC,EAAE,GAAG,CAAC;EAClD,OAAOM,WAAW;AACpB;;AAEA;AACA,OAAO,SAASC,YAAY,CAACC,SAAS,EAAE;EACtC,IAAMC,yBAAyB,GAC7Bd,MAAM,CAACe,QAAQ,CAACD,yBAAyB,IAAI,EAAE;EACjD,IAAME,MAAM,GAAGf,GAAG,CAACgB,KAAK,CAACJ,SAAS,CAAC;EACnC,IAAMK,OAAO,GACXJ,yBAAyB,CAACK,OAAO,CAACH,MAAM,CAACI,IAAI,CAAC,KAAK,CAAC,CAAC,GACjDP,SAAS,yBACMA,SAAS,CAAE;EAChC;EACA,OAAOK,OAAO;AAChB;AAEA,OAAO,SAASG,WAAW,CAACC,UAAU,EAAE;EACtC,OAAOA,UAAU,GACbvB,OAAO,CACLuB,UAAU,EACVtB,MAAM,CAACe,QAAQ,CAACQ,eAAe,EAC/BvB,MAAM,CAACe,QAAQ,CAACS,aAAa,CAC9B,GACD,EAAE;AACR"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}