{"ast":null,"code":"import _toPairs from \"lodash/toPairs\";\nimport _keys from \"lodash/keys\";\nimport _isObject from \"lodash/isObject\";\nimport _find from \"lodash/find\";\nimport _endsWith from \"lodash/endsWith\";\nimport _without from \"lodash/without\";\nimport _omit from \"lodash/omit\";\nconst _excluded = [\"data\", \"intl\"];\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport move from 'lodash-move';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { applySchemaEnhancer } from '@plone/volto/helpers';\n\n/**\n * Get blocks field.\n * @function getBlocksFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks\n */\nexport function getBlocksFieldname(props) {\n  return _find(_keys(props), key => key !== 'volto.blocks' && _endsWith(key, 'blocks')) || null;\n}\n\n/**\n * Get blocks layout field.\n * @function getBlocksLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks layout\n */\nexport function getBlocksLayoutFieldname(props) {\n  return _find(_keys(props), key => key !== 'volto.blocks' && _endsWith(key, 'blocks_layout')) || null;\n}\n\n/**\n * Has blocks data.\n * @function hasBlocksData\n * @param {Object} props Properties.\n * @return {boolean} True if it has blocks data.\n */\nexport function hasBlocksData(props) {\n  return _find(_keys(props), key => key !== 'volto.blocks' && _endsWith(key, 'blocks')) !== undefined;\n}\n\n/**\n * Pluggable method to test if a block has a set value (any non-empty value)\n * @function blockHasValue\n * @param {Object} data Block data\n * @return {boolean} True if block has a non-empty value\n */\nexport function blockHasValue(data) {\n  var _blocks$blocksConfig$;\n  const {\n    blocks\n  } = config;\n  const blockType = data['@type'];\n  const check = (_blocks$blocksConfig$ = blocks.blocksConfig[blockType]) === null || _blocks$blocksConfig$ === void 0 ? void 0 : _blocks$blocksConfig$.blockHasValue;\n  if (!check) {\n    return true;\n  }\n  return check(data);\n}\n\n/**\n * Get block pairs of [id, block] from content properties\n * @function getBlocks\n * @param {Object} properties\n * @return {Array} a list of block [id, value] pairs, in order from layout\n */\nexport const getBlocks = properties => {\n  var _properties$blocksLay, _properties$blocksLay2;\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  return ((_properties$blocksLay = properties[blocksLayoutFieldname]) === null || _properties$blocksLay === void 0 ? void 0 : (_properties$blocksLay2 = _properties$blocksLay.items) === null || _properties$blocksLay2 === void 0 ? void 0 : _properties$blocksLay2.map(n => [n, properties[blocksFieldName][n]])) || [];\n};\n\n/**\n * Move block to different location index within blocks_layout\n * @function moveBlock\n * @param {Object} formData Form data\n * @param {number} source index within form blocks_layout items\n * @param {number} destination index within form blocks_layout items\n * @return {Object} New form data\n */\nexport function moveBlock(formData, source, destination) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: move(formData[blocksLayoutFieldname].items, source, destination)\n    }\n  });\n}\n\n/**\n * Delete block by id\n * @function deleteBlock\n * @param {Object} formData Form data\n * @param {string} blockId Block uid\n * @return {Object} New form data\n */\nexport function deleteBlock(formData, blockId) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  let newFormData = _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: _without(formData[blocksLayoutFieldname].items, blockId)\n    },\n    [blocksFieldname]: _omit(formData[blocksFieldname], [blockId])\n  });\n  if (newFormData[blocksLayoutFieldname].items.length === 0) {\n    newFormData = addBlock(newFormData, config.settings.defaultBlockType, 0);\n  }\n  return newFormData;\n}\n\n/**\n * Add block\n * @function addBlock\n * @param {Object} formData Form data\n * @param {string} type Block type\n * @param {number} index Destination index\n * @return {Array} New block id, New form data\n */\nexport function addBlock(formData, type, index) {\n  const {\n    settings\n  } = config;\n  const id = uuid();\n  const idTrailingBlock = uuid();\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const totalItems = formData[blocksLayoutFieldname].items.length;\n  const insert = index === -1 ? totalItems : index;\n  return [id, _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksLayoutFieldname]: {\n      items: [...formData[blocksLayoutFieldname].items.slice(0, insert), id, ...(type !== settings.defaultBlockType ? [idTrailingBlock] : []), ...formData[blocksLayoutFieldname].items.slice(insert)]\n    },\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [id]: {\n        '@type': type\n      }\n    }, type !== settings.defaultBlockType && {\n      [idTrailingBlock]: {\n        '@type': settings.defaultBlockType\n      }\n    }),\n    selected: id\n  })];\n}\n\n/**\n * Mutate block\n * @function mutateBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to mutate\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function mutateBlock(formData, id, value) {\n  const {\n    settings\n  } = config;\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id) + 1;\n\n  // Test if block at index is already a placeholder (trailing) block\n  const trailId = formData[blocksLayoutFieldname].items[index];\n  if (trailId) {\n    const block = formData[blocksFieldname][trailId];\n    if (!blockHasValue(block)) {\n      return _objectSpread(_objectSpread({}, formData), {}, {\n        [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n          [id]: value || null\n        })\n      });\n    }\n  }\n  const idTrailingBlock = uuid();\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [id]: value || null,\n      [idTrailingBlock]: {\n        '@type': settings.defaultBlockType\n      }\n    }),\n    [blocksLayoutFieldname]: {\n      items: [...formData[blocksLayoutFieldname].items.slice(0, index), idTrailingBlock, ...formData[blocksLayoutFieldname].items.slice(index)]\n    }\n  });\n}\n\n/**\n * Insert new block before another block\n * @function insertBlock\n * @param {Object} formData Form data\n * @param {string} id Insert new block before the block with this id\n * @param {number} value New block's value\n * @return {Array} New block id, New form data\n */\nexport function insertBlock(formData, id, value, current = {}) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id);\n  const newBlockId = uuid();\n  return [newBlockId, _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [newBlockId]: value || null,\n      [id]: _objectSpread(_objectSpread({}, formData[blocksFieldname][id]), current)\n    }),\n    [blocksLayoutFieldname]: {\n      items: [...formData[blocksLayoutFieldname].items.slice(0, index), newBlockId, ...formData[blocksLayoutFieldname].items.slice(index)]\n    }\n  })];\n}\n\n/**\n * Change block\n * @function changeBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to change\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function changeBlock(formData, id, value) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  return _objectSpread(_objectSpread({}, formData), {}, {\n    [blocksFieldname]: _objectSpread(_objectSpread({}, formData[blocksFieldname]), {}, {\n      [id]: value || null\n    })\n  });\n}\n\n/**\n * Get the next block UID within form\n * @function nextBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Next block uid\n */\nexport function nextBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(currentBlock);\n  if (currentIndex === formData[blocksLayoutFieldname].items.length - 1) {\n    // We are already at the bottom block don't do anything\n    return null;\n  }\n  const newIndex = currentIndex + 1;\n  return formData[blocksLayoutFieldname].items[newIndex];\n}\n\n/**\n * Get the previous block UID within form\n * @function previousBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Previous block uid\n */\nexport function previousBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(currentBlock);\n  if (currentIndex === 0) {\n    // We are already at the top block don't do anything\n    return null;\n  }\n  const newindex = currentIndex - 1;\n  return formData[blocksLayoutFieldname].items[newindex];\n}\n\n/**\n * Generate empty block form\n * @function emptyBlocksForm\n * @param {Object} formData Form data\n * @return {Object} Empty blocks form with one defaultBlockType block\n */\nexport function emptyBlocksForm() {\n  const {\n    settings\n  } = config;\n  const id = uuid();\n  return {\n    blocks: {\n      [id]: {\n        '@type': settings.defaultBlockType\n      }\n    },\n    blocks_layout: {\n      items: [id]\n    }\n  };\n}\n\n/**\n * Recursively discover blocks in data and call the provided callback\n * @function visitBlocks\n * @param {Object} content A content data structure (an object with blocks and blocks_layout)\n * @param {Function} callback A function to call on each discovered block\n */\nexport function visitBlocks(content, callback) {\n  const queue = getBlocks(content);\n  while (queue.length > 0) {\n    const [id, blockdata] = queue.shift();\n    callback([id, blockdata]);\n\n    // assumes that a block value is like: {blocks, blocks_layout} or\n    // { data: {blocks, blocks_layout}}\n    if (Object.keys(blockdata || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata));\n    }\n    if (Object.keys((blockdata === null || blockdata === void 0 ? void 0 : blockdata.data) || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata.data));\n    }\n  }\n}\n\n/**\n * Initializes data with the default values coming from schema\n */\nexport function applySchemaDefaults({\n  data = {},\n  schema\n}) {\n  const derivedData = _objectSpread(_objectSpread({}, Object.keys(schema.properties).reduce((accumulator, currentField) => {\n    return schema.properties[currentField].default ? _objectSpread(_objectSpread({}, accumulator), {}, {\n      [currentField]: schema.properties[currentField].default\n    }) : accumulator;\n  }, {})), data);\n  return derivedData;\n}\n\n/**\n * Apply the block's default (as defined in schema) to the block data.\n *\n * @function applyBlockDefaults\n * @param {Object} params An object with data, intl and anything else\n * @return {Object} Derived data, with the defaults extracted from the schema\n */\nexport function applyBlockDefaults(_ref, blocksConfig) {\n  let {\n      data,\n      intl\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  const block_type = data['@type'];\n  const {\n    blockSchema\n  } = (blocksConfig || config.blocks.blocksConfig)[block_type] || {};\n  if (!blockSchema) return data;\n  let schema = typeof blockSchema === 'function' ? blockSchema(_objectSpread({\n    data,\n    intl\n  }, rest)) : blockSchema;\n  schema = applySchemaEnhancer({\n    schema,\n    formData: data,\n    intl\n  });\n  return applySchemaDefaults({\n    data,\n    schema\n  });\n}\nexport const buildStyleClassNamesFromData = styles => {\n  // styles has the form\n  // const styles = {\n  // color: 'red',\n  // backgroundColor: '#AABBCC',\n  // }\n  // Returns: ['has--color--red', 'has--backgroundColor--AABBCC']\n  let styleArray = [];\n  const pairedStyles = _toPairs(styles);\n  pairedStyles.forEach(item => {\n    if (_isObject(item[1])) {\n      const flattenedNestedStyles = _toPairs(item[1]).map(nested => [item[0], ...nested]);\n      flattenedNestedStyles.forEach(sub => styleArray.push(sub));\n    } else {\n      styleArray.push(item);\n    }\n  });\n  return styleArray.map(item => {\n    const classname = item.map(item => {\n      const str_item = item ? item.toString() : '';\n      return str_item && str_item.startsWith('#') ? str_item.replace('#', '') : str_item;\n    });\n    return `has--${classname[0]}--${classname[1]}${classname[2] ? `--${classname[2]}` : ''}`;\n  });\n};","map":{"version":3,"names":["move","v4","uuid","config","applySchemaEnhancer","getBlocksFieldname","props","key","getBlocksLayoutFieldname","hasBlocksData","undefined","blockHasValue","data","blocks","blockType","check","blocksConfig","getBlocks","properties","blocksFieldName","blocksLayoutFieldname","items","map","n","moveBlock","formData","source","destination","deleteBlock","blockId","blocksFieldname","newFormData","length","addBlock","settings","defaultBlockType","type","index","id","idTrailingBlock","totalItems","insert","slice","selected","mutateBlock","value","indexOf","trailId","block","insertBlock","current","newBlockId","changeBlock","nextBlockId","currentBlock","currentIndex","newIndex","previousBlockId","newindex","emptyBlocksForm","blocks_layout","visitBlocks","content","callback","queue","blockdata","shift","Object","keys","push","applySchemaDefaults","schema","derivedData","reduce","accumulator","currentField","default","applyBlockDefaults","intl","rest","block_type","blockSchema","buildStyleClassNamesFromData","styles","styleArray","pairedStyles","forEach","item","flattenedNestedStyles","nested","sub","classname","str_item","toString","startsWith","replace"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/Blocks/Blocks.js"],"sourcesContent":["/**\n * Blocks helper.\n * @module helpers/Blocks\n */\n\nimport { omit, without, endsWith, find, isObject, keys, toPairs } from 'lodash';\nimport move from 'lodash-move';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { applySchemaEnhancer } from '@plone/volto/helpers';\n\n/**\n * Get blocks field.\n * @function getBlocksFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks\n */\nexport function getBlocksFieldname(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks'),\n    ) || null\n  );\n}\n\n/**\n * Get blocks layout field.\n * @function getBlocksLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the blocks layout\n */\nexport function getBlocksLayoutFieldname(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks_layout'),\n    ) || null\n  );\n}\n\n/**\n * Has blocks data.\n * @function hasBlocksData\n * @param {Object} props Properties.\n * @return {boolean} True if it has blocks data.\n */\nexport function hasBlocksData(props) {\n  return (\n    find(\n      keys(props),\n      (key) => key !== 'volto.blocks' && endsWith(key, 'blocks'),\n    ) !== undefined\n  );\n}\n\n/**\n * Pluggable method to test if a block has a set value (any non-empty value)\n * @function blockHasValue\n * @param {Object} data Block data\n * @return {boolean} True if block has a non-empty value\n */\nexport function blockHasValue(data) {\n  const { blocks } = config;\n  const blockType = data['@type'];\n  const check = blocks.blocksConfig[blockType]?.blockHasValue;\n  if (!check) {\n    return true;\n  }\n  return check(data);\n}\n\n/**\n * Get block pairs of [id, block] from content properties\n * @function getBlocks\n * @param {Object} properties\n * @return {Array} a list of block [id, value] pairs, in order from layout\n */\nexport const getBlocks = (properties) => {\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  return (\n    properties[blocksLayoutFieldname]?.items?.map((n) => [\n      n,\n      properties[blocksFieldName][n],\n    ]) || []\n  );\n};\n\n/**\n * Move block to different location index within blocks_layout\n * @function moveBlock\n * @param {Object} formData Form data\n * @param {number} source index within form blocks_layout items\n * @param {number} destination index within form blocks_layout items\n * @return {Object} New form data\n */\nexport function moveBlock(formData, source, destination) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  return {\n    ...formData,\n    [blocksLayoutFieldname]: {\n      items: move(formData[blocksLayoutFieldname].items, source, destination),\n    },\n  };\n}\n\n/**\n * Delete block by id\n * @function deleteBlock\n * @param {Object} formData Form data\n * @param {string} blockId Block uid\n * @return {Object} New form data\n */\nexport function deleteBlock(formData, blockId) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n\n  let newFormData = {\n    ...formData,\n    [blocksLayoutFieldname]: {\n      items: without(formData[blocksLayoutFieldname].items, blockId),\n    },\n    [blocksFieldname]: omit(formData[blocksFieldname], [blockId]),\n  };\n\n  if (newFormData[blocksLayoutFieldname].items.length === 0) {\n    newFormData = addBlock(newFormData, config.settings.defaultBlockType, 0);\n  }\n\n  return newFormData;\n}\n\n/**\n * Add block\n * @function addBlock\n * @param {Object} formData Form data\n * @param {string} type Block type\n * @param {number} index Destination index\n * @return {Array} New block id, New form data\n */\nexport function addBlock(formData, type, index) {\n  const { settings } = config;\n  const id = uuid();\n  const idTrailingBlock = uuid();\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const totalItems = formData[blocksLayoutFieldname].items.length;\n  const insert = index === -1 ? totalItems : index;\n\n  return [\n    id,\n    {\n      ...formData,\n      [blocksLayoutFieldname]: {\n        items: [\n          ...formData[blocksLayoutFieldname].items.slice(0, insert),\n          id,\n          ...(type !== settings.defaultBlockType ? [idTrailingBlock] : []),\n          ...formData[blocksLayoutFieldname].items.slice(insert),\n        ],\n      },\n      [blocksFieldname]: {\n        ...formData[blocksFieldname],\n        [id]: {\n          '@type': type,\n        },\n        ...(type !== settings.defaultBlockType && {\n          [idTrailingBlock]: {\n            '@type': settings.defaultBlockType,\n          },\n        }),\n      },\n      selected: id,\n    },\n  ];\n}\n\n/**\n * Mutate block\n * @function mutateBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to mutate\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function mutateBlock(formData, id, value) {\n  const { settings } = config;\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id) + 1;\n\n  // Test if block at index is already a placeholder (trailing) block\n  const trailId = formData[blocksLayoutFieldname].items[index];\n  if (trailId) {\n    const block = formData[blocksFieldname][trailId];\n    if (!blockHasValue(block)) {\n      return {\n        ...formData,\n        [blocksFieldname]: {\n          ...formData[blocksFieldname],\n          [id]: value || null,\n        },\n      };\n    }\n  }\n\n  const idTrailingBlock = uuid();\n  return {\n    ...formData,\n    [blocksFieldname]: {\n      ...formData[blocksFieldname],\n      [id]: value || null,\n      [idTrailingBlock]: {\n        '@type': settings.defaultBlockType,\n      },\n    },\n    [blocksLayoutFieldname]: {\n      items: [\n        ...formData[blocksLayoutFieldname].items.slice(0, index),\n        idTrailingBlock,\n        ...formData[blocksLayoutFieldname].items.slice(index),\n      ],\n    },\n  };\n}\n\n/**\n * Insert new block before another block\n * @function insertBlock\n * @param {Object} formData Form data\n * @param {string} id Insert new block before the block with this id\n * @param {number} value New block's value\n * @return {Array} New block id, New form data\n */\nexport function insertBlock(formData, id, value, current = {}) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const index = formData[blocksLayoutFieldname].items.indexOf(id);\n\n  const newBlockId = uuid();\n  return [\n    newBlockId,\n    {\n      ...formData,\n      [blocksFieldname]: {\n        ...formData[blocksFieldname],\n        [newBlockId]: value || null,\n        [id]: {\n          ...formData[blocksFieldname][id],\n          ...current,\n        },\n      },\n      [blocksLayoutFieldname]: {\n        items: [\n          ...formData[blocksLayoutFieldname].items.slice(0, index),\n          newBlockId,\n          ...formData[blocksLayoutFieldname].items.slice(index),\n        ],\n      },\n    },\n  ];\n}\n\n/**\n * Change block\n * @function changeBlock\n * @param {Object} formData Form data\n * @param {string} id Block uid to change\n * @param {number} value Block's new value\n * @return {Object} New form data\n */\nexport function changeBlock(formData, id, value) {\n  const blocksFieldname = getBlocksFieldname(formData);\n  return {\n    ...formData,\n    [blocksFieldname]: {\n      ...formData[blocksFieldname],\n      [id]: value || null,\n    },\n  };\n}\n\n/**\n * Get the next block UID within form\n * @function nextBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Next block uid\n */\nexport function nextBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(\n    currentBlock,\n  );\n\n  if (currentIndex === formData[blocksLayoutFieldname].items.length - 1) {\n    // We are already at the bottom block don't do anything\n    return null;\n  }\n\n  const newIndex = currentIndex + 1;\n  return formData[blocksLayoutFieldname].items[newIndex];\n}\n\n/**\n * Get the previous block UID within form\n * @function previousBlockId\n * @param {Object} formData Form data\n * @param {string} currentBlock Block uid\n * @return {string} Previous block uid\n */\nexport function previousBlockId(formData, currentBlock) {\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(formData);\n  const currentIndex = formData[blocksLayoutFieldname].items.indexOf(\n    currentBlock,\n  );\n\n  if (currentIndex === 0) {\n    // We are already at the top block don't do anything\n    return null;\n  }\n  const newindex = currentIndex - 1;\n  return formData[blocksLayoutFieldname].items[newindex];\n}\n\n/**\n * Generate empty block form\n * @function emptyBlocksForm\n * @param {Object} formData Form data\n * @return {Object} Empty blocks form with one defaultBlockType block\n */\nexport function emptyBlocksForm() {\n  const { settings } = config;\n  const id = uuid();\n  return {\n    blocks: {\n      [id]: {\n        '@type': settings.defaultBlockType,\n      },\n    },\n    blocks_layout: { items: [id] },\n  };\n}\n\n/**\n * Recursively discover blocks in data and call the provided callback\n * @function visitBlocks\n * @param {Object} content A content data structure (an object with blocks and blocks_layout)\n * @param {Function} callback A function to call on each discovered block\n */\nexport function visitBlocks(content, callback) {\n  const queue = getBlocks(content);\n  while (queue.length > 0) {\n    const [id, blockdata] = queue.shift();\n    callback([id, blockdata]);\n\n    // assumes that a block value is like: {blocks, blocks_layout} or\n    // { data: {blocks, blocks_layout}}\n    if (Object.keys(blockdata || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata));\n    }\n    if (Object.keys(blockdata?.data || {}).indexOf('blocks') > -1) {\n      queue.push(...getBlocks(blockdata.data));\n    }\n  }\n}\n\n/**\n * Initializes data with the default values coming from schema\n */\nexport function applySchemaDefaults({ data = {}, schema }) {\n  const derivedData = {\n    ...Object.keys(schema.properties).reduce((accumulator, currentField) => {\n      return schema.properties[currentField].default\n        ? {\n            ...accumulator,\n            [currentField]: schema.properties[currentField].default,\n          }\n        : accumulator;\n    }, {}),\n    ...data,\n  };\n  return derivedData;\n}\n\n/**\n * Apply the block's default (as defined in schema) to the block data.\n *\n * @function applyBlockDefaults\n * @param {Object} params An object with data, intl and anything else\n * @return {Object} Derived data, with the defaults extracted from the schema\n */\nexport function applyBlockDefaults({ data, intl, ...rest }, blocksConfig) {\n  const block_type = data['@type'];\n  const { blockSchema } =\n    (blocksConfig || config.blocks.blocksConfig)[block_type] || {};\n  if (!blockSchema) return data;\n\n  let schema =\n    typeof blockSchema === 'function'\n      ? blockSchema({ data, intl, ...rest })\n      : blockSchema;\n  schema = applySchemaEnhancer({ schema, formData: data, intl });\n\n  return applySchemaDefaults({ data, schema });\n}\n\nexport const buildStyleClassNamesFromData = (styles) => {\n  // styles has the form\n  // const styles = {\n  // color: 'red',\n  // backgroundColor: '#AABBCC',\n  // }\n  // Returns: ['has--color--red', 'has--backgroundColor--AABBCC']\n  let styleArray = [];\n  const pairedStyles = toPairs(styles);\n  pairedStyles.forEach((item) => {\n    if (isObject(item[1])) {\n      const flattenedNestedStyles = toPairs(item[1]).map((nested) => [\n        item[0],\n        ...nested,\n      ]);\n      flattenedNestedStyles.forEach((sub) => styleArray.push(sub));\n    } else {\n      styleArray.push(item);\n    }\n  });\n  return styleArray.map((item) => {\n    const classname = item.map((item) => {\n      const str_item = item ? item.toString() : '';\n      return str_item && str_item.startsWith('#')\n        ? str_item.replace('#', '')\n        : str_item;\n    });\n    return `has--${classname[0]}--${classname[1]}${\n      classname[2] ? `--${classname[2]}` : ''\n    }`;\n  });\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}