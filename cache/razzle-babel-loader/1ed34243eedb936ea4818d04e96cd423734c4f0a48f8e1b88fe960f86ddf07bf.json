{"ast":null,"code":"const _excluded = [\"location\", \"routes\", \"filter\"];\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nimport { matchRoutes } from 'react-router-config';\nimport { mapSeries, isPromise } from './utils';\nimport { endGlobalLoad } from '@plone/volto/actions/asyncConnect/asyncConnect';\nexport function filterComponents(branch) {\n  return branch.reduce((result, {\n    route,\n    match\n  }) => {\n    if (route.component && route.component.reduxAsyncConnect) {\n      result.push([route.component, {\n        route,\n        match\n      }]);\n    }\n    return result;\n  }, []);\n}\nexport function loadAsyncConnect(_ref) {\n  let {\n      location,\n      routes = [],\n      filter = () => true\n    } = _ref,\n    rest = _objectWithoutProperties(_ref, _excluded);\n  const layered = filterComponents(matchRoutes(routes, location.pathname));\n  if (layered.length === 0) {\n    return Promise.resolve();\n  }\n\n  // this allows us to have nested promises, that rely on each other's completion\n  // cycle\n  return mapSeries(layered, ([component, routeParams]) => {\n    if (component == null) {\n      return Promise.resolve();\n    }\n\n    // Collect the results of each component\n    const results = [];\n    const asyncItems = component.reduxAsyncConnect;\n    const asyncItemsArr = [...component.reduxAsyncConnect];\n\n    // get array of results\n    asyncItems.forEach(item => {\n      if (filter(item, component)) {\n        // handle Volto's voltoLoadAsyncProps\n        if (item.key === 'voltoLoadAsyncProps') {\n          results.push(item);\n          const asyncPropsItems = item.promise(_objectSpread(_objectSpread(_objectSpread({}, rest), routeParams), {}, {\n            location,\n            routes\n          }));\n          asyncItemsArr.push(...asyncPropsItems);\n          asyncPropsItems.forEach(asyncPropItem => {\n            let innerPromiseOrResult = asyncPropItem && asyncPropItem.promise || asyncPropItem;\n            if (isPromise(innerPromiseOrResult)) {\n              innerPromiseOrResult = innerPromiseOrResult.catch(error => ({\n                error\n              }));\n            }\n            results.push(innerPromiseOrResult);\n          });\n          return;\n        }\n\n        // handles default case of classic asyncConnect\n        let promiseOrResult = item.promise(_objectSpread(_objectSpread(_objectSpread({}, rest), routeParams), {}, {\n          location,\n          routes\n        }));\n        if (isPromise(promiseOrResult)) {\n          promiseOrResult = promiseOrResult.catch(error => ({\n            error\n          }));\n        }\n        results.push(promiseOrResult);\n      }\n    });\n\n    // map results to keys for prop injection\n    const resolver = finalResults => {\n      return Object.assign({}, finalResults.map((result, idx) => {\n        const {\n          key\n        } = asyncItemsArr[idx];\n        return key ? {\n          [key]: result\n        } : null;\n      }));\n    };\n    return Promise.all(results).then(resolver);\n  });\n}\nexport function loadOnServer(args) {\n  return loadAsyncConnect(args).then(() => {\n    args.store.dispatch(endGlobalLoad());\n  });\n}","map":{"version":3,"names":["matchRoutes","mapSeries","isPromise","endGlobalLoad","filterComponents","branch","reduce","result","route","match","component","reduxAsyncConnect","push","loadAsyncConnect","location","routes","filter","rest","layered","pathname","length","Promise","resolve","routeParams","results","asyncItems","asyncItemsArr","forEach","item","key","asyncPropsItems","promise","asyncPropItem","innerPromiseOrResult","catch","error","promiseOrResult","resolver","finalResults","Object","assign","map","idx","all","then","loadOnServer","args","store","dispatch"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/AsyncConnect/ssr.js"],"sourcesContent":["import { matchRoutes } from 'react-router-config';\nimport { mapSeries, isPromise } from './utils';\nimport { endGlobalLoad } from '@plone/volto/actions/asyncConnect/asyncConnect';\n\nexport function filterComponents(branch) {\n  return branch.reduce((result, { route, match }) => {\n    if (route.component && route.component.reduxAsyncConnect) {\n      result.push([route.component, { route, match }]);\n    }\n\n    return result;\n  }, []);\n}\n\nexport function loadAsyncConnect({\n  location,\n  routes = [],\n  filter = () => true,\n  ...rest\n}) {\n  const layered = filterComponents(matchRoutes(routes, location.pathname));\n\n  if (layered.length === 0) {\n    return Promise.resolve();\n  }\n\n  // this allows us to have nested promises, that rely on each other's completion\n  // cycle\n  return mapSeries(layered, ([component, routeParams]) => {\n    if (component == null) {\n      return Promise.resolve();\n    }\n\n    // Collect the results of each component\n    const results = [];\n    const asyncItems = component.reduxAsyncConnect;\n    const asyncItemsArr = [...component.reduxAsyncConnect];\n\n    // get array of results\n    asyncItems.forEach((item) => {\n      if (filter(item, component)) {\n        // handle Volto's voltoLoadAsyncProps\n        if (item.key === 'voltoLoadAsyncProps') {\n          results.push(item);\n          const asyncPropsItems = item.promise({\n            ...rest,\n            ...routeParams,\n            location,\n            routes,\n          });\n          asyncItemsArr.push(...asyncPropsItems);\n\n          asyncPropsItems.forEach((asyncPropItem) => {\n            let innerPromiseOrResult =\n              (asyncPropItem && asyncPropItem.promise) || asyncPropItem;\n\n            if (isPromise(innerPromiseOrResult)) {\n              innerPromiseOrResult = innerPromiseOrResult.catch((error) => ({\n                error,\n              }));\n            }\n            results.push(innerPromiseOrResult);\n          });\n          return;\n        }\n\n        // handles default case of classic asyncConnect\n        let promiseOrResult = item.promise({\n          ...rest,\n          ...routeParams,\n          location,\n          routes,\n        });\n\n        if (isPromise(promiseOrResult)) {\n          promiseOrResult = promiseOrResult.catch((error) => ({ error }));\n        }\n\n        results.push(promiseOrResult);\n      }\n    });\n\n    // map results to keys for prop injection\n    const resolver = (finalResults) => {\n      return Object.assign(\n        {},\n        finalResults.map((result, idx) => {\n          const { key } = asyncItemsArr[idx];\n          return key ? { [key]: result } : null;\n        }),\n      );\n    };\n\n    return Promise.all(results).then(resolver);\n  });\n}\n\nexport function loadOnServer(args) {\n  return loadAsyncConnect(args).then(() => {\n    args.store.dispatch(endGlobalLoad());\n  });\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}