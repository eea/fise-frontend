{"ast":null,"code":"import _transform from \"lodash/transform\";\nimport _isObject from \"lodash/isObject\";\nimport _isEqual from \"lodash/isEqual\";\nimport _flatten from \"lodash/flatten\";\nimport _cloneDeepWith from \"lodash/cloneDeepWith\";\nvar _jsxFileName = \"/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/Utils/Utils.js\";\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport React from 'react';\nimport { matchPath } from 'react-router';\nimport config from '@plone/volto/registry';\n\n/**\n * Deep diff between two object, using lodash\n * @param  {Object} object Object compared\n * @param  {Object} base   Object to compare with\n * @return {Object}        Return a new object who represent the diff\n */\nexport function difference(object, base) {\n  return _transform(object, (result, value, key) => {\n    if (!_isEqual(value, base[key])) {\n      result[key] = _isObject(value) && _isObject(base[key]) ? difference(value, base[key]) : value;\n    }\n  });\n}\n\n/**\n * Throw an error if the wrapped function returns undefined\n *\n * @param {Function} func\n */\nexport const safeWrapper = func => config => {\n  const res = func(config);\n  if (typeof res === 'undefined') {\n    throw new Error(`Configuration function doesn't return config, ${func}`);\n  }\n  return res;\n};\n\n/**\n * A helper to pipe a configuration object through configuration loaders\n *\n * @param {Array} configMethods A list of configuration methods\n * @param {Object} config The Volto singleton config object\n */\nexport function applyConfig(configMethods, config) {\n  return configMethods.reduce((acc, apply) => safeWrapper(apply)(acc), config);\n}\n\n/**\n * A HOC factory that propagates the status of asyncConnected requests back to\n * the main server process, to allow properly expressing an error status as\n * HTTP status code\n *\n * @param {} code HTTP return code\n */\nexport function withServerErrorCode(code) {\n  return WrappedComponent => props => {\n    if (props.staticContext && Object.keys(props.staticContext).length === 0) {\n      const {\n        staticContext\n      } = props;\n      staticContext.error_code = code;\n      staticContext.error = props.error;\n    }\n    return __jsx(WrappedComponent, _extends({}, props, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 60,\n        columnNumber: 12\n      }\n    }));\n  };\n}\n\n// See https://en.wikipedia.org/wiki/Web_colors#Extended_colors\nconst safeColors = ['Black', 'Blue', 'BlueViolet', 'Brown', 'Crimson', 'DarkBlue', 'DarkCyan', 'DarkGreen', 'DarkMagenta', 'DarkOliveGreen', 'DarkOrchid', 'DarkRed', 'DarkSlateBlue', 'DarkSlateGray', 'DarkViolet', 'DeepPink', 'DimGray', 'DodgerBlue', 'Firebrick', 'ForestGreen', 'Fuchsia', 'Green', 'IndianRed', 'Indigo', 'Magenta', 'Maroon', 'MediumBlue', 'MediumSlateBlue', 'MediumVioletRed', 'MidnightBlue', 'Navy', 'Olive', 'OliveDrab', 'OrangeRed', 'Purple', 'Red', 'RoyalBlue', 'SaddleBrown', 'SeaGreen', 'Sienna', 'SlateBlue', 'SlateGray', 'SteelBlue', 'Teal'];\nconst namedColors = {};\n\n/**\n * Will generate initials from string\n * @param {string} name\n * @param {integer} count\n * @returns {string} only one letter if received only one name\n */\nexport const getInitials = (title, limit) => {\n  const text = title.split(' ').map(n => n[0] ? n[0].toUpperCase() : '').join('');\n  if (limit) {\n    return text.substring(0, limit);\n  }\n  return text;\n};\n\n/**\n * Will generate a random color hex\n * Will also remmember the color for each userId\n * @param {string} userId\n */\nexport const getColor = name => {\n  const namedColor = namedColors[name] ? namedColors[name] : safeColors.length > 0 ? safeColors.pop() : `#${Math.floor(Math.random() * 16777215).toString(16)}`;\n  if (!namedColors[name]) {\n    namedColors[name] = namedColor;\n  }\n  return namedColor;\n};\n\n/**\n * Fixes TimeZones issues on moment date objects\n * Parses a DateTime and sets correct moment locale\n * @param {string} locale Current locale\n * @param {string} value DateTime string\n * @param {string} format Date format of choice\n * @returns {Object|string} Moment object or string if format is set\n */\nexport const parseDateTime = (locale, value, format, moment) => {\n  //  Used to set a server timezone or UTC as default\n  moment.updateLocale(locale, moment.localeData(locale)._config); // copy locale to moment-timezone\n  let datetime = null;\n  if (value) {\n    // check if datetime has timezone, otherwise assumes it's UTC\n    datetime = !value.match(/T/) || value.match(/T(.)*(-|\\+|Z)/g) ?\n    // Since we assume UTC everywhere, then transform to local (momentjs default)\n    moment(value) :\n    // This might happen in old Plone versions dates\n    moment(`${value}Z`);\n  }\n  if (format && datetime) {\n    return datetime.format(format);\n  }\n  return datetime;\n};\n\n/**\n * Converts a language code to the format `lang_region`\n * Useful for passing from Plone's i18n lang names to Xnix locale names\n * eg. LC_MESSAGES/lang_region.po filenames\n * @param {string} language Language to be converted\n * @returns {string} Language converted\n */\nexport const normalizeLanguageName = language => {\n  if (language.includes('-')) {\n    let normalizedLang = language.split('-');\n    normalizedLang = `${normalizedLang[0]}_${normalizedLang[1].toUpperCase()}`;\n    return normalizedLang;\n  }\n  return language;\n};\n\n/**\n * Converts a language code to the format `lang-region`\n * `react-intl` only supports this syntax, so coming from the language\n * negotiation of the `locale` lib, one need to convert it first\n * @param {string} language Language to be converted\n * @returns {string} Language converted\n */\nexport const toLangUnderscoreRegion = language => {\n  if (language.includes('_')) {\n    let langCode = language.split('_');\n    langCode = `${langCode[0]}-${langCode[1].toUpperCase()}`;\n    return langCode;\n  }\n  return language;\n};\n\n/**\n * Lookup if a given expander is set in apiExpanders\n * @param {string} language Language to be normalized\n * @returns {string} Language normalized\n */\nexport const hasApiExpander = (expander, path = '', type = 'GET_CONTENT') => {\n  return _flatten(config.settings.apiExpanders.filter(expand => matchPath(path, expand.match) && expand[type]).map(expand => expand[type])).includes(expander);\n};\n\n/**\n * Insert element into array at a give index\n * @param {Array} array Array with data\n * @param {*} element Element to be inserted\n * @param {number} index Index of item to be inserted at\n * @returns {Array} Array with inserted element\n */\nexport const insertInArray = (array, element, index) => [...array.slice(0, index), element, ...array.slice(index)];\n\n/**\n * Replace element in array at a give index\n * @param {Array} array Array with data\n * @param {*} element Element to be replaced\n * @param {number} index Index of item to be replaced at\n * @returns {Array} Array with replaced element\n */\nexport const replaceItemOfArray = (array, index, value) => Object.assign([...array], {\n  [index]: value\n});\n\n/**\n * Remove item from array at given index\n * @param {Array} array Array with data\n * @param {number} index Index of item to be removed\n * @returns {Array} Array without deleted element\n */\nexport const removeFromArray = (array, index) => {\n  let newArray = array.slice();\n  newArray.splice(index, 1);\n  return newArray;\n};\n\n/**\n * Reorder array\n * @param {Array} array Array with data\n * @param {number} origin Index of item to be reordered\n * @param {number} target Index of item to be reordered to\n * @returns {Array} Array with reordered elements\n */\nexport const reorderArray = (array, origin, target) => {\n  const result = Array.from(array);\n  const [removed] = result.splice(origin, 1);\n  result.splice(target, 0, removed);\n  return result;\n};\n\n/**\n * Slugify a string: remove whitespaces, special chars and replace with _\n * @param {string} string String to be slugified\n * @returns {string} Slugified string\n */\nexport const slugify = string => {\n  return string.toLowerCase().replace(/[\\s-]+/g, '_').replace(/[^\\w]+/g, '');\n};\n\n/**\n * cloneDeep an object with support for JSX nodes on it\n * Somehow, in a browser it fails with a \"Illegal invocation\" error\n * but in node (Jest test) it doesn't. This does the trick.\n * @param {object} object object to be cloned\n * @returns {object} deep cloned object\n */\nexport const cloneDeepSchema = object => {\n  return _cloneDeepWith(object, value => {\n    if ( /*#__PURE__*/React.isValidElement(value)) {\n      // If a JSX valid element, just return it, do not try to deep clone it\n      return value;\n    }\n  });\n};","map":{"version":3,"names":["React","matchPath","config","difference","object","base","result","value","key","safeWrapper","func","res","Error","applyConfig","configMethods","reduce","acc","apply","withServerErrorCode","code","WrappedComponent","props","staticContext","Object","keys","length","error_code","error","safeColors","namedColors","getInitials","title","limit","text","split","map","n","toUpperCase","join","substring","getColor","name","namedColor","pop","Math","floor","random","toString","parseDateTime","locale","format","moment","updateLocale","localeData","_config","datetime","match","normalizeLanguageName","language","includes","normalizedLang","toLangUnderscoreRegion","langCode","hasApiExpander","expander","path","type","settings","apiExpanders","filter","expand","insertInArray","array","element","index","slice","replaceItemOfArray","assign","removeFromArray","newArray","splice","reorderArray","origin","target","Array","from","removed","slugify","string","toLowerCase","replace","cloneDeepSchema","isValidElement"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/Utils/Utils.js"],"sourcesContent":["import { cloneDeepWith, flatten, isEqual, isObject, transform } from 'lodash';\nimport React from 'react';\nimport { matchPath } from 'react-router';\nimport config from '@plone/volto/registry';\n\n/**\n * Deep diff between two object, using lodash\n * @param  {Object} object Object compared\n * @param  {Object} base   Object to compare with\n * @return {Object}        Return a new object who represent the diff\n */\nexport function difference(object, base) {\n  return transform(object, (result, value, key) => {\n    if (!isEqual(value, base[key])) {\n      result[key] =\n        isObject(value) && isObject(base[key])\n          ? difference(value, base[key])\n          : value;\n    }\n  });\n}\n\n/**\n * Throw an error if the wrapped function returns undefined\n *\n * @param {Function} func\n */\nexport const safeWrapper = (func) => (config) => {\n  const res = func(config);\n  if (typeof res === 'undefined') {\n    throw new Error(`Configuration function doesn't return config, ${func}`);\n  }\n  return res;\n};\n\n/**\n * A helper to pipe a configuration object through configuration loaders\n *\n * @param {Array} configMethods A list of configuration methods\n * @param {Object} config The Volto singleton config object\n */\nexport function applyConfig(configMethods, config) {\n  return configMethods.reduce((acc, apply) => safeWrapper(apply)(acc), config);\n}\n\n/**\n * A HOC factory that propagates the status of asyncConnected requests back to\n * the main server process, to allow properly expressing an error status as\n * HTTP status code\n *\n * @param {} code HTTP return code\n */\nexport function withServerErrorCode(code) {\n  return (WrappedComponent) => (props) => {\n    if (props.staticContext && Object.keys(props.staticContext).length === 0) {\n      const { staticContext } = props;\n      staticContext.error_code = code;\n      staticContext.error = props.error;\n    }\n    return <WrappedComponent {...props} />;\n  };\n}\n\n// See https://en.wikipedia.org/wiki/Web_colors#Extended_colors\nconst safeColors = [\n  'Black',\n  'Blue',\n  'BlueViolet',\n  'Brown',\n  'Crimson',\n  'DarkBlue',\n  'DarkCyan',\n  'DarkGreen',\n  'DarkMagenta',\n  'DarkOliveGreen',\n  'DarkOrchid',\n  'DarkRed',\n  'DarkSlateBlue',\n  'DarkSlateGray',\n  'DarkViolet',\n  'DeepPink',\n  'DimGray',\n  'DodgerBlue',\n  'Firebrick',\n  'ForestGreen',\n  'Fuchsia',\n  'Green',\n  'IndianRed',\n  'Indigo',\n  'Magenta',\n  'Maroon',\n  'MediumBlue',\n  'MediumSlateBlue',\n  'MediumVioletRed',\n  'MidnightBlue',\n  'Navy',\n  'Olive',\n  'OliveDrab',\n  'OrangeRed',\n  'Purple',\n  'Red',\n  'RoyalBlue',\n  'SaddleBrown',\n  'SeaGreen',\n  'Sienna',\n  'SlateBlue',\n  'SlateGray',\n  'SteelBlue',\n  'Teal',\n];\nconst namedColors = {};\n\n/**\n * Will generate initials from string\n * @param {string} name\n * @param {integer} count\n * @returns {string} only one letter if received only one name\n */\nexport const getInitials = (title, limit) => {\n  const text = title\n    .split(' ')\n    .map((n) => (n[0] ? n[0].toUpperCase() : ''))\n    .join('');\n  if (limit) {\n    return text.substring(0, limit);\n  }\n  return text;\n};\n\n/**\n * Will generate a random color hex\n * Will also remmember the color for each userId\n * @param {string} userId\n */\nexport const getColor = (name) => {\n  const namedColor = namedColors[name]\n    ? namedColors[name]\n    : safeColors.length > 0\n    ? safeColors.pop()\n    : `#${Math.floor(Math.random() * 16777215).toString(16)}`;\n  if (!namedColors[name]) {\n    namedColors[name] = namedColor;\n  }\n  return namedColor;\n};\n\n/**\n * Fixes TimeZones issues on moment date objects\n * Parses a DateTime and sets correct moment locale\n * @param {string} locale Current locale\n * @param {string} value DateTime string\n * @param {string} format Date format of choice\n * @returns {Object|string} Moment object or string if format is set\n */\nexport const parseDateTime = (locale, value, format, moment) => {\n  //  Used to set a server timezone or UTC as default\n  moment.updateLocale(locale, moment.localeData(locale)._config); // copy locale to moment-timezone\n  let datetime = null;\n\n  if (value) {\n    // check if datetime has timezone, otherwise assumes it's UTC\n    datetime =\n      !value.match(/T/) || value.match(/T(.)*(-|\\+|Z)/g)\n        ? // Since we assume UTC everywhere, then transform to local (momentjs default)\n          moment(value)\n        : // This might happen in old Plone versions dates\n          moment(`${value}Z`);\n  }\n\n  if (format && datetime) {\n    return datetime.format(format);\n  }\n  return datetime;\n};\n\n/**\n * Converts a language code to the format `lang_region`\n * Useful for passing from Plone's i18n lang names to Xnix locale names\n * eg. LC_MESSAGES/lang_region.po filenames\n * @param {string} language Language to be converted\n * @returns {string} Language converted\n */\nexport const normalizeLanguageName = (language) => {\n  if (language.includes('-')) {\n    let normalizedLang = language.split('-');\n    normalizedLang = `${normalizedLang[0]}_${normalizedLang[1].toUpperCase()}`;\n    return normalizedLang;\n  }\n\n  return language;\n};\n\n/**\n * Converts a language code to the format `lang-region`\n * `react-intl` only supports this syntax, so coming from the language\n * negotiation of the `locale` lib, one need to convert it first\n * @param {string} language Language to be converted\n * @returns {string} Language converted\n */\nexport const toLangUnderscoreRegion = (language) => {\n  if (language.includes('_')) {\n    let langCode = language.split('_');\n    langCode = `${langCode[0]}-${langCode[1].toUpperCase()}`;\n    return langCode;\n  }\n\n  return language;\n};\n\n/**\n * Lookup if a given expander is set in apiExpanders\n * @param {string} language Language to be normalized\n * @returns {string} Language normalized\n */\nexport const hasApiExpander = (expander, path = '', type = 'GET_CONTENT') => {\n  return flatten(\n    config.settings.apiExpanders\n      .filter((expand) => matchPath(path, expand.match) && expand[type])\n      .map((expand) => expand[type]),\n  ).includes(expander);\n};\n\n/**\n * Insert element into array at a give index\n * @param {Array} array Array with data\n * @param {*} element Element to be inserted\n * @param {number} index Index of item to be inserted at\n * @returns {Array} Array with inserted element\n */\nexport const insertInArray = (array, element, index) => [\n  ...array.slice(0, index),\n  element,\n  ...array.slice(index),\n];\n\n/**\n * Replace element in array at a give index\n * @param {Array} array Array with data\n * @param {*} element Element to be replaced\n * @param {number} index Index of item to be replaced at\n * @returns {Array} Array with replaced element\n */\nexport const replaceItemOfArray = (array, index, value) =>\n  Object.assign([...array], { [index]: value });\n\n/**\n * Remove item from array at given index\n * @param {Array} array Array with data\n * @param {number} index Index of item to be removed\n * @returns {Array} Array without deleted element\n */\nexport const removeFromArray = (array, index) => {\n  let newArray = array.slice();\n  newArray.splice(index, 1);\n  return newArray;\n};\n\n/**\n * Reorder array\n * @param {Array} array Array with data\n * @param {number} origin Index of item to be reordered\n * @param {number} target Index of item to be reordered to\n * @returns {Array} Array with reordered elements\n */\nexport const reorderArray = (array, origin, target) => {\n  const result = Array.from(array);\n  const [removed] = result.splice(origin, 1);\n  result.splice(target, 0, removed);\n\n  return result;\n};\n\n/**\n * Slugify a string: remove whitespaces, special chars and replace with _\n * @param {string} string String to be slugified\n * @returns {string} Slugified string\n */\nexport const slugify = (string) => {\n  return string\n    .toLowerCase()\n    .replace(/[\\s-]+/g, '_')\n    .replace(/[^\\w]+/g, '');\n};\n\n/**\n * cloneDeep an object with support for JSX nodes on it\n * Somehow, in a browser it fails with a \"Illegal invocation\" error\n * but in node (Jest test) it doesn't. This does the trick.\n * @param {object} object object to be cloned\n * @returns {object} deep cloned object\n */\nexport const cloneDeepSchema = (object) => {\n  return cloneDeepWith(object, (value) => {\n    if (React.isValidElement(value)) {\n      // If a JSX valid element, just return it, do not try to deep clone it\n      return value;\n    }\n  });\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}