{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _map from \"lodash/map\";\nimport _castArray from \"lodash/castArray\";\nimport { Editor, Path, Point, Range, Transforms } from 'slate';\n\n/**\n * Get range from {@link getPointBefore} to the end point of `at`.\n */\nexport var getRangeBefore = function getRangeBefore(editor, at, options) {\n  var anchor = getPointBefore(editor, at, options);\n  if (!anchor) return;\n  var focus = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  return {\n    anchor: anchor,\n    focus: focus\n  };\n};\n\n/**\n * Autoformat in the middle of a block\n */\nexport var autoformatInlineBlock = function autoformatInlineBlock(editor, _ref) {\n  var type = _ref.type,\n    markup = _ref.markup,\n    _preFormat = _ref.preFormat,\n    format = _ref.format;\n  var markupRange = getRangeBefore(editor, editor.selection, {\n    matchString: markup,\n    skipInvalid: true\n  });\n  if (markupRange) {\n    autoformatBlock(editor, type, markupRange, {\n      preFormat: function preFormat() {\n        editor.insertBreak();\n        if (_preFormat) {\n          _preFormat(editor);\n        }\n      },\n      format: format\n    });\n    return true;\n  }\n};\n\n/**\n * {@link Editor.before} with additional options.\n * TODO: support for sequence of any characters.\n */\nexport var getPointBefore = function getPointBefore(editor, at, options) {\n  var _options$matchString;\n  if (!options || !options.match && !options.matchString) {\n    return Editor.before(editor, at, options);\n  }\n  var beforeAt = at;\n  var previousBeforePoint = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  var stackLength = (((_options$matchString = options.matchString) === null || _options$matchString === void 0 ? void 0 : _options$matchString.length) || 0) + 1;\n  var stack = Array(stackLength);\n  var unitOffset = !options.unit || options.unit === 'offset';\n  var count = 0;\n  while (true) {\n    var _options$match;\n    var beforePoint = Editor.before(editor, beforeAt, options);\n\n    // not found\n    if (!beforePoint) return;\n\n    // different path\n    if (!options.multiPaths && !Path.equals(beforePoint.path, previousBeforePoint.path)) {\n      return;\n    }\n    var beforeString = Editor.string(editor, {\n      anchor: beforePoint,\n      focus: previousBeforePoint\n    });\n    var matchString = _castArray(options.matchString);\n    var beforeStringToMatch = beforeString;\n    if (unitOffset && stackLength) {\n      stack.unshift({\n        point: beforePoint,\n        text: beforeString\n      });\n      stack.pop();\n      beforeStringToMatch = _map(stack.slice(0, -1), 'text').join('');\n    }\n    if (matchString.includes(beforeStringToMatch) || (_options$match = options.match) !== null && _options$match !== void 0 && _options$match.call(options, {\n      beforeString: beforeStringToMatch,\n      beforePoint: beforePoint,\n      at: at\n    })) {\n      if (options.afterMatch) {\n        if (stackLength && unitOffset) {\n          var _stack;\n          return (_stack = stack[stack.length - 1]) === null || _stack === void 0 ? void 0 : _stack.point;\n        }\n        return previousBeforePoint;\n      }\n      return beforePoint;\n    }\n    previousBeforePoint = beforePoint;\n    beforeAt = beforePoint;\n    count += 1;\n    if (!options.skipInvalid) {\n      if (!matchString || count > matchString.length) return;\n    }\n  }\n};\nexport var autoformatInline = function autoformatInline(editor, _ref2) {\n  var type = _ref2.type,\n    between = _ref2.between,\n    markup = _ref2.markup,\n    ignoreTrim = _ref2.ignoreTrim;\n  var selection = editor.selection;\n  var startMarkup = between ? between[0] : markup;\n  var endMarkup = between ? between[1] : '';\n  var endMarkupPointBefore = selection.anchor;\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup\n    });\n    if (!endMarkupPointBefore) return false;\n  }\n  var startMarkupPointAfter = getPointBefore(editor, endMarkupPointBefore, {\n    matchString: startMarkup,\n    skipInvalid: true,\n    afterMatch: true\n  });\n  if (!startMarkupPointAfter) return false;\n\n  // found\n\n  var markupRange = {\n    anchor: startMarkupPointAfter,\n    focus: endMarkupPointBefore\n  };\n  if (!ignoreTrim) {\n    var markupText = getText(editor, markupRange);\n    if (markupText.trim() !== markupText) return false;\n  }\n\n  // delete end markup\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup\n    });\n    Transforms[\"delete\"](editor, {\n      at: {\n        anchor: endMarkupPointBefore,\n        focus: selection.anchor\n      }\n    });\n  }\n\n  // add mark to the text between the markups\n  Transforms.select(editor, markupRange);\n  editor.addMark(type, true);\n  Transforms.collapse(editor, {\n    edge: 'end'\n  });\n  editor.removeMark(type);\n\n  // delete start markup\n  var startMarkupPointBefore = getPointBefore(editor, selection, {\n    matchString: startMarkup,\n    skipInvalid: true\n  });\n  Transforms[\"delete\"](editor, {\n    at: {\n      anchor: startMarkupPointBefore,\n      focus: startMarkupPointAfter\n    }\n  });\n  return true;\n};\nexport var autoformatBlock = function autoformatBlock(editor, type, at, _ref3) {\n  var preFormat = _ref3.preFormat,\n    format = _ref3.format;\n  Transforms[\"delete\"](editor, {\n    at: at\n  });\n  if (preFormat) {\n    preFormat(editor);\n  }\n  if (!format) {\n    Transforms.setNodes(editor, {\n      type: type\n    }, {\n      match: function match(n) {\n        return Editor.isBlock(editor, n);\n      }\n    });\n  } else {\n    format(editor);\n  }\n};\n\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\nexport var isCollapsed = function isCollapsed(range) {\n  return !!range && Range.isCollapsed(range);\n};\n\n/**\n * See {@link Editor.string}.\n * If `at` is not defined, return an empty string.\n */\nexport var getText = function getText(editor, at) {\n  var _ref4;\n  return (_ref4 = at && Editor.string(editor, at)) !== null && _ref4 !== void 0 ? _ref4 : '';\n};\n\n/**\n * Get the bloc {\n * k above a location (default: selection).\n * If not found, return the editor entry.\n */\nexport var getBlockAbove = function getBlockAbove(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return Editor.above(editor, _objectSpread({\n    match: function match(n) {\n      return Editor.isBlock(editor, n);\n    }\n  }, options)) || [editor, []];\n};\n\n/**\n * Get the point from a location (default: selection).\n * If the location is a range, get the anchor point.\n * If the location is a path, get the point at this path with offset 0.\n * If `focus` is true, get the focus point.\n */\nexport var getPointFromLocation = function getPointFromLocation(editor) {\n  var _ref5 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n    _ref5$at = _ref5.at,\n    at = _ref5$at === void 0 ? editor.selection : _ref5$at,\n    focus = _ref5.focus;\n  var point;\n  if (Range.isRange(at)) point = !focus ? at.anchor : at.focus;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = {\n    path: at,\n    offset: 0\n  };\n  return point;\n};\n\n/**\n * Get the range from the start of the block above a location (default: selection) to the location.\n */\nexport var getRangeFromBlockStart = function getRangeFromBlockStart(editor) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var _getBlockAbove = getBlockAbove(editor, options),\n    _getBlockAbove2 = _slicedToArray(_getBlockAbove, 2),\n    path = _getBlockAbove2[1];\n  var start = Editor.start(editor, path);\n  var focus = getPointFromLocation(editor, options);\n  if (!focus) return;\n  return {\n    anchor: start,\n    focus: focus\n  };\n};\n\n/**\n * Enables support for autoformatting actions.\n * Once a markup rule is validated, it does not check the following rules.\n */\nexport var withAutoformat = function withAutoformat(_ref6) {\n  var rules = _ref6.rules;\n  return function (editor) {\n    var insertText = editor.insertText;\n    editor.insertText = function (text) {\n      if (!isCollapsed(editor.selection)) return insertText(text);\n      var _iterator = _createForOfIteratorHelper(rules),\n        _step;\n      try {\n        var _loop = function _loop() {\n          var _step$value = _step.value,\n            _step$value$trigger = _step$value.trigger,\n            trigger = _step$value$trigger === void 0 ? ' ' : _step$value$trigger,\n            type = _step$value.type,\n            markup = _step$value.markup,\n            preFormat = _step$value.preFormat,\n            format = _step$value.format,\n            mode = _step$value.mode,\n            between = _step$value.between,\n            ignoreTrim = _step$value.ignoreTrim,\n            insertTrigger = _step$value.insertTrigger;\n          var triggers = _castArray(trigger);\n\n          // Check trigger\n          if (!triggers.includes(text)) return \"continue\";\n          var markups = _castArray(markup);\n          var rangeFromBlockStart = getRangeFromBlockStart(editor);\n          var textFromBlockStart = getText(editor, rangeFromBlockStart);\n          var valid = function valid() {\n            return insertTrigger && insertText(text);\n          };\n          if (markups.includes(textFromBlockStart)) {\n            // Start of the block\n            autoformatBlock(editor, type, rangeFromBlockStart, {\n              preFormat: preFormat,\n              format: format\n            });\n            return {\n              v: valid()\n            };\n          }\n          if (mode === 'inline-block') {\n            if (autoformatInlineBlock(editor, {\n              preFormat: preFormat,\n              markup: markup,\n              format: format,\n              type: type\n            })) {\n              return {\n                v: valid()\n              };\n            }\n          }\n          if (mode === 'inline') {\n            if (autoformatInline(editor, {\n              type: type,\n              between: between,\n              ignoreTrim: ignoreTrim,\n              markup: Array.isArray(markup) ? markup[0] : markup\n            })) {\n              return {\n                v: valid()\n              };\n            }\n          }\n        };\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _ret = _loop();\n          if (_ret === \"continue\") continue;\n          if (typeof _ret === \"object\") return _ret.v;\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      insertText(text);\n    };\n    return editor;\n  };\n};","map":{"version":3,"names":["Editor","Path","Point","Range","Transforms","getRangeBefore","editor","at","options","anchor","getPointBefore","focus","point","edge","autoformatInlineBlock","type","markup","preFormat","format","markupRange","selection","matchString","skipInvalid","autoformatBlock","insertBreak","match","before","beforeAt","previousBeforePoint","stackLength","length","stack","Array","unitOffset","unit","count","beforePoint","multiPaths","equals","path","beforeString","string","beforeStringToMatch","unshift","text","pop","slice","join","includes","afterMatch","autoformatInline","between","ignoreTrim","startMarkup","endMarkup","endMarkupPointBefore","startMarkupPointAfter","markupText","getText","trim","select","addMark","collapse","removeMark","startMarkupPointBefore","setNodes","n","isBlock","isCollapsed","range","getBlockAbove","above","getPointFromLocation","isRange","isPoint","isPath","offset","getRangeFromBlockStart","start","withAutoformat","rules","insertText","trigger","mode","insertTrigger","triggers","markups","rangeFromBlockStart","textFromBlockStart","valid","isArray"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-slate/src/editor/plugins/Markdown/extensions.js"],"sourcesContent":["import { castArray, map } from 'lodash';\nimport { Editor, Path, Point, Range, Transforms } from 'slate';\n\n/**\n * Get range from {@link getPointBefore} to the end point of `at`.\n */\nexport const getRangeBefore = (editor, at, options) => {\n  const anchor = getPointBefore(editor, at, options);\n  if (!anchor) return;\n\n  const focus = Editor.point(editor, at, { edge: 'end' });\n\n  return {\n    anchor,\n    focus,\n  };\n};\n\n/**\n * Autoformat in the middle of a block\n */\nexport const autoformatInlineBlock = (\n  editor,\n  { type, markup, preFormat, format },\n) => {\n  const markupRange = getRangeBefore(editor, editor.selection, {\n    matchString: markup,\n    skipInvalid: true,\n  });\n\n  if (markupRange) {\n    autoformatBlock(editor, type, markupRange, {\n      preFormat: () => {\n        editor.insertBreak();\n        if (preFormat) {\n          preFormat(editor);\n        }\n      },\n      format,\n    });\n\n    return true;\n  }\n};\n\n/**\n * {@link Editor.before} with additional options.\n * TODO: support for sequence of any characters.\n */\nexport const getPointBefore = (editor, at, options) => {\n  if (!options || (!options.match && !options.matchString)) {\n    return Editor.before(editor, at, options);\n  }\n\n  let beforeAt = at;\n  let previousBeforePoint = Editor.point(editor, at, { edge: 'end' });\n\n  const stackLength = (options.matchString?.length || 0) + 1;\n  const stack = Array(stackLength);\n\n  const unitOffset = !options.unit || options.unit === 'offset';\n\n  let count = 0;\n  while (true) {\n    const beforePoint = Editor.before(editor, beforeAt, options);\n\n    // not found\n    if (!beforePoint) return;\n\n    // different path\n    if (\n      !options.multiPaths &&\n      !Path.equals(beforePoint.path, previousBeforePoint.path)\n    ) {\n      return;\n    }\n\n    const beforeString = Editor.string(editor, {\n      anchor: beforePoint,\n      focus: previousBeforePoint,\n    });\n\n    const matchString = castArray(options.matchString);\n\n    let beforeStringToMatch = beforeString;\n\n    if (unitOffset && stackLength) {\n      stack.unshift({\n        point: beforePoint,\n        text: beforeString,\n      });\n      stack.pop();\n\n      beforeStringToMatch = map(stack.slice(0, -1), 'text').join('');\n    }\n\n    if (\n      matchString.includes(beforeStringToMatch) ||\n      options.match?.({ beforeString: beforeStringToMatch, beforePoint, at })\n    ) {\n      if (options.afterMatch) {\n        if (stackLength && unitOffset) {\n          return stack[stack.length - 1]?.point;\n        }\n        return previousBeforePoint;\n      }\n      return beforePoint;\n    }\n\n    previousBeforePoint = beforePoint;\n    beforeAt = beforePoint;\n\n    count += 1;\n\n    if (!options.skipInvalid) {\n      if (!matchString || count > matchString.length) return;\n    }\n  }\n};\n\nexport const autoformatInline = (\n  editor,\n  { type, between, markup, ignoreTrim },\n) => {\n  const selection = editor.selection;\n\n  const startMarkup = between ? between[0] : markup;\n  const endMarkup = between ? between[1] : '';\n\n  let endMarkupPointBefore = selection.anchor;\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup,\n    });\n    if (!endMarkupPointBefore) return false;\n  }\n\n  const startMarkupPointAfter = getPointBefore(editor, endMarkupPointBefore, {\n    matchString: startMarkup,\n    skipInvalid: true,\n    afterMatch: true,\n  });\n\n  if (!startMarkupPointAfter) return false;\n\n  // found\n\n  const markupRange = {\n    anchor: startMarkupPointAfter,\n    focus: endMarkupPointBefore,\n  };\n\n  if (!ignoreTrim) {\n    const markupText = getText(editor, markupRange);\n    if (markupText.trim() !== markupText) return false;\n  }\n\n  // delete end markup\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup,\n    });\n    Transforms.delete(editor, {\n      at: {\n        anchor: endMarkupPointBefore,\n        focus: selection.anchor,\n      },\n    });\n  }\n\n  // add mark to the text between the markups\n  Transforms.select(editor, markupRange);\n  editor.addMark(type, true);\n  Transforms.collapse(editor, { edge: 'end' });\n  editor.removeMark(type);\n\n  // delete start markup\n  const startMarkupPointBefore = getPointBefore(editor, selection, {\n    matchString: startMarkup,\n    skipInvalid: true,\n  });\n  Transforms.delete(editor, {\n    at: {\n      anchor: startMarkupPointBefore,\n      focus: startMarkupPointAfter,\n    },\n  });\n\n  return true;\n};\n\nexport const autoformatBlock = (editor, type, at, { preFormat, format }) => {\n  Transforms.delete(editor, { at });\n\n  if (preFormat) {\n    preFormat(editor);\n  }\n\n  if (!format) {\n    Transforms.setNodes(\n      editor,\n      { type },\n      { match: (n) => Editor.isBlock(editor, n) },\n    );\n  } else {\n    format(editor);\n  }\n};\n\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\nexport const isCollapsed = (range) => !!range && Range.isCollapsed(range);\n\n/**\n * See {@link Editor.string}.\n * If `at` is not defined, return an empty string.\n */\nexport const getText = (editor, at) => (at && Editor.string(editor, at)) ?? '';\n\n/**\n * Get the bloc {\n * k above a location (default: selection).\n * If not found, return the editor entry.\n */\nexport const getBlockAbove = (editor, options = {}) =>\n  Editor.above(editor, {\n    match: (n) => Editor.isBlock(editor, n),\n    ...options,\n  }) || [editor, []];\n\n/**\n * Get the point from a location (default: selection).\n * If the location is a range, get the anchor point.\n * If the location is a path, get the point at this path with offset 0.\n * If `focus` is true, get the focus point.\n */\nexport const getPointFromLocation = (\n  editor,\n  { at = editor.selection, focus } = {},\n) => {\n  let point;\n  if (Range.isRange(at)) point = !focus ? at.anchor : at.focus;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = { path: at, offset: 0 };\n\n  return point;\n};\n\n/**\n * Get the range from the start of the block above a location (default: selection) to the location.\n */\nexport const getRangeFromBlockStart = (editor, options = {}) => {\n  const [, path] = getBlockAbove(editor, options);\n\n  const start = Editor.start(editor, path);\n\n  const focus = getPointFromLocation(editor, options);\n\n  if (!focus) return;\n\n  return { anchor: start, focus };\n};\n\n/**\n * Enables support for autoformatting actions.\n * Once a markup rule is validated, it does not check the following rules.\n */\nexport const withAutoformat = ({ rules }) => (editor) => {\n  const { insertText } = editor;\n\n  editor.insertText = (text) => {\n    if (!isCollapsed(editor.selection)) return insertText(text);\n\n    for (const {\n      trigger = ' ',\n      type,\n      markup,\n      preFormat,\n      format,\n      mode,\n      between,\n      ignoreTrim,\n      insertTrigger,\n    } of rules) {\n      const triggers = castArray(trigger);\n\n      // Check trigger\n      if (!triggers.includes(text)) continue;\n\n      const markups = castArray(markup);\n\n      const rangeFromBlockStart = getRangeFromBlockStart(editor);\n      const textFromBlockStart = getText(editor, rangeFromBlockStart);\n\n      const valid = () => insertTrigger && insertText(text);\n\n      if (markups.includes(textFromBlockStart)) {\n        // Start of the block\n        autoformatBlock(editor, type, rangeFromBlockStart, {\n          preFormat,\n          format,\n        });\n        return valid();\n      }\n\n      if (mode === 'inline-block') {\n        if (\n          autoformatInlineBlock(editor, { preFormat, markup, format, type })\n        ) {\n          return valid();\n        }\n      }\n\n      if (mode === 'inline') {\n        if (\n          autoformatInline(editor, {\n            type,\n            between,\n            ignoreTrim,\n            markup: Array.isArray(markup) ? markup[0] : markup,\n          })\n        ) {\n          return valid();\n        }\n      }\n    }\n\n    insertText(text);\n  };\n\n  return editor;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}