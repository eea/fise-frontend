{"ast":null,"code":"import _cloneDeep from \"lodash/cloneDeep\";\nimport config from '@plone/volto/registry';\nimport { defineMessages } from 'react-intl';\nconst addTypeSelect = ({\n  intl,\n  schema,\n  extensionName,\n  messages\n}) => {\n  const field = '@type';\n  const extensions = config.blocks.blocksConfig.listing.extensions;\n  const variations = extensions[extensionName];\n  schema.properties[field] = {\n    title: intl.formatMessage(messages.title),\n    choices: variations.map(({\n      id,\n      title\n    }) => [id, title]),\n    defaultValue: variations.find(({\n      isDefault\n    }) => isDefault).id\n  };\n  schema.fieldsets[0].fields.unshift(field);\n  return schema;\n};\n\n// Creates a factory that can trigger schemaEnhancer for a given extension\nexport const schemaEnhancerFactory = ({\n  extensionName,\n  messages,\n  blockType = 'listing',\n  extensionField = '@type'\n}) => ({\n  schema: originalSchema,\n  formData,\n  intl\n}) => {\n  var _activeItem;\n  //\n  // the attribute name that's stored in the block data\n  // it identifies the type of extension that's\n  // applied. Similar in scope, for example, with the block @type\n\n  const blockConfig = config.blocks.blocksConfig[blockType];\n  const extensions = blockConfig.extensions;\n  const templates = extensions[extensionName];\n  const activeItemName = formData === null || formData === void 0 ? void 0 : formData[extensionField];\n  let activeItem = templates === null || templates === void 0 ? void 0 : templates.find(item => item.id === activeItemName);\n  if (!activeItem) activeItem = templates === null || templates === void 0 ? void 0 : templates.find(item => item.isDefault);\n  const schemaEnhancer = (_activeItem = activeItem) === null || _activeItem === void 0 ? void 0 : _activeItem['schemaEnhancer'];\n  let schema = schemaEnhancer ? schemaEnhancer({\n    schema: _cloneDeep(originalSchema),\n    formData,\n    intl\n  }) : _cloneDeep(originalSchema);\n  return addTypeSelect({\n    schema,\n    intl,\n    extensionName,\n    messages\n  });\n};\nconst messages = defineMessages({\n  variation: {\n    \"id\": \"Variation\",\n    \"defaultMessage\": \"Variation\"\n  },\n  styling: {\n    \"id\": \"Styling\",\n    \"defaultMessage\": \"Styling\"\n  }\n});\nconst addStylesField = ({\n  schema,\n  intl,\n  formData\n}) => {\n  // Add the default style schema as the first step in the \"ladder\".\n  // The order is as follows:\n  //\n  // - default volto style schema\n  // - listing block -> default style schema enhancer\n  // - listing block variation -> style schema enhancer\n  // - listing block card/item extension -> style schema enhancer\n  //\n  // We omit the first step in ladder because of bugs in Volto < 16.0.0-alpha.36\n  // In later versions we won't have to redefine the styles field\n\n  if (schema.properties.styles) return schema;\n  const defaultStyleSchema = config.blocks.blocksConfig.listing.stylesSchema;\n  schema.fieldsets.push({\n    id: 'styling',\n    title: intl.formatMessage(messages.styling),\n    fields: ['styles']\n  });\n  schema.properties.styles = {\n    widget: 'object',\n    title: intl.formatMessage(messages.styling),\n    schema: defaultStyleSchema({\n      formData,\n      intl,\n      schema\n    })\n  };\n  return schema;\n};\nexport const enhanceStylingSchema = ({\n  formData,\n  schema,\n  blockType = 'listing',\n  extensionName = 'itemTemplates',\n  intl\n}) => {\n  var _blockConfig$variatio, _blockConfig$variatio2, _blockConfig$extensio, _formData$itemModel;\n  // Adds (to the limited styles schema) the new styling schema enhancements\n  schema = addStylesField({\n    formData,\n    schema,\n    intl\n  });\n\n  // first, enhance styling schema based on the variation\n  // then, enhance it based on the `${extensionName}`\n\n  const blockConfig = config.blocks.blocksConfig[blockType];\n  const activeVariationId = formData['variation'] || ((_blockConfig$variatio = blockConfig.variations) === null || _blockConfig$variatio === void 0 ? void 0 : (_blockConfig$variatio2 = _blockConfig$variatio.find(({\n    isDefault\n  }) => isDefault)) === null || _blockConfig$variatio2 === void 0 ? void 0 : _blockConfig$variatio2.id);\n  // TODO: use resolveExtensions() from Volto\n  const activeVariation = activeVariationId ? blockConfig.variations.find(({\n    id\n  }) => id === activeVariationId) : {};\n\n  // TODO: not needed when we will use latest Volto\n  const variationStyleSchema = activeVariation === null || activeVariation === void 0 ? void 0 : activeVariation.stylesSchema;\n  schema = variationStyleSchema ? variationStyleSchema({\n    schema: _cloneDeep(schema),\n    formData,\n    intl\n  }) : schema;\n  // end TODO\n\n  const extensionType = '@type'; // the attribute name that's stored in the block data\n  const extensionTemplates = (_blockConfig$extensio = blockConfig.extensions) === null || _blockConfig$extensio === void 0 ? void 0 : _blockConfig$extensio[extensionName];\n  const activeItemName = formData === null || formData === void 0 ? void 0 : (_formData$itemModel = formData.itemModel) === null || _formData$itemModel === void 0 ? void 0 : _formData$itemModel[extensionType];\n  let activeItem = extensionTemplates === null || extensionTemplates === void 0 ? void 0 : extensionTemplates.find(item => item.id === activeItemName);\n  const stylingSchema = activeItem === null || activeItem === void 0 ? void 0 : activeItem['stylesSchema'];\n  schema = stylingSchema ? stylingSchema({\n    schema: _cloneDeep(schema),\n    formData,\n    intl\n  }) : schema;\n  return schema;\n};\nexport const getVoltoStyles = props => {\n  const styles = props ? props : {};\n  const output = {};\n  for (const [key, value] of Object.entries(styles)) {\n    if (styles[key] === true) {\n      output[key] = key;\n    } else {\n      output[value] = value;\n    }\n  }\n  return output;\n};","map":{"version":3,"names":["config","defineMessages","addTypeSelect","intl","schema","extensionName","messages","field","extensions","blocks","blocksConfig","listing","variations","properties","title","formatMessage","choices","map","id","defaultValue","find","isDefault","fieldsets","fields","unshift","schemaEnhancerFactory","blockType","extensionField","originalSchema","formData","blockConfig","templates","activeItemName","activeItem","item","schemaEnhancer","variation","styling","addStylesField","styles","defaultStyleSchema","stylesSchema","push","widget","enhanceStylingSchema","activeVariationId","activeVariation","variationStyleSchema","extensionType","extensionTemplates","itemModel","stylingSchema","getVoltoStyles","props","output","key","value","Object","entries"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@eeacms/volto-listing-block/src/schema-utils.js"],"sourcesContent":["import { cloneDeep } from 'lodash';\nimport config from '@plone/volto/registry';\n\nimport { defineMessages } from 'react-intl';\n\nconst addTypeSelect = ({ intl, schema, extensionName, messages }) => {\n  const field = '@type';\n  const extensions = config.blocks.blocksConfig.listing.extensions;\n  const variations = extensions[extensionName];\n  schema.properties[field] = {\n    title: intl.formatMessage(messages.title),\n    choices: variations.map(({ id, title }) => [id, title]),\n    defaultValue: variations.find(({ isDefault }) => isDefault).id,\n  };\n  schema.fieldsets[0].fields.unshift(field);\n\n  return schema;\n};\n\n// Creates a factory that can trigger schemaEnhancer for a given extension\nexport const schemaEnhancerFactory = ({\n  extensionName,\n  messages,\n  blockType = 'listing',\n  extensionField = '@type',\n}) => ({ schema: originalSchema, formData, intl }) => {\n  //\n  // the attribute name that's stored in the block data\n  // it identifies the type of extension that's\n  // applied. Similar in scope, for example, with the block @type\n\n  const blockConfig = config.blocks.blocksConfig[blockType];\n  const extensions = blockConfig.extensions;\n  const templates = extensions[extensionName];\n\n  const activeItemName = formData?.[extensionField];\n  let activeItem = templates?.find((item) => item.id === activeItemName);\n  if (!activeItem) activeItem = templates?.find((item) => item.isDefault);\n\n  const schemaEnhancer = activeItem?.['schemaEnhancer'];\n\n  let schema = schemaEnhancer\n    ? schemaEnhancer({ schema: cloneDeep(originalSchema), formData, intl })\n    : cloneDeep(originalSchema);\n\n  return addTypeSelect({ schema, intl, extensionName, messages });\n};\n\nconst messages = defineMessages({\n  variation: {\n    id: 'Variation',\n    defaultMessage: 'Variation',\n  },\n  styling: {\n    id: 'Styling',\n    defaultMessage: 'Styling',\n  },\n});\n\nconst addStylesField = ({ schema, intl, formData }) => {\n  // Add the default style schema as the first step in the \"ladder\".\n  // The order is as follows:\n  //\n  // - default volto style schema\n  // - listing block -> default style schema enhancer\n  // - listing block variation -> style schema enhancer\n  // - listing block card/item extension -> style schema enhancer\n  //\n  // We omit the first step in ladder because of bugs in Volto < 16.0.0-alpha.36\n  // In later versions we won't have to redefine the styles field\n\n  if (schema.properties.styles) return schema;\n\n  const defaultStyleSchema = config.blocks.blocksConfig.listing.stylesSchema;\n\n  schema.fieldsets.push({\n    id: 'styling',\n    title: intl.formatMessage(messages.styling),\n    fields: ['styles'],\n  });\n\n  schema.properties.styles = {\n    widget: 'object',\n    title: intl.formatMessage(messages.styling),\n    schema: defaultStyleSchema({ formData, intl, schema }),\n  };\n\n  return schema;\n};\nexport const enhanceStylingSchema = ({\n  formData,\n  schema,\n  blockType = 'listing',\n  extensionName = 'itemTemplates',\n  intl,\n}) => {\n  // Adds (to the limited styles schema) the new styling schema enhancements\n  schema = addStylesField({ formData, schema, intl });\n\n  // first, enhance styling schema based on the variation\n  // then, enhance it based on the `${extensionName}`\n\n  const blockConfig = config.blocks.blocksConfig[blockType];\n  const activeVariationId =\n    formData['variation'] ||\n    blockConfig.variations?.find(({ isDefault }) => isDefault)?.id;\n  // TODO: use resolveExtensions() from Volto\n  const activeVariation = activeVariationId\n    ? blockConfig.variations.find(({ id }) => id === activeVariationId)\n    : {};\n\n  // TODO: not needed when we will use latest Volto\n  const variationStyleSchema = activeVariation?.stylesSchema;\n  schema = variationStyleSchema\n    ? variationStyleSchema({ schema: cloneDeep(schema), formData, intl })\n    : schema;\n  // end TODO\n\n  const extensionType = '@type'; // the attribute name that's stored in the block data\n  const extensionTemplates = blockConfig.extensions?.[extensionName];\n  const activeItemName = formData?.itemModel?.[extensionType];\n  let activeItem = extensionTemplates?.find(\n    (item) => item.id === activeItemName,\n  );\n\n  const stylingSchema = activeItem?.['stylesSchema'];\n  schema = stylingSchema\n    ? stylingSchema({ schema: cloneDeep(schema), formData, intl })\n    : schema;\n\n  return schema;\n};\n\nexport const getVoltoStyles = (props) => {\n  const styles = props ? props : {};\n  const output = {};\n  for (const [key, value] of Object.entries(styles)) {\n    if (styles[key] === true) {\n      output[key] = key;\n    } else {\n      output[value] = value;\n    }\n  }\n  return output;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[{"id":"Variation","defaultMessage":"Variation"},{"id":"Styling","defaultMessage":"Styling"}]}},"sourceType":"module","externalDependencies":[]}