{"ast":null,"code":"import _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { Editor, Path, Transforms, Node } from 'slate';\nimport { isCursorInList, getCurrentListItem } from 'volto-slate/utils';\nimport config from '@plone/volto/registry';\n\n/**\n * Move up a list with with `Ctrl+Up`. (The Up key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\nexport function moveListItemUp(_ref) {\n  var editor = _ref.editor,\n    event = _ref.event;\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!(event.ctrlKey && isCursorInList(editor))) return;\n\n  // Else prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n  var anchor = editor.selection.anchor;\n  var slate = config.settings.slate;\n  event.preventDefault();\n  event.stopPropagation();\n\n  // Store the current list item's path.\n  var _getCurrentListItem = getCurrentListItem(editor),\n    _getCurrentListItem2 = _slicedToArray(_getCurrentListItem, 2),\n    listItemPath = _getCurrentListItem2[1];\n\n  // Don't allow in first line list item Check if the current list item is first\n  // in its parent\n  if (\n  // If the selection starts at the beginning of a root-level block node\n  anchor.path.slice(1).reduce(function (acc, n) {\n    return acc + n;\n  }, 0) === 0 ||\n  // or the current list item is the first in the list that contains it\n  listItemPath[listItemPath.length - 1] === 0) {\n    // Mark the event as handled and do nothing.\n    return true;\n  }\n\n  // Take the Node in the selection that is LI and is farthest-from-root.\n  var _Editor$nodes = Editor.nodes(editor, {\n      match: function match(n) {\n        return n.type === slate.listItemType;\n      },\n      // Explanation of the three modes:\n      // * 'all' - take all the nodes from the root Editor node to the selected\n      //   leaf Text node\n      // * 'highest' - take the root Editor node (if there is a selection, in case\n      //   no `at` option is given)\n      // * 'lowest' - take the farthest-from-root selected leaf Text node\n      // (Replace the \"leaf Text node\" expressions in the above list with\n      // whatever matching function you use.)\n      mode: 'lowest'\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    match = _Editor$nodes2[0];\n\n  // Get the Path of the above-found Node.\n  var _match = _slicedToArray(match, 2),\n    at = _match[1];\n\n  // Get the Path that represents the previous sibling node of the Path above.\n  // TODO: handle the exception that this can throw, when `at` has the last\n  // number in it a `0`. This case is possible because the condition above that\n  // uses the Array.prototype.reduce method checks only the sum but the last 2\n  // items can be [2, 0], their sum is 2 but the last item is 0, so the\n  // exception is thrown.\n  var to = Path.previous(at);\n\n  // If the Path does not exist, mark the event as handled and do nothing.\n  if (!Node.has(editor, to)) return true;\n\n  // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just before its current location.\n  Transforms.moveNodes(editor, {\n    at: at,\n    to: to\n  });\n\n  // Mark the event as handled.\n  return true;\n}\n\n/**\n * Move down a list with with `Ctrl+Down`. (The Down key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\nexport function moveListItemDown(_ref2) {\n  var editor = _ref2.editor,\n    event = _ref2.event;\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!event.ctrlKey) return;\n  if (!isCursorInList(editor)) return false;\n\n  // Else\n  var slate = config.settings.slate;\n\n  // Take the Node in the selection that is LI and is farthest-from-root.\n  var _Editor$nodes3 = Editor.nodes(editor, {\n      // Explanation of the three modes:\n      // * 'all' - take all the nodes from the root Editor node to the selected\n      //   leaf Text node\n      // * 'highest' - take the root Editor node (if there is a selection, in case\n      //   no `at` option is given)\n      // * 'lowest' - take the farthest-from-root selected leaf Text node\n      // (Replace the \"leaf Text node\" expressions in the above list with\n      // whatever matching function you use.)\n      match: function match(n) {\n        return n.type === slate.listItemType;\n      },\n      reverse: true,\n      mode: 'lowest'\n    }),\n    _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n    match = _Editor$nodes4[0];\n\n  // Get the Path of the above-found Node.\n  var _match2 = _slicedToArray(match, 2),\n    at = _match2[1];\n\n  // Get the Path that represents the next sibling node of the Path above.\n  var to = Path.next(at);\n\n  // Prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n  event.preventDefault();\n  event.stopPropagation();\n\n  // If the Path does not exist, mark the event as handled and do nothing.\n  if (!Node.has(editor, to)) return true;\n\n  // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just after its current location, if there is a place for it\n  // at the same depth.\n  Transforms.moveNodes(editor, {\n    at: at,\n    to: to\n  });\n\n  // Mark the event as handled.\n  return true;\n}","map":{"version":3,"names":["Editor","Path","Transforms","Node","isCursorInList","getCurrentListItem","config","moveListItemUp","editor","event","ctrlKey","anchor","selection","slate","settings","preventDefault","stopPropagation","listItemPath","path","slice","reduce","acc","n","length","nodes","match","type","listItemType","mode","at","to","previous","has","moveNodes","moveListItemDown","reverse","next"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/blocks/Text/keyboard/moveListItems.js"],"sourcesContent":["import { Editor, Path, Transforms, Node } from 'slate';\nimport { isCursorInList, getCurrentListItem } from 'volto-slate/utils';\nimport config from '@plone/volto/registry';\n\n/**\n * Move up a list with with `Ctrl+Up`. (The Up key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\nexport function moveListItemUp({ editor, event }) {\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!(event.ctrlKey && isCursorInList(editor))) return;\n\n  // Else prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n  const { anchor } = editor.selection;\n  const { slate } = config.settings;\n\n  event.preventDefault();\n  event.stopPropagation();\n\n  // Store the current list item's path.\n  const [, listItemPath] = getCurrentListItem(editor);\n\n  // Don't allow in first line list item Check if the current list item is first\n  // in its parent\n  if (\n    // If the selection starts at the beginning of a root-level block node\n    anchor.path.slice(1).reduce((acc, n) => acc + n, 0) === 0 ||\n    // or the current list item is the first in the list that contains it\n    listItemPath[listItemPath.length - 1] === 0\n  ) {\n    // Mark the event as handled and do nothing.\n    return true;\n  }\n\n  // Take the Node in the selection that is LI and is farthest-from-root.\n  const [match] = Editor.nodes(editor, {\n    match: (n) => n.type === slate.listItemType,\n    // Explanation of the three modes:\n    // * 'all' - take all the nodes from the root Editor node to the selected\n    //   leaf Text node\n    // * 'highest' - take the root Editor node (if there is a selection, in case\n    //   no `at` option is given)\n    // * 'lowest' - take the farthest-from-root selected leaf Text node\n    // (Replace the \"leaf Text node\" expressions in the above list with\n    // whatever matching function you use.)\n    mode: 'lowest',\n  });\n\n  // Get the Path of the above-found Node.\n  const [, at] = match;\n\n  // Get the Path that represents the previous sibling node of the Path above.\n  // TODO: handle the exception that this can throw, when `at` has the last\n  // number in it a `0`. This case is possible because the condition above that\n  // uses the Array.prototype.reduce method checks only the sum but the last 2\n  // items can be [2, 0], their sum is 2 but the last item is 0, so the\n  // exception is thrown.\n  const to = Path.previous(at);\n\n  // If the Path does not exist, mark the event as handled and do nothing.\n  if (!Node.has(editor, to)) return true;\n\n  // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just before its current location.\n  Transforms.moveNodes(editor, { at, to });\n\n  // Mark the event as handled.\n  return true;\n}\n\n/**\n * Move down a list with with `Ctrl+Down`. (The Down key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\nexport function moveListItemDown({ editor, event }) {\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!event.ctrlKey) return;\n  if (!isCursorInList(editor)) return false;\n\n  // Else\n  const { slate } = config.settings;\n\n  // Take the Node in the selection that is LI and is farthest-from-root.\n  const [match] = Editor.nodes(editor, {\n    // Explanation of the three modes:\n    // * 'all' - take all the nodes from the root Editor node to the selected\n    //   leaf Text node\n    // * 'highest' - take the root Editor node (if there is a selection, in case\n    //   no `at` option is given)\n    // * 'lowest' - take the farthest-from-root selected leaf Text node\n    // (Replace the \"leaf Text node\" expressions in the above list with\n    // whatever matching function you use.)\n    match: (n) => n.type === slate.listItemType,\n    reverse: true,\n    mode: 'lowest',\n  });\n\n  // Get the Path of the above-found Node.\n  const [, at] = match;\n\n  // Get the Path that represents the next sibling node of the Path above.\n  const to = Path.next(at);\n\n  // Prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n  event.preventDefault();\n  event.stopPropagation();\n\n  // If the Path does not exist, mark the event as handled and do nothing.\n  if (!Node.has(editor, to)) return true;\n\n  // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just after its current location, if there is a place for it\n  // at the same depth.\n  Transforms.moveNodes(editor, { at, to });\n\n  // Mark the event as handled.\n  return true;\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}