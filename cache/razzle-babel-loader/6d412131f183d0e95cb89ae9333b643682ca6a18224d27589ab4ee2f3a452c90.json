{"ast":null,"code":"import ReactDOM from 'react-dom';\nimport { serializeNodesToText } from 'volto-slate/editor/render';\nimport { Editor } from 'slate';\nimport { getPreviousVoltoBlock, getNextVoltoBlock, isCursorAtBlockStart, isCursorAtBlockEnd, mergeSlateWithBlockBackward, mergeSlateWithBlockForward } from 'volto-slate/utils';\nimport { changeBlock, deleteBlock, getBlocksFieldname, getBlocksLayoutFieldname } from '@plone/volto/helpers';\n\n/**\n * Joins the current block (which has an active Slate Editor)\n * with the previous block, to make a single block.\n *\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithPreviousBlock({\n  editor,\n  event\n}) {\n  if (!isCursorAtBlockStart(editor)) return;\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n    properties,\n    onChangeField\n  } = blockProps;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const prev = getPreviousVoltoBlock(index, properties);\n  if (!prev) return;\n  const [otherBlock = {}, otherBlockId] = prev;\n\n  // Don't join with required blocks\n  if (data !== null && data !== void 0 && data.required || otherBlock !== null && otherBlock !== void 0 && otherBlock.required || otherBlock['@type'] !== 'slate') return;\n  event.stopPropagation();\n  event.preventDefault();\n\n  // If the Editor contains no characters TODO: clarify if this special case\n  // really needs to be handled or not. In `joinWithNextBlock` it is not\n  // handled.\n  const text = Editor.string(editor, []);\n  if (!text) {\n    const cursor = getBlockEndAsRange(otherBlock);\n    const newFormData = deleteBlock(properties, block);\n    ReactDOM.unstable_batchedUpdates(() => {\n      saveSlateBlockSelection(otherBlockId, cursor);\n      onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n      onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n      onSelectBlock(otherBlockId);\n    });\n    return true;\n  }\n\n  // Else the editor contains characters, so we merge the current block's\n  // `editor` with the block before, `otherBlock`.\n  const cursor = mergeSlateWithBlockBackward(editor, otherBlock);\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // // TODO: don't remove undo history, etc Should probably save both undo\n  // // histories, so that the blocks are split, the undos can be restored??\n\n  // const cursor = getBlockEndAsRange(otherBlock);\n  const formData = changeBlock(properties, otherBlockId, {\n    '@type': 'slate',\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    value: combined,\n    plaintext: serializeNodesToText(combined || [])\n  });\n  const newFormData = deleteBlock(formData, block);\n  ReactDOM.unstable_batchedUpdates(() => {\n    saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n\n/**\n * Joins the current block (which has the cursor) with the next block to make a\n * single block.\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithNextBlock({\n  editor,\n  event\n}) {\n  if (!isCursorAtBlockEnd(editor)) return;\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    // saveSlateBlockSelection,\n    onSelectBlock,\n    data\n  } = blockProps;\n  const {\n    properties,\n    onChangeField\n  } = editor.getBlockProps();\n  const [otherBlock = {}, otherBlockId] = getNextVoltoBlock(index, properties);\n\n  // Don't join with required blocks\n  if (data !== null && data !== void 0 && data.required || otherBlock !== null && otherBlock !== void 0 && otherBlock.required || otherBlock['@type'] !== 'slate') return;\n  event.stopPropagation();\n  event.preventDefault();\n  mergeSlateWithBlockForward(editor, otherBlock);\n\n  // const cursor = JSON.parse(JSON.stringify(editor.selection));\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // TODO: don't remove undo history, etc Should probably save both undo\n  // histories, so that the blocks are split, the undos can be restored??\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const formData = changeBlock(properties, otherBlockId, {\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    '@type': 'slate',\n    value: combined,\n    plaintext: serializeNodesToText(combined || [])\n  });\n  const newFormData = deleteBlock(formData, block);\n  ReactDOM.unstable_batchedUpdates(() => {\n    // saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n\n/**\n * @param {object} block The Volto object representing the configuration and\n * contents of a Volto Block of type Slate Text.\n * @returns {Range} The collapsed Slate Range that represents the last position\n * the text cursor can take inside the given block.\n */\nfunction getBlockEndAsRange(block) {\n  const {\n    value\n  } = block;\n  const location = [value.length - 1]; // adress of root node\n  const editor = {\n    children: value\n  };\n  const path = Editor.last(editor, location)[1]; // last Node in the block\n  // The last Text node (leaf node) entry inside the path computed just above.\n  const [leaf, leafpath] = Editor.leaf(editor, path);\n  // The offset of the Points in the collapsed Range computed below:\n  const offset = (leaf.text || '').length;\n  return {\n    anchor: {\n      path: leafpath,\n      offset\n    },\n    focus: {\n      path: leafpath,\n      offset\n    }\n  };\n}","map":{"version":3,"names":["ReactDOM","serializeNodesToText","Editor","getPreviousVoltoBlock","getNextVoltoBlock","isCursorAtBlockStart","isCursorAtBlockEnd","mergeSlateWithBlockBackward","mergeSlateWithBlockForward","changeBlock","deleteBlock","getBlocksFieldname","getBlocksLayoutFieldname","joinWithPreviousBlock","editor","event","blockProps","getBlockProps","block","index","saveSlateBlockSelection","onSelectBlock","data","properties","onChangeField","blocksFieldname","blocksLayoutFieldname","prev","otherBlock","otherBlockId","required","stopPropagation","preventDefault","text","string","cursor","getBlockEndAsRange","newFormData","unstable_batchedUpdates","combined","JSON","parse","stringify","children","formData","value","plaintext","joinWithNextBlock","location","length","path","last","leaf","leafpath","offset","anchor","focus"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/blocks/Text/keyboard/joinBlocks.js"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport { serializeNodesToText } from 'volto-slate/editor/render';\nimport { Editor } from 'slate';\nimport {\n  getPreviousVoltoBlock,\n  getNextVoltoBlock,\n  isCursorAtBlockStart,\n  isCursorAtBlockEnd,\n  mergeSlateWithBlockBackward,\n  mergeSlateWithBlockForward,\n} from 'volto-slate/utils';\nimport {\n  changeBlock,\n  deleteBlock,\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers';\n\n/**\n * Joins the current block (which has an active Slate Editor)\n * with the previous block, to make a single block.\n *\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithPreviousBlock({ editor, event }) {\n  if (!isCursorAtBlockStart(editor)) return;\n\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n    properties,\n    onChangeField,\n  } = blockProps;\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const prev = getPreviousVoltoBlock(index, properties);\n  if (!prev) return;\n  const [otherBlock = {}, otherBlockId] = prev;\n\n  // Don't join with required blocks\n  if (data?.required || otherBlock?.required || otherBlock['@type'] !== 'slate')\n    return;\n\n  event.stopPropagation();\n  event.preventDefault();\n\n  // If the Editor contains no characters TODO: clarify if this special case\n  // really needs to be handled or not. In `joinWithNextBlock` it is not\n  // handled.\n  const text = Editor.string(editor, []);\n  if (!text) {\n    const cursor = getBlockEndAsRange(otherBlock);\n    const newFormData = deleteBlock(properties, block);\n\n    ReactDOM.unstable_batchedUpdates(() => {\n      saveSlateBlockSelection(otherBlockId, cursor);\n\n      onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n      onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n\n      onSelectBlock(otherBlockId);\n    });\n\n    return true;\n  }\n\n  // Else the editor contains characters, so we merge the current block's\n  // `editor` with the block before, `otherBlock`.\n  const cursor = mergeSlateWithBlockBackward(editor, otherBlock);\n\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // // TODO: don't remove undo history, etc Should probably save both undo\n  // // histories, so that the blocks are split, the undos can be restored??\n\n  // const cursor = getBlockEndAsRange(otherBlock);\n  const formData = changeBlock(properties, otherBlockId, {\n    '@type': 'slate', // TODO: use a constant specified in src/constants.js instead of 'slate'\n    value: combined,\n    plaintext: serializeNodesToText(combined || []),\n  });\n  const newFormData = deleteBlock(formData, block);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n\n  return true;\n}\n\n/**\n * Joins the current block (which has the cursor) with the next block to make a\n * single block.\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithNextBlock({ editor, event }) {\n  if (!isCursorAtBlockEnd(editor)) return;\n\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    // saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n  } = blockProps;\n\n  const { properties, onChangeField } = editor.getBlockProps();\n  const [otherBlock = {}, otherBlockId] = getNextVoltoBlock(index, properties);\n\n  // Don't join with required blocks\n  if (data?.required || otherBlock?.required || otherBlock['@type'] !== 'slate')\n    return;\n\n  event.stopPropagation();\n  event.preventDefault();\n\n  mergeSlateWithBlockForward(editor, otherBlock);\n\n  // const cursor = JSON.parse(JSON.stringify(editor.selection));\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // TODO: don't remove undo history, etc Should probably save both undo\n  // histories, so that the blocks are split, the undos can be restored??\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const formData = changeBlock(properties, otherBlockId, {\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    '@type': 'slate',\n    value: combined,\n    plaintext: serializeNodesToText(combined || []),\n  });\n  const newFormData = deleteBlock(formData, block);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    // saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n\n/**\n * @param {object} block The Volto object representing the configuration and\n * contents of a Volto Block of type Slate Text.\n * @returns {Range} The collapsed Slate Range that represents the last position\n * the text cursor can take inside the given block.\n */\nfunction getBlockEndAsRange(block) {\n  const { value } = block;\n  const location = [value.length - 1]; // adress of root node\n  const editor = { children: value };\n  const path = Editor.last(editor, location)[1]; // last Node in the block\n  // The last Text node (leaf node) entry inside the path computed just above.\n  const [leaf, leafpath] = Editor.leaf(editor, path);\n  // The offset of the Points in the collapsed Range computed below:\n  const offset = (leaf.text || '').length;\n\n  return {\n    anchor: { path: leafpath, offset },\n    focus: { path: leafpath, offset },\n  };\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}