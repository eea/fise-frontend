{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport React from 'react';\nimport { Editor, Transforms, Range, Text } from 'slate';\nexport function isMarkActive(editor, format) {\n  // TODO: this implementation is not ok. LibreOffice Writer only shows\n  // mark button as active if the mark is applied to the entire selected range\n  // Here, it seems, the mark doesn't need to cover the entire selection,\n  // which is wrong\n  let marks;\n  try {\n    marks = Editor.marks(editor);\n  } catch (ex) {\n    // bug in Slate, recently appears only in Cypress context, more exactly when I press Enter inside a numbered list first item to produce a split (resulting two list items) (not sure if manually inside the Cypress browser but automatically it surely appears)\n    // if (\n    //   ex.message ===\n    //   'Cannot get the leaf node at path [0,0] because it refers to a non-leaf node: [object Object]' // also with [0,1]\n    // ) {\n    marks = null;\n    // } else {\n    //   throw ex;\n    // }\n  }\n\n  return marks ? marks[format] === true : false;\n}\nfunction addMark(editor, key, value) {\n  const {\n    selection\n  } = editor;\n  if (selection) {\n    if (Range.isExpanded(selection)) {\n      Transforms.setNodes(editor, {\n        [key]: value\n      }, {\n        match: node => {\n          // console.log('node', node);\n          return Text.isText(node) || editor.isVoid(node);\n        },\n        split: true\n      });\n    } else {\n      const marks = _objectSpread(_objectSpread({}, Editor.marks(editor) || {}), {}, {\n        [key]: value\n      });\n      editor.marks = marks;\n      editor.onChange();\n    }\n  }\n}\nexport function toggleMark(editor, format) {\n  const isActive = isMarkActive(editor, format);\n  if (isActive) {\n    Editor.removeMark(editor, format);\n  } else {\n    // don't apply marks inside inlines (such as footnote) because\n    // that splits the footnote into multiple footnotes\n    addMark(editor, format, true);\n    // if (isSelectionInline(editor)) {\n    //   addMark(editor, format, true);\n    // }\n  }\n}\n\n/*\n * Replaces inline text elements with a wrapper result:\n *\n * Leaves are wrapped and non-leaves are cloned. Empty leaves are removed.\n */\nexport function wrapInlineMarkupText(children, wrapper) {\n  if (typeof children === 'string') {\n    return children ? wrapper(children) : null;\n  }\n\n  // TODO: find the deepest child that needs to be replaced.\n  // TODO: note: this might trigger warnings about keys\n  if (Array.isArray(children)) {\n    return children.map(child => {\n      if (typeof child === 'string' && child.length >= 1) {\n        return wrapper(children);\n      }\n      if (typeof child === 'string' && child.length === 0) {\n        return null;\n      }\n      return /*#__PURE__*/React.cloneElement(child, child.props, wrapInlineMarkupText(child.props.children, wrapper));\n    }).filter(child => !!child);\n  }\n  return /*#__PURE__*/React.cloneElement(children, children.props, wrapInlineMarkupText(children.props.children, wrapper));\n}","map":{"version":3,"names":["React","Editor","Transforms","Range","Text","isMarkActive","editor","format","marks","ex","addMark","key","value","selection","isExpanded","setNodes","match","node","isText","isVoid","split","onChange","toggleMark","isActive","removeMark","wrapInlineMarkupText","children","wrapper","Array","isArray","map","child","length","cloneElement","props","filter"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-slate/src/utils/marks.js"],"sourcesContent":["import React from 'react';\nimport { Editor, Transforms, Range, Text } from 'slate';\n\nexport function isMarkActive(editor, format) {\n  // TODO: this implementation is not ok. LibreOffice Writer only shows\n  // mark button as active if the mark is applied to the entire selected range\n  // Here, it seems, the mark doesn't need to cover the entire selection,\n  // which is wrong\n  let marks;\n  try {\n    marks = Editor.marks(editor);\n  } catch (ex) {\n    // bug in Slate, recently appears only in Cypress context, more exactly when I press Enter inside a numbered list first item to produce a split (resulting two list items) (not sure if manually inside the Cypress browser but automatically it surely appears)\n    // if (\n    //   ex.message ===\n    //   'Cannot get the leaf node at path [0,0] because it refers to a non-leaf node: [object Object]' // also with [0,1]\n    // ) {\n    marks = null;\n    // } else {\n    //   throw ex;\n    // }\n  }\n  return marks ? marks[format] === true : false;\n}\n\nfunction addMark(editor, key, value) {\n  const { selection } = editor;\n\n  if (selection) {\n    if (Range.isExpanded(selection)) {\n      Transforms.setNodes(\n        editor,\n        { [key]: value },\n        {\n          match: (node) => {\n            // console.log('node', node);\n            return Text.isText(node) || editor.isVoid(node);\n          },\n          split: true,\n        },\n      );\n    } else {\n      const marks = {\n        ...(Editor.marks(editor) || {}),\n        [key]: value,\n      };\n\n      editor.marks = marks;\n      editor.onChange();\n    }\n  }\n}\n\nexport function toggleMark(editor, format) {\n  const isActive = isMarkActive(editor, format);\n\n  if (isActive) {\n    Editor.removeMark(editor, format);\n  } else {\n    // don't apply marks inside inlines (such as footnote) because\n    // that splits the footnote into multiple footnotes\n    addMark(editor, format, true);\n    // if (isSelectionInline(editor)) {\n    //   addMark(editor, format, true);\n    // }\n  }\n}\n\n/*\n * Replaces inline text elements with a wrapper result:\n *\n * Leaves are wrapped and non-leaves are cloned. Empty leaves are removed.\n */\nexport function wrapInlineMarkupText(children, wrapper) {\n  if (typeof children === 'string') {\n    return children ? wrapper(children) : null;\n  }\n\n  // TODO: find the deepest child that needs to be replaced.\n  // TODO: note: this might trigger warnings about keys\n  if (Array.isArray(children)) {\n    return children\n      .map((child) => {\n        if (typeof child === 'string' && child.length >= 1) {\n          return wrapper(children);\n        }\n        if (typeof child === 'string' && child.length === 0) {\n          return null;\n        }\n        return React.cloneElement(\n          child,\n          child.props,\n          wrapInlineMarkupText(child.props.children, wrapper),\n        );\n      })\n      .filter((child) => !!child);\n  }\n\n  return React.cloneElement(\n    children,\n    children.props,\n    wrapInlineMarkupText(children.props.children, wrapper),\n  );\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}