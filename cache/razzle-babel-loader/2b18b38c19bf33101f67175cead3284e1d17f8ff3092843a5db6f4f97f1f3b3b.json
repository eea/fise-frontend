{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport { isCmsUi } from '@plone/volto/helpers';\nconst LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\nconst PROTECT_START = '@@loadProtector/START';\nconst PROTECT_END = '@@loadProtector/END';\nconst PROTECT_SKIPPED = '@@loadProtector/SKIPPED';\nconst GET_CONTENT_PENDING = 'GET_CONTENT_PENDING';\nconst GET_CONTENT_SUCCESS = 'GET_CONTENT_SUCCESS';\nconst GET_CONTENT_FAIL = 'GET_CONTENT_FAIL';\nconst RESET_CONTENT = 'RESET_CONTENT';\n\n// ---\n// The load protector middlewares have multiple purposes.\n//\n// 1. Maintained a delayed location that can be used to trigger an UI\n// change (such as scroll to top) after all content for the page has been\n// loaded.\n//\n// 2. When moving from a non content route to a content route, issue\n// a data reset before the content load operation. - However do not do\n// such a reset when navigating between two content routes.\n// ---\n\nexport const protectLoadStart = ({\n  dispatch,\n  getState\n}) => next => action => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  switch (action.type) {\n    case LOCATION_CHANGE:\n      const {\n        location\n      } = action.payload;\n      const {\n        pathname: path\n      } = location;\n      const currentPath = getState().router.location.pathname;\n      const result = next(action);\n      if (isCmsUi(path)) {\n        // Next path: isCmsUI, Non Content. There is no\n        // loading here, so skip counting altogether.\n        // Will update the delayed location constantly.\n        dispatch({\n          type: PROTECT_SKIPPED,\n          location\n        });\n      } else {\n        dispatch({\n          type: PROTECT_START,\n          location,\n          // Only reset before the fetch, if we depart from\n          // a not isCmsUi, Content pass. However, reset will\n          // not occur if moving between two content paths,\n          // only the postponed location will be booked.\n          resetBeforeFetch: isCmsUi(currentPath)\n        });\n      }\n      return result;\n    default:\n      return next(action);\n  }\n};\n\n// Note that there is a bit of heuristics here. We assume that every action\n// like this is beginning/ending an action. If this logic fails then the counting\n// will be off, resulting either a premature or an indefinitely missing state change.\nconst isRequestAction = action => action.type.endsWith('_PENDING');\nconst isResponseAction = action => action.type.endsWith('_SUCCESS') || action.type.endsWith('_FAIL');\n\n// Action map defines an action to be emitted before the key action\nconst mapActions = {\n  [GET_CONTENT_PENDING]: RESET_CONTENT\n};\nexport const protectLoadEnd = ({\n  dispatch,\n  getState\n}) => next => action => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  const {\n    isCounting,\n    resetBeforeFetch,\n    requestCount\n  } = getState().loadProtector;\n  if (resetBeforeFetch) {\n    const type = mapActions[action.type];\n    if (type) {\n      dispatch({\n        type\n      });\n    }\n  }\n  if (isCounting && requestCount === 1 && isResponseAction(action)) {\n    setTimeout(() => dispatch({\n      type: PROTECT_END\n    }), 0);\n  }\n  return next(action);\n};\nexport function loadProtector(state = {}, action = {}) {\n  switch (action.type) {\n    case PROTECT_START:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: true,\n        resetBeforeFetch: action.resetBeforeFetch,\n        postponedLocation: action.location\n      });\n    case PROTECT_END:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false\n      });\n    case PROTECT_SKIPPED:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n        postponedLocation: null,\n        location: action.location\n      });\n    case GET_CONTENT_SUCCESS:\n    case GET_CONTENT_FAIL:\n      if (state.isCounting) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: state.requestCount - 1,\n          postponedLocation: null,\n          location: state.postponedLocation\n        });\n      } else {\n        return state;\n      }\n    case RESET_CONTENT:\n      if (state.resetBeforeFetch) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          resetBeforeFetch: false\n        });\n      } else {\n        return state;\n      }\n    default:\n      const {\n        isCounting,\n        requestCount\n      } = state;\n      if (isCounting && isRequestAction(action)) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: requestCount + 1\n        });\n      } else if (isCounting && isResponseAction(action)) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: requestCount - 1\n        });\n      } else {\n        return state;\n      }\n  }\n}","map":{"version":3,"names":["isCmsUi","LOCATION_CHANGE","PROTECT_START","PROTECT_END","PROTECT_SKIPPED","GET_CONTENT_PENDING","GET_CONTENT_SUCCESS","GET_CONTENT_FAIL","RESET_CONTENT","protectLoadStart","dispatch","getState","next","action","type","location","payload","pathname","path","currentPath","router","result","resetBeforeFetch","isRequestAction","endsWith","isResponseAction","mapActions","protectLoadEnd","isCounting","requestCount","loadProtector","setTimeout","state","postponedLocation"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/middleware/storeProtectLoadUtils.js"],"sourcesContent":["import { isCmsUi } from '@plone/volto/helpers';\n\nconst LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\nconst PROTECT_START = '@@loadProtector/START';\nconst PROTECT_END = '@@loadProtector/END';\nconst PROTECT_SKIPPED = '@@loadProtector/SKIPPED';\nconst GET_CONTENT_PENDING = 'GET_CONTENT_PENDING';\nconst GET_CONTENT_SUCCESS = 'GET_CONTENT_SUCCESS';\nconst GET_CONTENT_FAIL = 'GET_CONTENT_FAIL';\nconst RESET_CONTENT = 'RESET_CONTENT';\n\n// ---\n// The load protector middlewares have multiple purposes.\n//\n// 1. Maintained a delayed location that can be used to trigger an UI\n// change (such as scroll to top) after all content for the page has been\n// loaded.\n//\n// 2. When moving from a non content route to a content route, issue\n// a data reset before the content load operation. - However do not do\n// such a reset when navigating between two content routes.\n// ---\n\nexport const protectLoadStart = ({ dispatch, getState }) => (next) => (\n  action,\n) => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  switch (action.type) {\n    case LOCATION_CHANGE:\n      const { location } = action.payload;\n      const { pathname: path } = location;\n      const currentPath = getState().router.location.pathname;\n      const result = next(action);\n      if (isCmsUi(path)) {\n        // Next path: isCmsUI, Non Content. There is no\n        // loading here, so skip counting altogether.\n        // Will update the delayed location constantly.\n        dispatch({\n          type: PROTECT_SKIPPED,\n          location,\n        });\n      } else {\n        dispatch({\n          type: PROTECT_START,\n          location,\n          // Only reset before the fetch, if we depart from\n          // a not isCmsUi, Content pass. However, reset will\n          // not occur if moving between two content paths,\n          // only the postponed location will be booked.\n          resetBeforeFetch: isCmsUi(currentPath),\n        });\n      }\n      return result;\n    default:\n      return next(action);\n  }\n};\n\n// Note that there is a bit of heuristics here. We assume that every action\n// like this is beginning/ending an action. If this logic fails then the counting\n// will be off, resulting either a premature or an indefinitely missing state change.\nconst isRequestAction = (action) => action.type.endsWith('_PENDING');\nconst isResponseAction = (action) =>\n  action.type.endsWith('_SUCCESS') || action.type.endsWith('_FAIL');\n\n// Action map defines an action to be emitted before the key action\nconst mapActions = {\n  [GET_CONTENT_PENDING]: RESET_CONTENT,\n};\n\nexport const protectLoadEnd = ({ dispatch, getState }) => (next) => (\n  action,\n) => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  const {\n    isCounting,\n    resetBeforeFetch,\n    requestCount,\n  } = getState().loadProtector;\n  if (resetBeforeFetch) {\n    const type = mapActions[action.type];\n    if (type) {\n      dispatch({ type });\n    }\n  }\n  if (isCounting && requestCount === 1 && isResponseAction(action)) {\n    setTimeout(\n      () =>\n        dispatch({\n          type: PROTECT_END,\n        }),\n      0,\n    );\n  }\n  return next(action);\n};\n\nexport function loadProtector(state = {}, action = {}) {\n  switch (action.type) {\n    case PROTECT_START:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: true,\n        resetBeforeFetch: action.resetBeforeFetch,\n        postponedLocation: action.location,\n      };\n    case PROTECT_END:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n      };\n    case PROTECT_SKIPPED:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n        postponedLocation: null,\n        location: action.location,\n      };\n    case GET_CONTENT_SUCCESS:\n    case GET_CONTENT_FAIL:\n      if (state.isCounting) {\n        return {\n          ...state,\n          requestCount: state.requestCount - 1,\n          postponedLocation: null,\n          location: state.postponedLocation,\n        };\n      } else {\n        return state;\n      }\n    case RESET_CONTENT:\n      if (state.resetBeforeFetch) {\n        return {\n          ...state,\n          resetBeforeFetch: false,\n        };\n      } else {\n        return state;\n      }\n    default:\n      const { isCounting, requestCount } = state;\n      if (isCounting && isRequestAction(action)) {\n        return {\n          ...state,\n          requestCount: requestCount + 1,\n        };\n      } else if (isCounting && isResponseAction(action)) {\n        return {\n          ...state,\n          requestCount: requestCount - 1,\n        };\n      } else {\n        return state;\n      }\n  }\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}