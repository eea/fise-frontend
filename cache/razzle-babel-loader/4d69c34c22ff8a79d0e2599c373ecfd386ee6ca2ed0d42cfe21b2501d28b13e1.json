{"ast":null,"code":"import _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { jsx } from 'slate-hyperscript';\nimport { Text } from 'slate';\nimport { isWhitespace } from 'volto-slate/utils';\nimport { TD, TH, COMMENT, ELEMENT_NODE, INLINE_ELEMENTS, TEXT_NODE } from '../constants';\nvar isInline = function isInline(node) {\n  return node && (node.nodeType === TEXT_NODE || INLINE_ELEMENTS.includes(node.nodeName));\n};\n\n/**\n * Deserialize to an object or an Array.\n *\n * This returns a Slate Node or null.\n */\nexport var deserialize = function deserialize(editor, el) {\n  // console.log('deserialize el:', el);\n  var htmlTagsToSlate = editor.htmlTagsToSlate;\n\n  // console.log('des:', el.nodeType, el);\n  if (el.nodeType === COMMENT) {\n    return null;\n  } else if (el.nodeType === TEXT_NODE) {\n    // instead of === '\\n' we use isWhitespace for when deserializing tables\n    // from Calc and other similar cases\n\n    // console.log('maybe whitespace', {\n    //   text: `-${el.textContent}-`,\n    //   prev: el.previousSibling,\n    //   next: el.nextSibling,\n    //   isPrev: isInline(el.previousSibling),\n    //   isNext: isInline(el.nextSibling),\n    //   prevName: el.previousSibling && el.previousSibling.nodeName,\n    //   nextName: el.nextSibling && el.nextSibling.nodeName,\n    // });\n\n    if (isWhitespace(el.textContent)) {\n      // console.log({\n      //   text: `-${el.textContent}-`,\n      //   prev: el.previousSibling,\n      //   next: el.nextSibling,\n      //   isPrev: isInline(el.previousSibling),\n      //   isNext: isInline(el.nextSibling),\n      //   prevName: el.previousSibling && el.previousSibling.nodeName,\n      //   nextName: el.nextSibling && el.nextSibling.nodeName,\n      // });\n      // if it's empty text between 2 tags, it should be ignored\n      return isInline(el.previousSibling) || isInline(el.nextSibling) ? {\n        text: el.textContent\n      } // perceptually multiple whitespace render as a single space\n      : null;\n    }\n    return {\n      text: el.textContent.replace(/\\n$/g, ' ').replace(/\\n/g, ' ').replace(/\\t/g, '')\n    };\n  } else if (el.nodeType !== ELEMENT_NODE) {\n    return null;\n  } else if (el.nodeName === 'BR') {\n    // TODO: is handling <br> like this ok in all cases ?\n    return {\n      text: '\\n'\n    };\n  }\n  if (el.getAttribute('data-slate-data')) {\n    return typeDeserialize(editor, el);\n  }\n  var nodeName = el.nodeName;\n  if (htmlTagsToSlate[nodeName]) {\n    return htmlTagsToSlate[nodeName](editor, el);\n  }\n  return deserializeChildren(el, editor); // fallback deserializer\n};\n\nexport var typeDeserialize = function typeDeserialize(editor, el) {\n  var jsData = el.getAttribute('data-slate-data');\n  var _JSON$parse = JSON.parse(jsData),\n    type = _JSON$parse.type,\n    data = _JSON$parse.data;\n  return jsx('element', {\n    type: type,\n    data: data\n  }, deserializeChildren(el, editor));\n};\nexport var deserializeChildren = function deserializeChildren(parent, editor) {\n  return Array.from(parent.childNodes).map(function (el) {\n    return deserialize(editor, el);\n  }).flat();\n};\nexport var blockTagDeserializer = function blockTagDeserializer(tagname) {\n  return function (editor, el) {\n    // if (tagname === 'h2') debugger;\n    var children = deserializeChildren(el, editor).filter(function (n) {\n      return n !== null;\n    });\n    if ([TD, TH].includes(tagname) && children.length > 0 && typeof children[0] === 'string') {\n      // TODO: should here be handled the cases when there are more strings in\n      // `children` or when there are besides strings other types of nodes too?\n      var p = {\n        type: 'div',\n        children: [{\n          text: ''\n        }]\n      };\n      p.children[0].text = children[0];\n      children = [p];\n    }\n\n    // normalizes block elements so that they're never empty\n    // Avoids a hard crash from the Slate editor\n    var hasValidChildren = children.length && children.find(function (c) {\n      return !!c;\n    });\n    if (!hasValidChildren) {\n      children = [{\n        text: ''\n      }];\n    }\n    return jsx('element', {\n      type: tagname\n    }, children);\n  };\n};\nexport var bodyTagDeserializer = function bodyTagDeserializer(editor, el) {\n  return jsx('fragment', {}, deserializeChildren(el, editor));\n};\nexport var inlineTagDeserializer = function inlineTagDeserializer(attrs) {\n  return function (editor, el) {\n    return deserializeChildren(el, editor).map(function (child) {\n      var res = Text.isText(child) || typeof child === 'string' ? jsx('text', attrs, child) : _objectSpread(_objectSpread({}, child), {}, {\n        attrs: attrs // pass the inline attrs as separate object\n      });\n\n      return res;\n    });\n  };\n};\nexport var spanTagDeserializer = function spanTagDeserializer(editor, el) {\n  var style = el.getAttribute('style') || '';\n  var children = el.childNodes;\n  if (\n  // handle formatting from OpenOffice\n  children.length === 1 && children[0].nodeType === 3 && children[0].textContent === '\\n') {\n    return jsx('text', {}, ' ');\n  }\n  children = deserializeChildren(el, editor);\n\n  // whitespace is replaced by deserialize() with null;\n  children = children.map(function (c) {\n    return c === null ? ' ' : c;\n  });\n\n  // TODO: handle sub/sup as <sub> and <sup>\n  // Handle Google Docs' <sub> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:sub') > -1) {\n    var attrs = {\n      sub: true\n    };\n    return children.map(function (child) {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  // Handle Google Docs' <sup> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:super') > -1) {\n    var _attrs = {\n      sup: true\n    };\n    return children.map(function (child) {\n      return jsx('text', _attrs, child);\n    });\n  }\n  var res = children.find(function (c) {\n    return typeof c !== 'string';\n  }) ? children : jsx('text', {}, children);\n  return res;\n};\nexport var bTagDeserializer = function bTagDeserializer(editor, el) {\n  // Google Docs does weird things with <b> tag\n  return (el.getAttribute('id') || '').indexOf('docs-internal-guid') > -1 ? deserializeChildren(el, editor) : jsx('element', {\n    type: 'b'\n  }, deserializeChildren(el, editor));\n};\nexport var codeTagDeserializer = function codeTagDeserializer(editor, el) {\n  return jsx('element', {\n    type: 'code'\n  }, el.textContent);\n};\nexport var preTagDeserializer = function preTagDeserializer(editor, el) {\n  // Based on Slate example implementation. Replaces <pre> tags with <code>.\n  // Comment: I don't know how good of an idea is this. I'd rather have two\n  // separate formats: \"preserve whitespace\" and \"code\". This feels like a hack\n  var nodeName = el.nodeName;\n  var parent = el;\n  if (el.childNodes[0] && el.childNodes[0].nodeName === 'CODE') {\n    parent = el.childNodes[0];\n    return codeTagDeserializer(editor, parent);\n  }\n  return blockTagDeserializer(nodeName)(editor, parent);\n};\nexport default deserialize;","map":{"version":3,"names":["jsx","Text","isWhitespace","TD","TH","COMMENT","ELEMENT_NODE","INLINE_ELEMENTS","TEXT_NODE","isInline","node","nodeType","includes","nodeName","deserialize","editor","el","htmlTagsToSlate","textContent","previousSibling","nextSibling","text","replace","getAttribute","typeDeserialize","deserializeChildren","jsData","JSON","parse","type","data","parent","Array","from","childNodes","map","flat","blockTagDeserializer","tagname","children","filter","n","length","p","hasValidChildren","find","c","bodyTagDeserializer","inlineTagDeserializer","attrs","child","res","isText","spanTagDeserializer","style","indexOf","sub","sup","bTagDeserializer","codeTagDeserializer","preTagDeserializer"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-slate/src/editor/deserialize.js"],"sourcesContent":["import { jsx } from 'slate-hyperscript';\nimport { Text } from 'slate';\nimport { isWhitespace } from 'volto-slate/utils';\nimport {\n  TD,\n  TH,\n  COMMENT,\n  ELEMENT_NODE,\n  INLINE_ELEMENTS,\n  TEXT_NODE,\n} from '../constants';\n\nconst isInline = (node) =>\n  node &&\n  (node.nodeType === TEXT_NODE || INLINE_ELEMENTS.includes(node.nodeName));\n\n/**\n * Deserialize to an object or an Array.\n *\n * This returns a Slate Node or null.\n */\nexport const deserialize = (editor, el) => {\n  // console.log('deserialize el:', el);\n  const { htmlTagsToSlate } = editor;\n\n  // console.log('des:', el.nodeType, el);\n  if (el.nodeType === COMMENT) {\n    return null;\n  } else if (el.nodeType === TEXT_NODE) {\n    // instead of === '\\n' we use isWhitespace for when deserializing tables\n    // from Calc and other similar cases\n\n    // console.log('maybe whitespace', {\n    //   text: `-${el.textContent}-`,\n    //   prev: el.previousSibling,\n    //   next: el.nextSibling,\n    //   isPrev: isInline(el.previousSibling),\n    //   isNext: isInline(el.nextSibling),\n    //   prevName: el.previousSibling && el.previousSibling.nodeName,\n    //   nextName: el.nextSibling && el.nextSibling.nodeName,\n    // });\n\n    if (isWhitespace(el.textContent)) {\n      // console.log({\n      //   text: `-${el.textContent}-`,\n      //   prev: el.previousSibling,\n      //   next: el.nextSibling,\n      //   isPrev: isInline(el.previousSibling),\n      //   isNext: isInline(el.nextSibling),\n      //   prevName: el.previousSibling && el.previousSibling.nodeName,\n      //   nextName: el.nextSibling && el.nextSibling.nodeName,\n      // });\n      // if it's empty text between 2 tags, it should be ignored\n      return isInline(el.previousSibling) || isInline(el.nextSibling)\n        ? { text: el.textContent } // perceptually multiple whitespace render as a single space\n        : null;\n    }\n    return {\n      text: el.textContent\n        .replace(/\\n$/g, ' ')\n        .replace(/\\n/g, ' ')\n        .replace(/\\t/g, ''),\n    };\n  } else if (el.nodeType !== ELEMENT_NODE) {\n    return null;\n  } else if (el.nodeName === 'BR') {\n    // TODO: is handling <br> like this ok in all cases ?\n    return { text: '\\n' };\n  }\n\n  if (el.getAttribute('data-slate-data')) {\n    return typeDeserialize(editor, el);\n  }\n\n  const { nodeName } = el;\n\n  if (htmlTagsToSlate[nodeName]) {\n    return htmlTagsToSlate[nodeName](editor, el);\n  }\n\n  return deserializeChildren(el, editor); // fallback deserializer\n};\n\nexport const typeDeserialize = (editor, el) => {\n  const jsData = el.getAttribute('data-slate-data');\n  const { type, data } = JSON.parse(jsData);\n  return jsx('element', { type, data }, deserializeChildren(el, editor));\n};\n\nexport const deserializeChildren = (parent, editor) =>\n  Array.from(parent.childNodes)\n    .map((el) => deserialize(editor, el))\n    .flat();\n\nexport const blockTagDeserializer = (tagname) => (editor, el) => {\n  // if (tagname === 'h2') debugger;\n  let children = deserializeChildren(el, editor).filter((n) => n !== null);\n\n  if (\n    [TD, TH].includes(tagname) &&\n    children.length > 0 &&\n    typeof children[0] === 'string'\n  ) {\n    // TODO: should here be handled the cases when there are more strings in\n    // `children` or when there are besides strings other types of nodes too?\n    const p = { type: 'div', children: [{ text: '' }] };\n    p.children[0].text = children[0];\n    children = [p];\n  }\n\n  // normalizes block elements so that they're never empty\n  // Avoids a hard crash from the Slate editor\n  const hasValidChildren = children.length && children.find((c) => !!c);\n  if (!hasValidChildren) {\n    children = [{ text: '' }];\n  }\n\n  return jsx('element', { type: tagname }, children);\n};\n\nexport const bodyTagDeserializer = (editor, el) => {\n  return jsx('fragment', {}, deserializeChildren(el, editor));\n};\n\nexport const inlineTagDeserializer = (attrs) => (editor, el) => {\n  return deserializeChildren(el, editor).map((child) => {\n    const res =\n      Text.isText(child) || typeof child === 'string'\n        ? jsx('text', attrs, child)\n        : {\n            ...child,\n            attrs, // pass the inline attrs as separate object\n          };\n    return res;\n  });\n};\n\nexport const spanTagDeserializer = (editor, el) => {\n  const style = el.getAttribute('style') || '';\n  let children = el.childNodes;\n  if (\n    // handle formatting from OpenOffice\n    children.length === 1 &&\n    children[0].nodeType === 3 &&\n    children[0].textContent === '\\n'\n  ) {\n    return jsx('text', {}, ' ');\n  }\n  children = deserializeChildren(el, editor);\n\n  // whitespace is replaced by deserialize() with null;\n  children = children.map((c) => (c === null ? ' ' : c));\n\n  // TODO: handle sub/sup as <sub> and <sup>\n  // Handle Google Docs' <sub> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:sub') > -1) {\n    const attrs = { sub: true };\n    return children.map((child) => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  // Handle Google Docs' <sup> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:super') > -1) {\n    const attrs = { sup: true };\n    return children.map((child) => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  const res = children.find((c) => typeof c !== 'string')\n    ? children\n    : jsx('text', {}, children);\n  return res;\n};\n\nexport const bTagDeserializer = (editor, el) => {\n  // Google Docs does weird things with <b> tag\n  return (el.getAttribute('id') || '').indexOf('docs-internal-guid') > -1\n    ? deserializeChildren(el, editor)\n    : jsx('element', { type: 'b' }, deserializeChildren(el, editor));\n};\n\nexport const codeTagDeserializer = (editor, el) => {\n  return jsx('element', { type: 'code' }, el.textContent);\n};\n\nexport const preTagDeserializer = (editor, el) => {\n  // Based on Slate example implementation. Replaces <pre> tags with <code>.\n  // Comment: I don't know how good of an idea is this. I'd rather have two\n  // separate formats: \"preserve whitespace\" and \"code\". This feels like a hack\n  const { nodeName } = el;\n  let parent = el;\n\n  if (el.childNodes[0] && el.childNodes[0].nodeName === 'CODE') {\n    parent = el.childNodes[0];\n    return codeTagDeserializer(editor, parent);\n  }\n\n  return blockTagDeserializer(nodeName)(editor, parent);\n};\n\nexport default deserialize;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}