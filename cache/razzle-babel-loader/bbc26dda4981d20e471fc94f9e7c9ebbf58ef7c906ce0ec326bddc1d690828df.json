{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n/* eslint-disable react-hooks/exhaustive-deps */\nimport { useEffect, useState } from 'react';\nimport { getBaseUrl, flattenToAppURL } from '@plone/volto/helpers';\nimport qs from 'querystring';\nexport function getBasePath(url) {\n  return flattenToAppURL(getBaseUrl(url));\n}\nexport function getConnectorPath(provider_url, hashValue) {\n  return `${provider_url}${hashValue ? `#${hashValue}` : '#_default'}`;\n}\nexport function getProviderUrl(url) {\n  if (!url) return '';\n  return flattenToAppURL(url).replace('@@download/file', '').replace(/\\/*$/, '');\n}\nexport function getForm({\n  data = {},\n  location,\n  pagination,\n  extraQuery = {},\n  extraConditions\n}) {\n  var _location$search;\n  const params = _objectSpread(_objectSpread(_objectSpread({}, qs.parse(location === null || location === void 0 ? void 0 : (_location$search = location.search) === null || _location$search === void 0 ? void 0 : _location$search.replace('?', '')) || {}), data.form || {}), extraQuery);\n  const allowedParams = data.allowedParams;\n  let allowedParamsObj = null;\n  if (Object.keys(allowedParams || {}).length) {\n    allowedParamsObj = {};\n    allowedParams.forEach(param => {\n      if (params[param]) {\n        allowedParamsObj[param] = params[param];\n      }\n    });\n  }\n  return _objectSpread(_objectSpread(_objectSpread({}, allowedParamsObj || params), extraConditions ? {\n    extra_conditions: extraConditions\n  } : {}), pagination !== null && pagination !== void 0 && pagination.enabled ? {\n    p: pagination.activePage,\n    nrOfHits: pagination.itemsPerPage\n  } : {});\n}\nexport function getDataQuery({\n  connected_data_parameters,\n  content = {},\n  data = {},\n  location,\n  params,\n  provider_url\n}) {\n  var _data$has_data_query_, _connected_data_param, _connected_data_param2;\n  let byContextPath = [];\n  let byRouteParameters = [];\n  const path = flattenToAppURL(content === null || content === void 0 ? void 0 : content['@id']) || location.pathname.replace('/edit', '');\n  const has_data_query_by_provider = (_data$has_data_query_ = data.has_data_query_by_provider) !== null && _data$has_data_query_ !== void 0 ? _data$has_data_query_ : true;\n  const byProviderPath = has_data_query_by_provider ? (connected_data_parameters === null || connected_data_parameters === void 0 ? void 0 : (_connected_data_param = connected_data_parameters.byProviderPath) === null || _connected_data_param === void 0 ? void 0 : _connected_data_param[provider_url]) || {} : {};\n  ((connected_data_parameters === null || connected_data_parameters === void 0 ? void 0 : (_connected_data_param2 = connected_data_parameters.byContextPath) === null || _connected_data_param2 === void 0 ? void 0 : _connected_data_param2[path]) || []).forEach(data_query => {\n    if (!params[data_query.i]) {\n      byContextPath.push(data_query);\n    } else {\n      byRouteParameters.push(_objectSpread(_objectSpread({}, data_query), {}, {\n        v: [params[data_query.i]]\n      }));\n    }\n  });\n  const filters = Object.keys(byProviderPath).map(key => byProviderPath[key]) || [];\n  // if (pagination.enabled) {\n  //   return [...(data?.data_query || []), ...byContextPath, ...filters];\n  // }\n  return [...((data === null || data === void 0 ? void 0 : data.data_query) || []), ...byContextPath, ...byRouteParameters, ...filters];\n}\n\n/*\n * refreshes chart data using data from provider\n * this is similar to mixProviderData from ConnectedChart, but it doesn't apply\n * transformation\n */\nexport function updateChartDataFromProvider(chartData, providerData) {\n  if (!providerData) return chartData;\n  const providerDataColumns = Object.keys(providerData);\n  const res = chartData.map(trace => {\n    const newTrace = _objectSpread({}, trace || {});\n    Object.keys(trace).forEach(tk => {\n      const originalColumn = tk.replace(/src$/, '');\n      if (tk.endsWith('src') && Object.keys(trace).includes(originalColumn) && typeof trace[tk] === 'string' && providerDataColumns.includes(trace[tk])) {\n        let values = providerData[trace[tk]];\n        newTrace[originalColumn] = values;\n      }\n    });\n    newTrace.transforms = (trace.transforms || []).map(transform => _objectSpread(_objectSpread({}, transform), {}, {\n      target: providerData[transform.targetsrc]\n    }));\n    return newTrace;\n  });\n  return res;\n}\n\n/**\n * mixProviderData.\n *\n * Mixes provider data with saved chart data, optionally filtered by connected\n * data parameters. To be used in a plotly chart\n *\n * @param {} chartData\n * @param {} providerData\n * @param {} parameters\n */\nexport function mixProviderData(chartData, providerData, parameters, connectedDataTemplateString) {\n  const providerDataColumns = Object.keys(providerData);\n  const res = (chartData || []).map(trace => {\n    Object.keys(trace).forEach(tk => {\n      const originalColumn = tk.replace(/src$/, '');\n      if (tk.endsWith('src') && Object.keys(trace).includes(originalColumn) && typeof trace[tk] === 'string' && providerDataColumns.includes(trace[tk])) {\n        let values = providerData[trace[tk]];\n        trace[originalColumn] = values;\n        if (!(parameters && parameters.length)) return;\n        const filter = parameters.find(f => {\n          // finds any available filter that matches the data\n          let {\n            i: index\n          } = f;\n          index = index.toLowerCase().replace('taxonomy_', '');\n          return Object.keys(providerData || {}).map(k => k.toLowerCase()).includes(index);\n        });\n        if (!filter) return providerData;\n        let {\n          i: filterName,\n          v: [filterValue]\n        } = filter;\n        filterName = filterName.replace('taxonomy_', '');\n        const real_index = providerDataColumns.find(n => n.toLowerCase() === filterName) || filterName;\n\n        // tweak transformation filters using data parameters\n        (trace.transforms || []).forEach(transform => {\n          if (transform.targetsrc === real_index && filterValue) {\n            if (!connectedDataTemplateString) {\n              transform.value = filterValue;\n              transform.target = providerData[transform.targetsrc];\n            } else {\n              let transformValue = transform.value;\n              const tValueIsArray = Array.isArray(transformValue);\n              transformValue = tValueIsArray ? transformValue.join() : transformValue;\n              connectedDataTemplateString.split(',').forEach(templString => {\n                transformValue = transformValue.replace(templString, filterValue);\n              });\n              transform.value = tValueIsArray ? transformValue.split(',') : transformValue;\n              transform.target = providerData[transform.targetsrc];\n            }\n          }\n        });\n      }\n    });\n    return trace;\n  });\n  return res;\n}\n\n/* Connected data parameters */\n\nexport function getConnectedDataParametersForContext(connected_data_parameters, url) {\n  let path = getBasePath(url || '');\n  const {\n    byContextPath = {}\n  } = connected_data_parameters;\n  return byContextPath[path] || null;\n}\nexport function getConnectedDataParametersForProvider(connected_data_parameters, provider_url) {\n  let path = getBasePath(provider_url || '');\n  const {\n    byProviderPath = {}\n  } = connected_data_parameters;\n  const res = Object.keys(byProviderPath[path] || {}).map(filter => byProviderPath[path][filter]);\n  return res;\n}\n\n// hook when component is in visible viewport, rootMargin is how much of the element should be visible before loading up\n// Example\"-300px\" for In this case it would only be considered onScreen if more ... 300px is visible\nexport function useOnScreen(ref, rootMargin = '0px') {\n  // State and setter for storing whether element is visible\n  const {\n    0: isIntersecting,\n    1: setIntersecting\n  } = useState(false);\n  const {\n    0: entryCount,\n    1: setEntryCount\n  } = useState(0);\n  useEffect(() => {\n    const observer = new IntersectionObserver(([entry]) => {\n      // Update our state when observer callback fires\n      setIntersecting(entry.isIntersecting);\n    }, {\n      rootMargin\n    });\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n    var curRef = ref.current;\n    return () => {\n      observer.unobserve(ref.current ? ref.current : curRef);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n  useEffect(() => {\n    if (isIntersecting) {\n      setEntryCount(entryCount + 1);\n    }\n  }, [isIntersecting]);\n  return {\n    entryCount,\n    isIntersecting\n  };\n}\n\n// export function mergeSchema(schema, schemaExtend, ...args) {\n//   const fieldsets = {};\n//   const fieldsetsOrder = [];\n//   const _schema =\n//     (typeof schema === 'function' ? schema(...args) : schema) || null;\n//   const _schemaExtend =\n//     (typeof schemaExtend === 'function'\n//       ? schemaExtend(...args)\n//       : schemaExtend) || null;\n//   if (!_schema || (_schema && !_schemaExtend)) return null;\n\n//   [...(_schema.fieldsets || []), ...(_schemaExtend.fieldsets || [])].forEach(\n//     (fieldset) => {\n//       if (!fieldsetsOrder.includes(fieldset.id)) {\n//         fieldsetsOrder.push(fieldset.id);\n//       }\n//       if (!fieldsets[fieldset.id]) {\n//         fieldsets[fieldset.id] = {};\n//       }\n//       fieldsets[fieldset.id] = {\n//         id: fieldset.id,\n//         title: fieldset.title,\n//         fields: [\n//           ...new Set([\n//             ...(fieldsets[fieldset.id].fields || []),\n//             ...(fieldset.fields || []),\n//           ]),\n//         ],\n//       };\n//     },\n//   );\n\n//   return {\n//     title: _schemaExtend.title || _schema.title,\n//     fieldsets,\n//     properties: {\n//       ...(_schema.properties || {}),\n//       ...(_schemaExtend.properties || {}),\n//     },\n//     required: [...(_schema.required || []), ...(_schemaExtend.required || [])],\n//   };\n// }\n\nexport const getFilteredURL = (url, connected_data_parameters = []) => {\n  if (!(connected_data_parameters !== null && connected_data_parameters !== void 0 && connected_data_parameters.length)) return url;\n  let decodedURL = decodeURIComponent(url);\n  const queries = decodedURL.match(/(<<)(.*?)*>>/g); //safari: don't use lookbehind\n  if (!(queries !== null && queries !== void 0 && queries.length)) return url;\n  const filteredQueries = queries.map(query => query.replace('<<', '').replace('>>', ''));\n  const keys = connected_data_parameters.map(param => param.i);\n  for (let poz in filteredQueries) {\n    const key = filteredQueries[poz];\n    const paramPoz = keys.indexOf(key);\n    if (paramPoz > -1) {\n      decodedURL = decodedURL.replace(`<<${key}>>`, connected_data_parameters[paramPoz].v[0]);\n      continue;\n    }\n  }\n  return decodedURL;\n};","map":{"version":3,"names":["useEffect","useState","getBaseUrl","flattenToAppURL","qs","getBasePath","url","getConnectorPath","provider_url","hashValue","getProviderUrl","replace","getForm","data","location","pagination","extraQuery","extraConditions","params","parse","search","form","allowedParams","allowedParamsObj","Object","keys","length","forEach","param","extra_conditions","enabled","p","activePage","nrOfHits","itemsPerPage","getDataQuery","connected_data_parameters","content","byContextPath","byRouteParameters","path","pathname","has_data_query_by_provider","byProviderPath","data_query","i","push","v","filters","map","key","updateChartDataFromProvider","chartData","providerData","providerDataColumns","res","trace","newTrace","tk","originalColumn","endsWith","includes","values","transforms","transform","target","targetsrc","mixProviderData","parameters","connectedDataTemplateString","filter","find","f","index","toLowerCase","k","filterName","filterValue","real_index","n","value","transformValue","tValueIsArray","Array","isArray","join","split","templString","getConnectedDataParametersForContext","getConnectedDataParametersForProvider","useOnScreen","ref","rootMargin","isIntersecting","setIntersecting","entryCount","setEntryCount","observer","IntersectionObserver","entry","current","observe","curRef","unobserve","getFilteredURL","decodedURL","decodeURIComponent","queries","match","filteredQueries","query","poz","paramPoz","indexOf"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-datablocks/src/helpers.js"],"sourcesContent":["/* eslint-disable react-hooks/exhaustive-deps */\nimport { useEffect, useState } from 'react';\nimport { getBaseUrl, flattenToAppURL } from '@plone/volto/helpers';\nimport qs from 'querystring';\n\nexport function getBasePath(url) {\n  return flattenToAppURL(getBaseUrl(url));\n}\n\nexport function getConnectorPath(provider_url, hashValue) {\n  return `${provider_url}${hashValue ? `#${hashValue}` : '#_default'}`;\n}\n\nexport function getProviderUrl(url) {\n  if (!url) return '';\n  return flattenToAppURL(url)\n    .replace('@@download/file', '')\n    .replace(/\\/*$/, '');\n}\n\nexport function getForm({\n  data = {},\n  location,\n  pagination,\n  extraQuery = {},\n  extraConditions,\n}) {\n  const params = {\n    ...(qs.parse(location?.search?.replace('?', '')) || {}),\n    ...(data.form || {}),\n    ...extraQuery,\n  };\n  const allowedParams = data.allowedParams;\n  let allowedParamsObj = null;\n  if (Object.keys(allowedParams || {}).length) {\n    allowedParamsObj = {};\n    allowedParams.forEach((param) => {\n      if (params[param]) {\n        allowedParamsObj[param] = params[param];\n      }\n    });\n  }\n\n  return {\n    ...(allowedParamsObj || params),\n    ...(extraConditions ? { extra_conditions: extraConditions } : {}),\n    ...(pagination?.enabled\n      ? { p: pagination.activePage, nrOfHits: pagination.itemsPerPage }\n      : {}),\n  };\n}\n\nexport function getDataQuery({\n  connected_data_parameters,\n  content = {},\n  data = {},\n  location,\n  params,\n  provider_url,\n}) {\n  let byContextPath = [];\n  let byRouteParameters = [];\n  const path =\n    flattenToAppURL(content?.['@id']) || location.pathname.replace('/edit', '');\n  const has_data_query_by_provider = data.has_data_query_by_provider ?? true;\n  const byProviderPath = has_data_query_by_provider\n    ? connected_data_parameters?.byProviderPath?.[provider_url] || {}\n    : {};\n\n  (connected_data_parameters?.byContextPath?.[path] || []).forEach(\n    (data_query) => {\n      if (!params[data_query.i]) {\n        byContextPath.push(data_query);\n      } else {\n        byRouteParameters.push({ ...data_query, v: [params[data_query.i]] });\n      }\n    },\n  );\n\n  const filters =\n    Object.keys(byProviderPath).map((key) => byProviderPath[key]) || [];\n  // if (pagination.enabled) {\n  //   return [...(data?.data_query || []), ...byContextPath, ...filters];\n  // }\n  return [\n    ...(data?.data_query || []),\n    ...byContextPath,\n    ...byRouteParameters,\n    ...filters,\n  ];\n}\n\n/*\n * refreshes chart data using data from provider\n * this is similar to mixProviderData from ConnectedChart, but it doesn't apply\n * transformation\n */\nexport function updateChartDataFromProvider(chartData, providerData) {\n  if (!providerData) return chartData;\n\n  const providerDataColumns = Object.keys(providerData);\n\n  const res = chartData.map((trace) => {\n    const newTrace = { ...(trace || {}) };\n    Object.keys(trace).forEach((tk) => {\n      const originalColumn = tk.replace(/src$/, '');\n      if (\n        tk.endsWith('src') &&\n        Object.keys(trace).includes(originalColumn) &&\n        typeof trace[tk] === 'string' &&\n        providerDataColumns.includes(trace[tk])\n      ) {\n        let values = providerData[trace[tk]];\n\n        newTrace[originalColumn] = values;\n      }\n    });\n    newTrace.transforms = (trace.transforms || []).map((transform) => ({\n      ...transform,\n      target: providerData[transform.targetsrc],\n    }));\n    return newTrace;\n  });\n  return res;\n}\n\n/**\n * mixProviderData.\n *\n * Mixes provider data with saved chart data, optionally filtered by connected\n * data parameters. To be used in a plotly chart\n *\n * @param {} chartData\n * @param {} providerData\n * @param {} parameters\n */\nexport function mixProviderData(\n  chartData,\n  providerData,\n  parameters,\n  connectedDataTemplateString,\n) {\n  const providerDataColumns = Object.keys(providerData);\n  const res = (chartData || []).map((trace) => {\n    Object.keys(trace).forEach((tk) => {\n      const originalColumn = tk.replace(/src$/, '');\n      if (\n        tk.endsWith('src') &&\n        Object.keys(trace).includes(originalColumn) &&\n        typeof trace[tk] === 'string' &&\n        providerDataColumns.includes(trace[tk])\n      ) {\n        let values = providerData[trace[tk]];\n\n        trace[originalColumn] = values;\n\n        if (!(parameters && parameters.length)) return;\n\n        const filter = parameters.find((f) => {\n          // finds any available filter that matches the data\n          let { i: index } = f;\n          index = index.toLowerCase().replace('taxonomy_', '');\n          return Object.keys(providerData || {})\n            .map((k) => k.toLowerCase())\n            .includes(index);\n        });\n        if (!filter) return providerData;\n\n        let {\n          i: filterName,\n          v: [filterValue],\n        } = filter;\n\n        filterName = filterName.replace('taxonomy_', '');\n\n        const real_index =\n          providerDataColumns.find((n) => n.toLowerCase() === filterName) ||\n          filterName;\n\n        // tweak transformation filters using data parameters\n        (trace.transforms || []).forEach((transform) => {\n          if (transform.targetsrc === real_index && filterValue) {\n            if (!connectedDataTemplateString) {\n              transform.value = filterValue;\n              transform.target = providerData[transform.targetsrc];\n            } else {\n              let transformValue = transform.value;\n              const tValueIsArray = Array.isArray(transformValue);\n              transformValue = tValueIsArray\n                ? transformValue.join()\n                : transformValue;\n\n              connectedDataTemplateString.split(',').forEach((templString) => {\n                transformValue = transformValue.replace(\n                  templString,\n                  filterValue,\n                );\n              });\n\n              transform.value = tValueIsArray\n                ? transformValue.split(',')\n                : transformValue;\n              transform.target = providerData[transform.targetsrc];\n            }\n          }\n        });\n      }\n    });\n\n    return trace;\n  });\n  return res;\n}\n\n/* Connected data parameters */\n\nexport function getConnectedDataParametersForContext(\n  connected_data_parameters,\n  url,\n) {\n  let path = getBasePath(url || '');\n\n  const { byContextPath = {} } = connected_data_parameters;\n\n  return byContextPath[path] || null;\n}\n\nexport function getConnectedDataParametersForProvider(\n  connected_data_parameters,\n  provider_url,\n) {\n  let path = getBasePath(provider_url || '');\n\n  const { byProviderPath = {} } = connected_data_parameters;\n  const res = Object.keys(byProviderPath[path] || {}).map(\n    (filter) => byProviderPath[path][filter],\n  );\n\n  return res;\n}\n\n// hook when component is in visible viewport, rootMargin is how much of the element should be visible before loading up\n// Example\"-300px\" for In this case it would only be considered onScreen if more ... 300px is visible\nexport function useOnScreen(ref, rootMargin = '0px') {\n  // State and setter for storing whether element is visible\n  const [isIntersecting, setIntersecting] = useState(false);\n  const [entryCount, setEntryCount] = useState(0);\n  useEffect(() => {\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        // Update our state when observer callback fires\n        setIntersecting(entry.isIntersecting);\n      },\n      {\n        rootMargin,\n      },\n    );\n    if (ref.current) {\n      observer.observe(ref.current);\n    }\n    var curRef = ref.current;\n    return () => {\n      observer.unobserve(ref.current ? ref.current : curRef);\n    };\n  }, []); // Empty array ensures that effect is only run on mount and unmount\n  useEffect(() => {\n    if (isIntersecting) {\n      setEntryCount(entryCount + 1);\n    }\n  }, [isIntersecting]);\n  return { entryCount, isIntersecting };\n}\n\n// export function mergeSchema(schema, schemaExtend, ...args) {\n//   const fieldsets = {};\n//   const fieldsetsOrder = [];\n//   const _schema =\n//     (typeof schema === 'function' ? schema(...args) : schema) || null;\n//   const _schemaExtend =\n//     (typeof schemaExtend === 'function'\n//       ? schemaExtend(...args)\n//       : schemaExtend) || null;\n//   if (!_schema || (_schema && !_schemaExtend)) return null;\n\n//   [...(_schema.fieldsets || []), ...(_schemaExtend.fieldsets || [])].forEach(\n//     (fieldset) => {\n//       if (!fieldsetsOrder.includes(fieldset.id)) {\n//         fieldsetsOrder.push(fieldset.id);\n//       }\n//       if (!fieldsets[fieldset.id]) {\n//         fieldsets[fieldset.id] = {};\n//       }\n//       fieldsets[fieldset.id] = {\n//         id: fieldset.id,\n//         title: fieldset.title,\n//         fields: [\n//           ...new Set([\n//             ...(fieldsets[fieldset.id].fields || []),\n//             ...(fieldset.fields || []),\n//           ]),\n//         ],\n//       };\n//     },\n//   );\n\n//   return {\n//     title: _schemaExtend.title || _schema.title,\n//     fieldsets,\n//     properties: {\n//       ...(_schema.properties || {}),\n//       ...(_schemaExtend.properties || {}),\n//     },\n//     required: [...(_schema.required || []), ...(_schemaExtend.required || [])],\n//   };\n// }\n\nexport const getFilteredURL = (url, connected_data_parameters = []) => {\n  if (!connected_data_parameters?.length) return url;\n  let decodedURL = decodeURIComponent(url);\n  const queries = decodedURL.match(/(<<)(.*?)*>>/g); //safari: don't use lookbehind\n  if (!queries?.length) return url;\n\n  const filteredQueries = queries.map((query) =>\n    query.replace('<<', '').replace('>>', ''),\n  );\n\n  const keys = connected_data_parameters.map((param) => param.i);\n  for (let poz in filteredQueries) {\n    const key = filteredQueries[poz];\n    const paramPoz = keys.indexOf(key);\n    if (paramPoz > -1) {\n      decodedURL = decodedURL.replace(\n        `<<${key}>>`,\n        connected_data_parameters[paramPoz].v[0],\n      );\n\n      continue;\n    }\n  }\n  return decodedURL;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}