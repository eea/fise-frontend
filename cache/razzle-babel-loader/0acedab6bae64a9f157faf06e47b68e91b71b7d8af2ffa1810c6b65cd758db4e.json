{"ast":null,"code":"import _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _castArray from \"lodash/castArray\";\nimport { Editor, Transforms, Range, Node } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { isCursorInList } from 'volto-slate/utils';\nimport { LI } from 'volto-slate/constants';\nimport config from '@plone/volto/registry';\n\n/**\n * Get the nodes with a type included in `types` in the selection (from root to leaf).\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesByType(editor, types) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  types = _castArray(types);\n  return Editor.nodes(editor, _objectSpread({\n    match: function match(n) {\n      return types.includes(n.type);\n    }\n  }, options));\n}\n\n/**\n * Is there a node with a type included in `types` in the selection (from root to leaf).\n */\nexport function isNodeInSelection(editor, types) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _getSelectionNodesByT = getSelectionNodesByType(editor, types, options),\n    _getSelectionNodesByT2 = _slicedToArray(_getSelectionNodesByT, 1),\n    match = _getSelectionNodesByT2[0];\n  return !!match;\n}\n\n/**\n * getSelectionNodesArrayByType.\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesArrayByType(editor, types) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  return Array.from(getSelectionNodesByType(editor, types, options));\n}\n\n/**\n * getMaxRange.\n *\n * @param {} editor\n *\n * TODO: is [0] ok as a path?\n */\nexport function getMaxRange(editor) {\n  var maxRange = {\n    anchor: Editor.start(editor, [0]),\n    focus: Editor.end(editor, [0])\n  };\n  return maxRange;\n}\n\n/**\n * selectAll.\n *\n * @param {} editor\n */\nexport function selectAll(editor) {\n  Transforms.select(editor, getMaxRange(editor));\n}\n\n// In the isCursorAtBlockStart/End functions maybe use a part of these pieces of code:\n// Range.isCollapsed(editor.selection) &&\n// Point.equals(editor.selection.anchor, Editor.start(editor, []))\n\n/**\n * isCursorAtBlockStart.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockStart(editor) {\n  // It does not work properly with lists\n\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    var anchor = editor.selection.anchor;\n    return anchor.offset > 0 ? false : anchor.path.reduce(function (acc, x) {\n      return acc + x;\n    }, 0) === 0;\n    // anchor.path.length === 2 &&\n  }\n\n  return false;\n}\n\n/**\n * isCursorAtBlockEnd.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockEnd(editor) {\n  // fixSelection(editor);\n\n  // if the selection is collapsed\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    var _editor$selection;\n    var anchor = ((_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor) || {};\n\n    // the last block node in the editor\n    var _Node$last = Node.last(editor, []),\n      _Node$last2 = _slicedToArray(_Node$last, 1),\n      node = _Node$last2[0];\n    if (\n    // if the node with the selection is the last block node\n    Node.get(editor, anchor.path) === node &&\n    // if the collapsed selection is at the end of the last block node\n    anchor.offset === node.text.length) {\n      return true;\n    }\n  }\n  return false;\n}\nvar defaultListItemValue = function defaultListItemValue() {\n  var slate = config.settings.slate;\n  var dv = slate.defaultValue();\n  dv[0].type = LI;\n  return dv;\n};\n\n/**\n * getFragmentFromStartOfSelectionToEndOfEditor.\n *\n * @param {} editor\n */\nexport function getFragmentFromStartOfSelectionToEndOfEditor(editor, initialSelection) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n  var slate = config.settings.slate;\n  var range = Editor.range(editor, Range.isBackward(initialSelection) ? initialSelection.focus : initialSelection.anchor, Editor.end(editor, []));\n\n  // this is the case when the fragment is empty, and we must return\n  // empty fragment but without formatting\n  if (Range.isCollapsed(range)) {\n    if (isCursorInList(editor)) {\n      return defaultListItemValue();\n    } else {\n      return slate.defaultValue();\n    }\n  }\n\n  // immer doesn't like editor.savedSelection\n  var newEditor = {\n    children: editor.children\n  };\n  return Editor.fragment(newEditor, range);\n}\n\n/**\n * getFragmentFromBeginningOfEditorToStartOfSelection.\n *\n * @param {} editor\n */\nexport function getFragmentFromBeginningOfEditorToStartOfSelection(editor, initialSelection) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  // immer doesn't like editor.savedSelection\n  // TODO: there's a bug here related to splitting lists\n  var newEditor = {\n    children: editor.children\n  };\n  return Editor.fragment(newEditor, Editor.range(newEditor, [], Range.isBackward(initialSelection) ? initialSelection.focus : initialSelection.anchor));\n}\n\n/**\n * @returns {boolean} true if editor contains a range selection (active\n * selection or at least a saved selection)\n * @param {Editor} editor\n */\nexport function hasRangeSelection(editor) {\n  var useSavedSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var selection = editor.selection;\n  var savedSelection = editor.getSavedSelection();\n  var range = ReactEditor.isFocused(editor) ? selection || (useSavedSelection ? savedSelection : null) : savedSelection;\n  if (!range) {\n    // console.log('no range', editor);\n    return;\n  }\n  var res = Range.isExpanded(range);\n  // console.log('call hasRange', res);\n  return res;\n}\nexport function parseDefaultSelection(editor, defaultSelection) {\n  if (defaultSelection) {\n    if (defaultSelection === 'start') {\n      var _Node$first = Node.first(editor, []),\n        _Node$first2 = _slicedToArray(_Node$first, 2),\n        path = _Node$first2[1];\n      var newSel = {\n        anchor: {\n          path: path,\n          offset: 0\n        },\n        focus: {\n          path: path,\n          offset: 0\n        }\n      };\n      return newSel;\n    }\n    if (defaultSelection === 'end') {\n      var _Node$last3 = Node.last(editor, []),\n        _Node$last4 = _slicedToArray(_Node$last3, 2),\n        leaf = _Node$last4[0],\n        _path = _Node$last4[1];\n      var _newSel = {\n        anchor: {\n          path: _path,\n          offset: (leaf.text || '').length\n        },\n        focus: {\n          path: _path,\n          offset: (leaf.text || '').length\n        }\n      };\n      return _newSel;\n    }\n    return defaultSelection;\n  }\n}","map":{"version":3,"names":["Editor","Transforms","Range","Node","ReactEditor","isCursorInList","LI","config","getSelectionNodesByType","editor","types","options","nodes","match","n","includes","type","isNodeInSelection","getSelectionNodesArrayByType","Array","from","getMaxRange","maxRange","anchor","start","focus","end","selectAll","select","isCursorAtBlockStart","selection","isCollapsed","offset","path","reduce","acc","x","isCursorAtBlockEnd","last","node","get","text","length","defaultListItemValue","slate","settings","dv","defaultValue","getFragmentFromStartOfSelectionToEndOfEditor","initialSelection","range","isBackward","newEditor","children","fragment","getFragmentFromBeginningOfEditorToStartOfSelection","hasRangeSelection","useSavedSelection","savedSelection","getSavedSelection","isFocused","res","isExpanded","parseDefaultSelection","defaultSelection","first","newSel","leaf"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-slate/src/utils/selection.js"],"sourcesContent":["import { castArray } from 'lodash';\nimport { Editor, Transforms, Range, Node } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { isCursorInList } from 'volto-slate/utils';\nimport { LI } from 'volto-slate/constants';\nimport config from '@plone/volto/registry';\n\n/**\n * Get the nodes with a type included in `types` in the selection (from root to leaf).\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesByType(editor, types, options = {}) {\n  types = castArray(types);\n\n  return Editor.nodes(editor, {\n    match: (n) => {\n      return types.includes(n.type);\n    },\n    ...options,\n  });\n}\n\n/**\n * Is there a node with a type included in `types` in the selection (from root to leaf).\n */\nexport function isNodeInSelection(editor, types, options = {}) {\n  const [match] = getSelectionNodesByType(editor, types, options);\n  return !!match;\n}\n\n/**\n * getSelectionNodesArrayByType.\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesArrayByType(editor, types, options = {}) {\n  return Array.from(getSelectionNodesByType(editor, types, options));\n}\n\n/**\n * getMaxRange.\n *\n * @param {} editor\n *\n * TODO: is [0] ok as a path?\n */\nexport function getMaxRange(editor) {\n  const maxRange = {\n    anchor: Editor.start(editor, [0]),\n    focus: Editor.end(editor, [0]),\n  };\n  return maxRange;\n}\n\n/**\n * selectAll.\n *\n * @param {} editor\n */\nexport function selectAll(editor) {\n  Transforms.select(editor, getMaxRange(editor));\n}\n\n// In the isCursorAtBlockStart/End functions maybe use a part of these pieces of code:\n// Range.isCollapsed(editor.selection) &&\n// Point.equals(editor.selection.anchor, Editor.start(editor, []))\n\n/**\n * isCursorAtBlockStart.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockStart(editor) {\n  // It does not work properly with lists\n\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const { anchor } = editor.selection;\n    return anchor.offset > 0\n      ? false\n      : anchor.path.reduce((acc, x) => acc + x, 0) === 0;\n    // anchor.path.length === 2 &&\n  }\n  return false;\n}\n\n/**\n * isCursorAtBlockEnd.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockEnd(editor) {\n  // fixSelection(editor);\n\n  // if the selection is collapsed\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const anchor = editor.selection?.anchor || {};\n\n    // the last block node in the editor\n    const [node] = Node.last(editor, []);\n\n    if (\n      // if the node with the selection is the last block node\n      Node.get(editor, anchor.path) === node &&\n      // if the collapsed selection is at the end of the last block node\n      anchor.offset === node.text.length\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconst defaultListItemValue = () => {\n  const { slate } = config.settings;\n  const dv = slate.defaultValue();\n  dv[0].type = LI;\n  return dv;\n};\n\n/**\n * getFragmentFromStartOfSelectionToEndOfEditor.\n *\n * @param {} editor\n */\nexport function getFragmentFromStartOfSelectionToEndOfEditor(\n  editor,\n  initialSelection,\n) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  const { slate } = config.settings;\n  const range = Editor.range(\n    editor,\n    Range.isBackward(initialSelection)\n      ? initialSelection.focus\n      : initialSelection.anchor,\n    Editor.end(editor, []),\n  );\n\n  // this is the case when the fragment is empty, and we must return\n  // empty fragment but without formatting\n  if (Range.isCollapsed(range)) {\n    if (isCursorInList(editor)) {\n      return defaultListItemValue();\n    } else {\n      return slate.defaultValue();\n    }\n  }\n\n  // immer doesn't like editor.savedSelection\n  const newEditor = { children: editor.children };\n  return Editor.fragment(newEditor, range);\n}\n\n/**\n * getFragmentFromBeginningOfEditorToStartOfSelection.\n *\n * @param {} editor\n */\nexport function getFragmentFromBeginningOfEditorToStartOfSelection(\n  editor,\n  initialSelection,\n) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  // immer doesn't like editor.savedSelection\n  // TODO: there's a bug here related to splitting lists\n  const newEditor = { children: editor.children };\n  return Editor.fragment(\n    newEditor,\n    Editor.range(\n      newEditor,\n      [],\n      Range.isBackward(initialSelection)\n        ? initialSelection.focus\n        : initialSelection.anchor,\n    ),\n  );\n}\n\n/**\n * @returns {boolean} true if editor contains a range selection (active\n * selection or at least a saved selection)\n * @param {Editor} editor\n */\nexport function hasRangeSelection(editor, useSavedSelection = true) {\n  const { selection } = editor;\n  const savedSelection = editor.getSavedSelection();\n\n  const range = ReactEditor.isFocused(editor)\n    ? selection || (useSavedSelection ? savedSelection : null)\n    : savedSelection;\n\n  if (!range) {\n    // console.log('no range', editor);\n    return;\n  }\n\n  const res = Range.isExpanded(range);\n  // console.log('call hasRange', res);\n  return res;\n}\n\nexport function parseDefaultSelection(editor, defaultSelection) {\n  if (defaultSelection) {\n    if (defaultSelection === 'start') {\n      const [, path] = Node.first(editor, []);\n      const newSel = {\n        anchor: { path, offset: 0 },\n        focus: { path, offset: 0 },\n      };\n      return newSel;\n    }\n    if (defaultSelection === 'end') {\n      const [leaf, path] = Node.last(editor, []);\n      const newSel = {\n        anchor: { path, offset: (leaf.text || '').length },\n        focus: { path, offset: (leaf.text || '').length },\n      };\n      return newSel;\n    }\n    return defaultSelection;\n  }\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}