{"ast":null,"code":"import _extends from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/extends.js\";\nimport _classCallCheck from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _isEqual from \"lodash/isEqual\";\nvar _jsxFileName = \"/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/packages/volto-slate/src/editor/SlateEditor.jsx\",\n  _window;\nvar __jsx = React.createElement;\nimport ReactDOM from 'react-dom';\nimport cx from 'classnames';\nimport { Transforms, Editor } from 'slate'; // , Transforms\nimport { Slate, Editable, ReactEditor } from 'slate-react';\nimport React, { Component } from 'react'; // , useState\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { Element, Leaf } from './render';\nimport withTestingFeatures from './extensions/withTestingFeatures';\nimport { makeEditor, toggleInlineFormat, toggleMark, parseDefaultSelection } from '@plone/volto-slate/utils';\nimport { InlineToolbar } from './ui';\nimport EditorContext from './EditorContext';\nimport isHotkey from 'is-hotkey';\nimport './less/editor.less';\nimport Toolbar from './ui/Toolbar';\nvar handleHotKeys = function handleHotKeys(editor, event, config) {\n  var wasHotkey = false;\n  for (var _i = 0, _Object$entries = Object.entries(config.hotkeys); _i < _Object$entries.length; _i++) {\n    var hk = _Object$entries[_i];\n    var _hk = _slicedToArray(hk, 2),\n      shortcut = _hk[0],\n      _hk$ = _hk[1],\n      format = _hk$.format,\n      type = _hk$.type;\n    if (isHotkey(shortcut, event)) {\n      event.preventDefault();\n      if (type === 'inline') {\n        toggleInlineFormat(editor, format);\n      } else {\n        // type === 'mark'\n        toggleMark(editor, format);\n      }\n      wasHotkey = true;\n    }\n  }\n  return wasHotkey;\n};\n\n// TODO: implement onFocus\nvar SlateEditor = /*#__PURE__*/function (_Component) {\n  _inherits(SlateEditor, _Component);\n  var _super = _createSuper(SlateEditor);\n  function SlateEditor(props) {\n    var _this;\n    _classCallCheck(this, SlateEditor);\n    _this = _super.call(this, props);\n    _this.createEditor = _this.createEditor.bind(_assertThisInitialized(_this));\n    _this.multiDecorator = _this.multiDecorator.bind(_assertThisInitialized(_this));\n    _this.handleChange = _this.handleChange.bind(_assertThisInitialized(_this));\n    _this.getSavedSelection = _this.getSavedSelection.bind(_assertThisInitialized(_this));\n    _this.setSavedSelection = _this.setSavedSelection.bind(_assertThisInitialized(_this));\n    _this.savedSelection = null;\n    var uid = uuid(); // used to namespace the editor's plugins\n\n    _this.slateSettings = props.slateSettings || config.settings.slate;\n    _this.state = {\n      editor: _this.createEditor(uid),\n      showExpandedToolbar: config.settings.slate.showExpandedToolbar,\n      internalValue: _this.props.value || _this.slateSettings.defaultValue(),\n      uid: uid\n    };\n    _this.editor = null;\n    _this.selectionTimeout = null;\n    return _this;\n  }\n  _createClass(SlateEditor, [{\n    key: \"getSavedSelection\",\n    value: function getSavedSelection() {\n      return this.savedSelection;\n    }\n  }, {\n    key: \"setSavedSelection\",\n    value: function setSavedSelection(selection) {\n      this.savedSelection = selection;\n    }\n  }, {\n    key: \"createEditor\",\n    value: function createEditor(uid) {\n      // extensions are \"editor plugins\" or \"editor wrappers\". It's a similar\n      // similar to OOP inheritance, where a callable creates a new copy of the\n      // editor, while replacing or adding new capabilities to that editor.\n      // Extensions are purely JS, no React components.\n      var editor = makeEditor({\n        extensions: this.props.extensions\n      });\n\n      // When the editor loses focus it no longer has a valid selections. This\n      // makes it impossible to have complex types of interactions (like filling\n      // in another text box, operating a select menu, etc). For this reason we\n      // save the active selection\n\n      editor.getSavedSelection = this.getSavedSelection;\n      editor.setSavedSelection = this.setSavedSelection;\n      editor.uid = uid || this.state.uid;\n      return editor;\n    }\n  }, {\n    key: \"handleChange\",\n    value: function handleChange(value) {\n      var _this2 = this;\n      ReactDOM.unstable_batchedUpdates(function () {\n        _this2.setState({\n          internalValue: value\n        });\n        if (_this2.props.onChange && !_isEqual(value, _this2.props.value)) {\n          _this2.props.onChange(value, _this2.editor);\n        }\n      });\n    }\n  }, {\n    key: \"multiDecorator\",\n    value: function multiDecorator(_ref) {\n      var _this3 = this;\n      var _ref2 = _slicedToArray(_ref, 2),\n        node = _ref2[0],\n        path = _ref2[1];\n      // Decorations (such as higlighting node types, selection, etc).\n      var _this$slateSettings$r = this.slateSettings.runtimeDecorators,\n        runtimeDecorators = _this$slateSettings$r === void 0 ? [] : _this$slateSettings$r;\n      return runtimeDecorators.reduce(function (acc, deco) {\n        return deco(_this3.state.editor, [node, path], acc);\n      }, []);\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this4 = this;\n      // watch the dom change\n\n      if (this.props.selected) {\n        var focused = true;\n        try {\n          focused = ReactEditor.isFocused(this.state.editor);\n        } catch (_unused) {}\n        if (!focused) {\n          setTimeout(function () {\n            try {\n              ReactEditor.focus(_this4.state.editor);\n            } catch (_unused2) {}\n          }, 100); // flush\n        }\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.isUnmounted = true;\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (!_isEqual(prevProps.extensions, this.props.extensions)) {\n        this.setState({\n          editor: this.createEditor()\n        });\n        return;\n      }\n      if (this.props.value && !_isEqual(this.props.value, this.state.internalValue)) {\n        var _editor = this.state.editor;\n        _editor.children = this.props.value;\n        if (this.props.defaultSelection) {\n          var selection = parseDefaultSelection(_editor, this.props.defaultSelection);\n          ReactEditor.focus(_editor);\n          Transforms.select(_editor, selection);\n        } else {\n          Transforms.select(_editor, Editor.end(_editor, []));\n        }\n        this.setState({\n          // editor,\n          internalValue: this.props.value\n        });\n        return;\n      }\n      var editor = this.state.editor;\n      if (!prevProps.selected && this.props.selected) {\n        // if the SlateEditor becomes selected from unselected\n\n        if (window.getSelection().type === 'None') {\n          // TODO: why is this condition checked?\n          Transforms.select(this.state.editor, Editor.range(this.state.editor, Editor.start(this.state.editor, [])));\n        }\n        ReactEditor.focus(this.state.editor);\n      }\n      if (this.props.selected && this.props.onUpdate) {\n        this.props.onUpdate(editor);\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate(nextProps, nextState) {\n      var _nextProps$selected = nextProps.selected,\n        selected = _nextProps$selected === void 0 ? true : _nextProps$selected,\n        value = nextProps.value,\n        readOnly = nextProps.readOnly;\n      var res = selected || this.props.selected !== selected || this.props.readOnly !== readOnly || !_isEqual(value, this.props.value);\n      return res;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props$value,\n        _this5 = this;\n      var _this$props = this.props,\n        selected = _this$props.selected,\n        placeholder = _this$props.placeholder,\n        _onKeyDown = _this$props.onKeyDown,\n        testingEditorRef = _this$props.testingEditorRef,\n        readOnly = _this$props.readOnly,\n        className = _this$props.className,\n        _this$props$renderExt = _this$props.renderExtensions,\n        renderExtensions = _this$props$renderExt === void 0 ? [] : _this$props$renderExt;\n      var slateSettings = this.slateSettings;\n\n      // renderExtensions is needed because the editor is memoized, so if these\n      // extensions need an updated state (for example to insert updated\n      // blockProps) then we need to always wrap the editor with them\n      var editor = renderExtensions.reduce(function (acc, apply) {\n        return apply(acc);\n      }, this.state.editor);\n\n      // Reset selection if field is reset\n      if (editor.selection && ((_this$props$value = this.props.value) === null || _this$props$value === void 0 ? void 0 : _this$props$value.length) === 1 && this.props.value[0].children.length === 1 && this.props.value[0].children[0].text === '') {\n        Transforms.select(editor, {\n          anchor: {\n            path: [0, 0],\n            offset: 0\n          },\n          focus: {\n            path: [0, 0],\n            offset: 0\n          }\n        });\n      }\n      this.editor = editor;\n      if (testingEditorRef) {\n        testingEditorRef.current = editor;\n      }\n\n      // debug-values are `data-` HTML attributes in withTestingFeatures HOC\n\n      return __jsx(\"div\", _extends({}, this.props['debug-values'], {\n        className: cx('slate-editor', {\n          'show-toolbar': this.state.showExpandedToolbar,\n          selected: selected\n        }),\n        tabIndex: -1,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 250,\n          columnNumber: 7\n        }\n      }), __jsx(EditorContext.Provider, {\n        value: editor,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 258,\n          columnNumber: 9\n        }\n      }, __jsx(Slate, {\n        editor: editor,\n        value: this.props.value || slateSettings.defaultValue(),\n        onChange: this.handleChange,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 259,\n          columnNumber: 11\n        }\n      }, selected ? __jsx(React.Fragment, null, __jsx(InlineToolbar, {\n        editor: editor,\n        className: className,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 266,\n          columnNumber: 17\n        }\n      }), Object.keys(slateSettings.elementToolbarButtons).map(function (t, i) {\n        return __jsx(Toolbar, {\n          elementType: t,\n          key: i,\n          __self: _this5,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 270,\n            columnNumber: 23\n          }\n        }, slateSettings.elementToolbarButtons[t].map(function (Btn, b) {\n          return __jsx(Btn, {\n            editor: editor,\n            key: b,\n            __self: _this5,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 273,\n              columnNumber: 36\n            }\n          });\n        }));\n      })) : '', __jsx(Editable, {\n        tabIndex: this.props.tabIndex || 0,\n        readOnly: readOnly,\n        placeholder: placeholder,\n        renderElement: function renderElement(props) {\n          return __jsx(Element, _extends({}, props, {\n            __self: _this5,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 288,\n              columnNumber: 41\n            }\n          }));\n        },\n        renderLeaf: function renderLeaf(props) {\n          return __jsx(Leaf, _extends({}, props, {\n            __self: _this5,\n            __source: {\n              fileName: _jsxFileName,\n              lineNumber: 289,\n              columnNumber: 38\n            }\n          }));\n        },\n        decorate: this.multiDecorator,\n        spellCheck: false,\n        scrollSelectionIntoView: slateSettings.scrollIntoView ? undefined : function () {\n          return null;\n        },\n        onBlur: function onBlur() {\n          _this5.props.onBlur && _this5.props.onBlur();\n          return null;\n        },\n        onClick: this.props.onClick,\n        onSelect: function onSelect(e) {\n          if (!selected && _this5.props.onFocus) {\n            // we can't overwrite the onFocus of Editable, as the onFocus\n            // in Slate has too much builtin behaviour that's not\n            // accessible otherwise. Instead we try to detect such an\n            // event based on observing selected state\n            if (!editor.selection) {\n              setTimeout(function () {\n                _this5.props.onFocus();\n              }, 100); // TODO: why 100 is chosen here?\n            }\n          }\n\n          if (_this5.selectionTimeout) clearTimeout(_this5.selectionTimeout);\n          _this5.selectionTimeout = setTimeout(function () {\n            if (editor.selection && !_isEqual(editor.selection, _this5.savedSelection) && !_this5.isUnmounted) {\n              _this5.setState(function (state) {\n                return {\n                  update: !_this5.state.update\n                };\n              });\n              _this5.setSavedSelection(JSON.parse(JSON.stringify(editor.selection)));\n            }\n          }, 200);\n        },\n        onKeyDown: function onKeyDown(event) {\n          var handled = handleHotKeys(editor, event, slateSettings);\n          if (handled) return;\n          _onKeyDown && _onKeyDown({\n            editor: editor,\n            event: event\n          });\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 284,\n          columnNumber: 13\n        }\n      }), selected && slateSettings.persistentHelpers.map(function (Helper, i) {\n        return __jsx(Helper, {\n          key: i,\n          editor: editor,\n          __self: _this5,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 335,\n            columnNumber: 24\n          }\n        });\n      }), this.props.debug ? __jsx(\"ul\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 338,\n          columnNumber: 15\n        }\n      }, __jsx(\"li\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 339,\n          columnNumber: 17\n        }\n      }, selected ? 'selected' : 'no-selected'), __jsx(\"li\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 340,\n          columnNumber: 17\n        }\n      }, \"savedSelection: \", JSON.stringify(editor.getSavedSelection())), __jsx(\"li\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 343,\n          columnNumber: 17\n        }\n      }, \"live selection: \", JSON.stringify(editor.selection)), __jsx(\"li\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 344,\n          columnNumber: 17\n        }\n      }, \"children: \", JSON.stringify(editor.children)), __jsx(\"li\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 345,\n          columnNumber: 17\n        }\n      }, \" \", selected ? 'selected' : 'notselected'), __jsx(\"li\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 346,\n          columnNumber: 17\n        }\n      }, ReactEditor.isFocused(editor) ? 'focused' : 'unfocused')) : '', this.props.children)));\n    }\n  }]);\n  return SlateEditor;\n}(Component);\nSlateEditor.defaultProps = {\n  extensions: [],\n  className: ''\n};\nexport default connect(function (state, props) {\n  return {};\n})(__CLIENT__ && (_window = window) !== null && _window !== void 0 && _window.Cypress ? withTestingFeatures(SlateEditor) : SlateEditor);","map":{"version":3,"names":["ReactDOM","cx","Transforms","Editor","Slate","Editable","ReactEditor","React","Component","connect","v4","uuid","config","Element","Leaf","withTestingFeatures","makeEditor","toggleInlineFormat","toggleMark","parseDefaultSelection","InlineToolbar","EditorContext","isHotkey","Toolbar","handleHotKeys","editor","event","wasHotkey","Object","entries","hotkeys","hk","shortcut","format","type","preventDefault","SlateEditor","props","createEditor","bind","multiDecorator","handleChange","getSavedSelection","setSavedSelection","savedSelection","uid","slateSettings","settings","slate","state","showExpandedToolbar","internalValue","value","defaultValue","selectionTimeout","selection","extensions","unstable_batchedUpdates","setState","onChange","node","path","runtimeDecorators","reduce","acc","deco","selected","focused","isFocused","setTimeout","focus","isUnmounted","prevProps","children","defaultSelection","select","end","window","getSelection","range","start","onUpdate","nextProps","nextState","readOnly","res","placeholder","onKeyDown","testingEditorRef","className","renderExtensions","apply","length","text","anchor","offset","current","keys","elementToolbarButtons","map","t","i","Btn","b","tabIndex","scrollIntoView","undefined","onBlur","onClick","e","onFocus","clearTimeout","update","JSON","parse","stringify","handled","persistentHelpers","Helper","debug","defaultProps","__CLIENT__","Cypress"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/packages/volto-slate/src/editor/SlateEditor.jsx"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport cx from 'classnames';\nimport { isEqual } from 'lodash';\nimport { Transforms, Editor } from 'slate'; // , Transforms\nimport { Slate, Editable, ReactEditor } from 'slate-react';\nimport React, { Component } from 'react'; // , useState\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\n\nimport config from '@plone/volto/registry';\n\nimport { Element, Leaf } from './render';\n\nimport withTestingFeatures from './extensions/withTestingFeatures';\nimport {\n  makeEditor,\n  toggleInlineFormat,\n  toggleMark,\n  parseDefaultSelection,\n} from '@plone/volto-slate/utils';\nimport { InlineToolbar } from './ui';\nimport EditorContext from './EditorContext';\n\nimport isHotkey from 'is-hotkey';\n\nimport './less/editor.less';\n\nimport Toolbar from './ui/Toolbar';\n\nconst handleHotKeys = (editor, event, config) => {\n  let wasHotkey = false;\n\n  for (const hk of Object.entries(config.hotkeys)) {\n    const [shortcut, { format, type }] = hk;\n    if (isHotkey(shortcut, event)) {\n      event.preventDefault();\n\n      if (type === 'inline') {\n        toggleInlineFormat(editor, format);\n      } else {\n        // type === 'mark'\n        toggleMark(editor, format);\n      }\n\n      wasHotkey = true;\n    }\n  }\n\n  return wasHotkey;\n};\n\n// TODO: implement onFocus\nclass SlateEditor extends Component {\n  constructor(props) {\n    super(props);\n\n    this.createEditor = this.createEditor.bind(this);\n    this.multiDecorator = this.multiDecorator.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.getSavedSelection = this.getSavedSelection.bind(this);\n    this.setSavedSelection = this.setSavedSelection.bind(this);\n\n    this.savedSelection = null;\n\n    const uid = uuid(); // used to namespace the editor's plugins\n\n    this.slateSettings = props.slateSettings || config.settings.slate;\n\n    this.state = {\n      editor: this.createEditor(uid),\n      showExpandedToolbar: config.settings.slate.showExpandedToolbar,\n      internalValue: this.props.value || this.slateSettings.defaultValue(),\n      uid,\n    };\n\n    this.editor = null;\n    this.selectionTimeout = null;\n  }\n\n  getSavedSelection() {\n    return this.savedSelection;\n  }\n  setSavedSelection(selection) {\n    this.savedSelection = selection;\n  }\n\n  createEditor(uid) {\n    // extensions are \"editor plugins\" or \"editor wrappers\". It's a similar\n    // similar to OOP inheritance, where a callable creates a new copy of the\n    // editor, while replacing or adding new capabilities to that editor.\n    // Extensions are purely JS, no React components.\n    const editor = makeEditor({ extensions: this.props.extensions });\n\n    // When the editor loses focus it no longer has a valid selections. This\n    // makes it impossible to have complex types of interactions (like filling\n    // in another text box, operating a select menu, etc). For this reason we\n    // save the active selection\n\n    editor.getSavedSelection = this.getSavedSelection;\n    editor.setSavedSelection = this.setSavedSelection;\n    editor.uid = uid || this.state.uid;\n\n    return editor;\n  }\n\n  handleChange(value) {\n    ReactDOM.unstable_batchedUpdates(() => {\n      this.setState({ internalValue: value });\n      if (this.props.onChange && !isEqual(value, this.props.value)) {\n        this.props.onChange(value, this.editor);\n      }\n    });\n  }\n\n  multiDecorator([node, path]) {\n    // Decorations (such as higlighting node types, selection, etc).\n    const { runtimeDecorators = [] } = this.slateSettings;\n    return runtimeDecorators.reduce(\n      (acc, deco) => deco(this.state.editor, [node, path], acc),\n      [],\n    );\n  }\n\n  componentDidMount() {\n    // watch the dom change\n\n    if (this.props.selected) {\n      let focused = true;\n      try {\n        focused = ReactEditor.isFocused(this.state.editor);\n      } catch {}\n      if (!focused) {\n        setTimeout(() => {\n          try {\n            ReactEditor.focus(this.state.editor);\n          } catch {}\n        }, 100); // flush\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.isUnmounted = true;\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!isEqual(prevProps.extensions, this.props.extensions)) {\n      this.setState({ editor: this.createEditor() });\n      return;\n    }\n\n    if (\n      this.props.value &&\n      !isEqual(this.props.value, this.state.internalValue)\n    ) {\n      const { editor } = this.state;\n      editor.children = this.props.value;\n\n      if (this.props.defaultSelection) {\n        const selection = parseDefaultSelection(\n          editor,\n          this.props.defaultSelection,\n        );\n\n        ReactEditor.focus(editor);\n        Transforms.select(editor, selection);\n      } else {\n        Transforms.select(editor, Editor.end(editor, []));\n      }\n\n      this.setState({\n        // editor,\n        internalValue: this.props.value,\n      });\n      return;\n    }\n\n    const { editor } = this.state;\n\n    if (!prevProps.selected && this.props.selected) {\n      // if the SlateEditor becomes selected from unselected\n\n      if (window.getSelection().type === 'None') {\n        // TODO: why is this condition checked?\n        Transforms.select(\n          this.state.editor,\n          Editor.range(this.state.editor, Editor.start(this.state.editor, [])),\n        );\n      }\n\n      ReactEditor.focus(this.state.editor);\n    }\n\n    if (this.props.selected && this.props.onUpdate) {\n      this.props.onUpdate(editor);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const { selected = true, value, readOnly } = nextProps;\n    const res =\n      selected ||\n      this.props.selected !== selected ||\n      this.props.readOnly !== readOnly ||\n      !isEqual(value, this.props.value);\n    return res;\n  }\n\n  render() {\n    const {\n      selected,\n      placeholder,\n      onKeyDown,\n      testingEditorRef,\n      readOnly,\n      className,\n      renderExtensions = [],\n    } = this.props;\n    const slateSettings = this.slateSettings;\n\n    // renderExtensions is needed because the editor is memoized, so if these\n    // extensions need an updated state (for example to insert updated\n    // blockProps) then we need to always wrap the editor with them\n    const editor = renderExtensions.reduce(\n      (acc, apply) => apply(acc),\n      this.state.editor,\n    );\n\n    // Reset selection if field is reset\n    if (\n      editor.selection &&\n      this.props.value?.length === 1 &&\n      this.props.value[0].children.length === 1 &&\n      this.props.value[0].children[0].text === ''\n    ) {\n      Transforms.select(editor, {\n        anchor: { path: [0, 0], offset: 0 },\n        focus: { path: [0, 0], offset: 0 },\n      });\n    }\n    this.editor = editor;\n\n    if (testingEditorRef) {\n      testingEditorRef.current = editor;\n    }\n\n    // debug-values are `data-` HTML attributes in withTestingFeatures HOC\n\n    return (\n      <div\n        {...this.props['debug-values']}\n        className={cx('slate-editor', {\n          'show-toolbar': this.state.showExpandedToolbar,\n          selected,\n        })}\n        tabIndex={-1}\n      >\n        <EditorContext.Provider value={editor}>\n          <Slate\n            editor={editor}\n            value={this.props.value || slateSettings.defaultValue()}\n            onChange={this.handleChange}\n          >\n            {selected ? (\n              <>\n                <InlineToolbar editor={editor} className={className} />\n                {Object.keys(slateSettings.elementToolbarButtons).map(\n                  (t, i) => {\n                    return (\n                      <Toolbar elementType={t} key={i}>\n                        {slateSettings.elementToolbarButtons[t].map(\n                          (Btn, b) => {\n                            return <Btn editor={editor} key={b} />;\n                          },\n                        )}\n                      </Toolbar>\n                    );\n                  },\n                )}\n              </>\n            ) : (\n              ''\n            )}\n            <Editable\n              tabIndex={this.props.tabIndex || 0}\n              readOnly={readOnly}\n              placeholder={placeholder}\n              renderElement={(props) => <Element {...props} />}\n              renderLeaf={(props) => <Leaf {...props} />}\n              decorate={this.multiDecorator}\n              spellCheck={false}\n              scrollSelectionIntoView={\n                slateSettings.scrollIntoView ? undefined : () => null\n              }\n              onBlur={() => {\n                this.props.onBlur && this.props.onBlur();\n                return null;\n              }}\n              onClick={this.props.onClick}\n              onSelect={(e) => {\n                if (!selected && this.props.onFocus) {\n                  // we can't overwrite the onFocus of Editable, as the onFocus\n                  // in Slate has too much builtin behaviour that's not\n                  // accessible otherwise. Instead we try to detect such an\n                  // event based on observing selected state\n                  if (!editor.selection) {\n                    setTimeout(() => {\n                      this.props.onFocus();\n                    }, 100); // TODO: why 100 is chosen here?\n                  }\n                }\n\n                if (this.selectionTimeout) clearTimeout(this.selectionTimeout);\n                this.selectionTimeout = setTimeout(() => {\n                  if (\n                    editor.selection &&\n                    !isEqual(editor.selection, this.savedSelection) &&\n                    !this.isUnmounted\n                  ) {\n                    this.setState((state) => ({ update: !this.state.update }));\n                    this.setSavedSelection(\n                      JSON.parse(JSON.stringify(editor.selection)),\n                    );\n                  }\n                }, 200);\n              }}\n              onKeyDown={(event) => {\n                const handled = handleHotKeys(editor, event, slateSettings);\n                if (handled) return;\n                onKeyDown && onKeyDown({ editor, event });\n              }}\n            />\n            {selected &&\n              slateSettings.persistentHelpers.map((Helper, i) => {\n                return <Helper key={i} editor={editor} />;\n              })}\n            {this.props.debug ? (\n              <ul>\n                <li>{selected ? 'selected' : 'no-selected'}</li>\n                <li>\n                  savedSelection: {JSON.stringify(editor.getSavedSelection())}\n                </li>\n                <li>live selection: {JSON.stringify(editor.selection)}</li>\n                <li>children: {JSON.stringify(editor.children)}</li>\n                <li> {selected ? 'selected' : 'notselected'}</li>\n                <li>\n                  {ReactEditor.isFocused(editor) ? 'focused' : 'unfocused'}\n                </li>\n              </ul>\n            ) : (\n              ''\n            )}\n            {this.props.children}\n          </Slate>\n        </EditorContext.Provider>\n      </div>\n    );\n  }\n}\n\nSlateEditor.defaultProps = {\n  extensions: [],\n  className: '',\n};\n\nexport default connect((state, props) => {\n  return {};\n})(\n  __CLIENT__ && window?.Cypress\n    ? withTestingFeatures(SlateEditor)\n    : SlateEditor,\n);\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}