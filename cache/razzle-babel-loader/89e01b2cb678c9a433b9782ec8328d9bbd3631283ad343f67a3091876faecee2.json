{"ast":null,"code":"import { Editor, Range, Transforms, Path } from 'slate';\nimport config from '@plone/volto/registry';\nexport function isCursorInList(editor) {\n  const {\n    slate\n  } = config.settings;\n  const result = Editor.above(editor, {\n    match: n => n.type === slate.listItemType\n  });\n  if (!result) {\n    return false;\n  }\n  const [listItemWithSelection] = result;\n\n  // whether the selection is inside a list item\n  const listItemCase = Range.isCollapsed(editor.selection) && listItemWithSelection;\n  return listItemCase;\n}\nexport function isCursorAtListBlockStart(editor) {\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const {\n      anchor\n    } = editor.selection;\n    return anchor.offset > 0 ? false : anchor.path.length === 3 && anchor.path.reduce((acc, x) => acc + x, 0) === 0;\n  }\n}\nconst getPreviousSiblingPath = function (path) {\n  // Doesn't raise an error if no previous sibling exists\n  const last = path[path.length - 1];\n  if (last <= 0) {\n    return null;\n  }\n  return path.slice(0, -1).concat(last - 1);\n};\nexport function mergeWithPreviousList(editor, listPath) {\n  const {\n    slate\n  } = config.settings;\n  const prevSiblingPath = getPreviousSiblingPath(listPath);\n  const [currentList] = Editor.node(editor, listPath);\n  if (prevSiblingPath) {\n    const [prevSibling] = Editor.node(editor, prevSiblingPath);\n    if (slate.listTypes.includes(prevSibling.type)) {\n      Transforms.mergeNodes(editor, {\n        // match: (node) => slate.listTypes.includes(node.type),\n        match: node => node === prevSibling || node === currentList,\n        mode: 'highest',\n        at: listPath\n      });\n    }\n  }\n}\nexport function mergeWithNextList(editor, listPath) {\n  const {\n    slate\n  } = config.settings;\n  const [currentList] = Editor.node(editor, listPath);\n  const [parent] = Editor.parent(editor, listPath);\n  if (parent.children.length - 1 > listPath[listPath.length - 1]) {\n    const nextSiblingPath = Path.next(listPath);\n    const [nextSibling] = Editor.node(editor, nextSiblingPath);\n    if (slate.listTypes.includes(nextSibling.type)) {\n      Transforms.mergeNodes(editor, {\n        match: node => {\n          return node === currentList || node === nextSibling;\n        },\n        at: nextSiblingPath,\n        mode: 'highest'\n      });\n    }\n  }\n}\nexport function getCurrentListItem(editor) {\n  const {\n    slate\n  } = config.settings;\n  const [match] = Editor.nodes(editor, {\n    at: editor.selection.anchor.path,\n    match: n => n.type === slate.listItemType,\n    mode: 'lowest'\n  });\n  return match || []; // empty entry if nothing is found\n}","map":{"version":3,"names":["Editor","Range","Transforms","Path","config","isCursorInList","editor","slate","settings","result","above","match","n","type","listItemType","listItemWithSelection","listItemCase","isCollapsed","selection","isCursorAtListBlockStart","anchor","offset","path","length","reduce","acc","x","getPreviousSiblingPath","last","slice","concat","mergeWithPreviousList","listPath","prevSiblingPath","currentList","node","prevSibling","listTypes","includes","mergeNodes","mode","at","mergeWithNextList","parent","children","nextSiblingPath","next","nextSibling","getCurrentListItem","nodes"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-slate/src/utils/lists.js"],"sourcesContent":["import { Editor, Range, Transforms, Path } from 'slate';\nimport config from '@plone/volto/registry';\n\nexport function isCursorInList(editor) {\n  const { slate } = config.settings;\n\n  const result = Editor.above(editor, {\n    match: (n) => n.type === slate.listItemType,\n  });\n\n  if (!result) {\n    return false;\n  }\n\n  const [listItemWithSelection] = result;\n\n  // whether the selection is inside a list item\n  const listItemCase =\n    Range.isCollapsed(editor.selection) && listItemWithSelection;\n\n  return listItemCase;\n}\n\nexport function isCursorAtListBlockStart(editor) {\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const { anchor } = editor.selection;\n    return anchor.offset > 0\n      ? false\n      : anchor.path.length === 3 &&\n          anchor.path.reduce((acc, x) => acc + x, 0) === 0;\n  }\n}\n\nconst getPreviousSiblingPath = function (path) {\n  // Doesn't raise an error if no previous sibling exists\n  const last = path[path.length - 1];\n\n  if (last <= 0) {\n    return null;\n  }\n\n  return path.slice(0, -1).concat(last - 1);\n};\n\nexport function mergeWithPreviousList(editor, listPath) {\n  const { slate } = config.settings;\n  const prevSiblingPath = getPreviousSiblingPath(listPath);\n  const [currentList] = Editor.node(editor, listPath);\n  if (prevSiblingPath) {\n    const [prevSibling] = Editor.node(editor, prevSiblingPath);\n\n    if (slate.listTypes.includes(prevSibling.type)) {\n      Transforms.mergeNodes(editor, {\n        // match: (node) => slate.listTypes.includes(node.type),\n        match: (node) => node === prevSibling || node === currentList,\n        mode: 'highest',\n        at: listPath,\n      });\n    }\n  }\n}\n\nexport function mergeWithNextList(editor, listPath) {\n  const { slate } = config.settings;\n  const [currentList] = Editor.node(editor, listPath);\n  const [parent] = Editor.parent(editor, listPath);\n\n  if (parent.children.length - 1 > listPath[listPath.length - 1]) {\n    const nextSiblingPath = Path.next(listPath);\n    const [nextSibling] = Editor.node(editor, nextSiblingPath);\n\n    if (slate.listTypes.includes(nextSibling.type)) {\n      Transforms.mergeNodes(editor, {\n        match: (node) => {\n          return node === currentList || node === nextSibling;\n        },\n        at: nextSiblingPath,\n        mode: 'highest',\n      });\n    }\n  }\n}\n\nexport function getCurrentListItem(editor) {\n  const { slate } = config.settings;\n  const [match] = Editor.nodes(editor, {\n    at: editor.selection.anchor.path,\n    match: (n) => n.type === slate.listItemType,\n    mode: 'lowest',\n  });\n  return match || []; // empty entry if nothing is found\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}