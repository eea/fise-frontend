{"ast":null,"code":"import _castArray from \"lodash/castArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport { Editor, Transforms, Range, Node } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { isCursorInList } from '@plone/volto-slate/utils';\nimport { LI } from '@plone/volto-slate/constants';\nimport config from '@plone/volto/registry';\n\n/**\n * Get the nodes with a type included in `types` in the selection (from root to leaf).\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesByType(editor, types, options = {}) {\n  types = _castArray(types);\n  return Editor.nodes(editor, _objectSpread({\n    match: n => {\n      return types.includes(n.type);\n    }\n  }, options));\n}\n\n/**\n * Is there a node with a type included in `types` in the selection (from root to leaf).\n */\nexport function isNodeInSelection(editor, types, options = {}) {\n  const [match] = getSelectionNodesByType(editor, types, options);\n  return !!match;\n}\n\n/**\n * getSelectionNodesArrayByType.\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesArrayByType(editor, types, options = {}) {\n  return Array.from(getSelectionNodesByType(editor, types, options));\n}\n\n/**\n * getMaxRange.\n *\n * @param {} editor\n *\n * TODO: is [0] ok as a path?\n */\nexport function getMaxRange(editor) {\n  const maxRange = {\n    anchor: Editor.start(editor, [0]),\n    focus: Editor.end(editor, [0])\n  };\n  return maxRange;\n}\n\n/**\n * selectAll.\n *\n * @param {} editor\n */\nexport function selectAll(editor) {\n  Transforms.select(editor, getMaxRange(editor));\n}\n\n// In the isCursorAtBlockStart/End functions maybe use a part of these pieces of code:\n// Range.isCollapsed(editor.selection) &&\n// Point.equals(editor.selection.anchor, Editor.start(editor, []))\n\n/**\n * isCursorAtBlockStart.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockStart(editor) {\n  // It does not work properly with lists\n\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const {\n      anchor\n    } = editor.selection;\n    return anchor.offset > 0 ? false : anchor.path.reduce((acc, x) => acc + x, 0) === 0;\n    // anchor.path.length === 2 &&\n  }\n\n  return false;\n}\n\n/**\n * isCursorAtBlockEnd.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockEnd(editor) {\n  // fixSelection(editor);\n\n  // if the selection is collapsed\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    var _editor$selection;\n    const anchor = ((_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor) || {};\n\n    // the last block node in the editor\n    const [node] = Node.last(editor, []);\n    if (\n    // if the node with the selection is the last block node\n    Node.get(editor, anchor.path) === node &&\n    // if the collapsed selection is at the end of the last block node\n    anchor.offset === node.text.length) {\n      return true;\n    }\n  }\n  return false;\n}\nconst defaultListItemValue = () => {\n  const {\n    slate\n  } = config.settings;\n  const dv = slate.defaultValue();\n  dv[0].type = LI;\n  return dv;\n};\n\n/**\n * getFragmentFromStartOfSelectionToEndOfEditor.\n *\n * @param {} editor\n */\nexport function getFragmentFromStartOfSelectionToEndOfEditor(editor, initialSelection) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n  const {\n    slate\n  } = config.settings;\n  const range = Editor.range(editor, Range.isBackward(initialSelection) ? initialSelection.focus : initialSelection.anchor, Editor.end(editor, []));\n\n  // this is the case when the fragment is empty, and we must return\n  // empty fragment but without formatting\n  if (Range.isCollapsed(range)) {\n    if (isCursorInList(editor)) {\n      return defaultListItemValue();\n    } else {\n      return slate.defaultValue();\n    }\n  }\n\n  // immer doesn't like editor.savedSelection\n  const newEditor = {\n    children: editor.children\n  };\n  return Editor.fragment(newEditor, range);\n}\n\n/**\n * getFragmentFromBeginningOfEditorToStartOfSelection.\n *\n * @param {} editor\n */\nexport function getFragmentFromBeginningOfEditorToStartOfSelection(editor, initialSelection) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  // immer doesn't like editor.savedSelection\n  // TODO: there's a bug here related to splitting lists\n  const newEditor = {\n    children: editor.children\n  };\n  return Editor.fragment(newEditor, Editor.range(newEditor, [], Range.isBackward(initialSelection) ? initialSelection.focus : initialSelection.anchor));\n}\n\n/**\n * @returns {boolean} true if editor contains a range selection (active\n * selection or at least a saved selection)\n * @param {Editor} editor\n */\nexport function hasRangeSelection(editor, useSavedSelection = true) {\n  const {\n    selection\n  } = editor;\n  const savedSelection = editor.getSavedSelection();\n  const range = ReactEditor.isFocused(editor) ? selection || (useSavedSelection ? savedSelection : null) : savedSelection;\n  if (!range) {\n    // console.log('no range', editor);\n    return;\n  }\n  const res = Range.isExpanded(range);\n  // console.log('call hasRange', res);\n  return res;\n}\nexport function parseDefaultSelection(editor, defaultSelection) {\n  if (defaultSelection) {\n    if (defaultSelection === 'start') {\n      const [, path] = Node.first(editor, []);\n      const newSel = {\n        anchor: {\n          path,\n          offset: 0\n        },\n        focus: {\n          path,\n          offset: 0\n        }\n      };\n      return newSel;\n    }\n    if (defaultSelection === 'end') {\n      const [leaf, path] = Node.last(editor, []);\n      const newSel = {\n        anchor: {\n          path,\n          offset: (leaf.text || '').length\n        },\n        focus: {\n          path,\n          offset: (leaf.text || '').length\n        }\n      };\n      return newSel;\n    }\n    return defaultSelection;\n  }\n}","map":{"version":3,"names":["Editor","Transforms","Range","Node","ReactEditor","isCursorInList","LI","config","getSelectionNodesByType","editor","types","options","nodes","match","n","includes","type","isNodeInSelection","getSelectionNodesArrayByType","Array","from","getMaxRange","maxRange","anchor","start","focus","end","selectAll","select","isCursorAtBlockStart","selection","isCollapsed","offset","path","reduce","acc","x","isCursorAtBlockEnd","node","last","get","text","length","defaultListItemValue","slate","settings","dv","defaultValue","getFragmentFromStartOfSelectionToEndOfEditor","initialSelection","range","isBackward","newEditor","children","fragment","getFragmentFromBeginningOfEditorToStartOfSelection","hasRangeSelection","useSavedSelection","savedSelection","getSavedSelection","isFocused","res","isExpanded","parseDefaultSelection","defaultSelection","first","newSel","leaf"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/packages/volto-slate/src/utils/selection.js"],"sourcesContent":["import { castArray } from 'lodash';\nimport { Editor, Transforms, Range, Node } from 'slate';\nimport { ReactEditor } from 'slate-react';\nimport { isCursorInList } from '@plone/volto-slate/utils';\nimport { LI } from '@plone/volto-slate/constants';\nimport config from '@plone/volto/registry';\n\n/**\n * Get the nodes with a type included in `types` in the selection (from root to leaf).\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesByType(editor, types, options = {}) {\n  types = castArray(types);\n\n  return Editor.nodes(editor, {\n    match: (n) => {\n      return types.includes(n.type);\n    },\n    ...options,\n  });\n}\n\n/**\n * Is there a node with a type included in `types` in the selection (from root to leaf).\n */\nexport function isNodeInSelection(editor, types, options = {}) {\n  const [match] = getSelectionNodesByType(editor, types, options);\n  return !!match;\n}\n\n/**\n * getSelectionNodesArrayByType.\n *\n * @param {} editor\n * @param {} types\n * @param {} options\n */\nexport function getSelectionNodesArrayByType(editor, types, options = {}) {\n  return Array.from(getSelectionNodesByType(editor, types, options));\n}\n\n/**\n * getMaxRange.\n *\n * @param {} editor\n *\n * TODO: is [0] ok as a path?\n */\nexport function getMaxRange(editor) {\n  const maxRange = {\n    anchor: Editor.start(editor, [0]),\n    focus: Editor.end(editor, [0]),\n  };\n  return maxRange;\n}\n\n/**\n * selectAll.\n *\n * @param {} editor\n */\nexport function selectAll(editor) {\n  Transforms.select(editor, getMaxRange(editor));\n}\n\n// In the isCursorAtBlockStart/End functions maybe use a part of these pieces of code:\n// Range.isCollapsed(editor.selection) &&\n// Point.equals(editor.selection.anchor, Editor.start(editor, []))\n\n/**\n * isCursorAtBlockStart.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockStart(editor) {\n  // It does not work properly with lists\n\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const { anchor } = editor.selection;\n    return anchor.offset > 0\n      ? false\n      : anchor.path.reduce((acc, x) => acc + x, 0) === 0;\n    // anchor.path.length === 2 &&\n  }\n  return false;\n}\n\n/**\n * isCursorAtBlockEnd.\n *\n * @param {} editor\n */\nexport function isCursorAtBlockEnd(editor) {\n  // fixSelection(editor);\n\n  // if the selection is collapsed\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const anchor = editor.selection?.anchor || {};\n\n    // the last block node in the editor\n    const [node] = Node.last(editor, []);\n\n    if (\n      // if the node with the selection is the last block node\n      Node.get(editor, anchor.path) === node &&\n      // if the collapsed selection is at the end of the last block node\n      anchor.offset === node.text.length\n    ) {\n      return true;\n    }\n  }\n  return false;\n}\n\nconst defaultListItemValue = () => {\n  const { slate } = config.settings;\n  const dv = slate.defaultValue();\n  dv[0].type = LI;\n  return dv;\n};\n\n/**\n * getFragmentFromStartOfSelectionToEndOfEditor.\n *\n * @param {} editor\n */\nexport function getFragmentFromStartOfSelectionToEndOfEditor(\n  editor,\n  initialSelection,\n) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  const { slate } = config.settings;\n  const range = Editor.range(\n    editor,\n    Range.isBackward(initialSelection)\n      ? initialSelection.focus\n      : initialSelection.anchor,\n    Editor.end(editor, []),\n  );\n\n  // this is the case when the fragment is empty, and we must return\n  // empty fragment but without formatting\n  if (Range.isCollapsed(range)) {\n    if (isCursorInList(editor)) {\n      return defaultListItemValue();\n    } else {\n      return slate.defaultValue();\n    }\n  }\n\n  // immer doesn't like editor.savedSelection\n  const newEditor = { children: editor.children };\n  return Editor.fragment(newEditor, range);\n}\n\n/**\n * getFragmentFromBeginningOfEditorToStartOfSelection.\n *\n * @param {} editor\n */\nexport function getFragmentFromBeginningOfEditorToStartOfSelection(\n  editor,\n  initialSelection,\n) {\n  if (typeof initialSelection === 'undefined') {\n    initialSelection = editor.selection;\n  }\n\n  // immer doesn't like editor.savedSelection\n  // TODO: there's a bug here related to splitting lists\n  const newEditor = { children: editor.children };\n  return Editor.fragment(\n    newEditor,\n    Editor.range(\n      newEditor,\n      [],\n      Range.isBackward(initialSelection)\n        ? initialSelection.focus\n        : initialSelection.anchor,\n    ),\n  );\n}\n\n/**\n * @returns {boolean} true if editor contains a range selection (active\n * selection or at least a saved selection)\n * @param {Editor} editor\n */\nexport function hasRangeSelection(editor, useSavedSelection = true) {\n  const { selection } = editor;\n  const savedSelection = editor.getSavedSelection();\n\n  const range = ReactEditor.isFocused(editor)\n    ? selection || (useSavedSelection ? savedSelection : null)\n    : savedSelection;\n\n  if (!range) {\n    // console.log('no range', editor);\n    return;\n  }\n\n  const res = Range.isExpanded(range);\n  // console.log('call hasRange', res);\n  return res;\n}\n\nexport function parseDefaultSelection(editor, defaultSelection) {\n  if (defaultSelection) {\n    if (defaultSelection === 'start') {\n      const [, path] = Node.first(editor, []);\n      const newSel = {\n        anchor: { path, offset: 0 },\n        focus: { path, offset: 0 },\n      };\n      return newSel;\n    }\n    if (defaultSelection === 'end') {\n      const [leaf, path] = Node.last(editor, []);\n      const newSel = {\n        anchor: { path, offset: (leaf.text || '').length },\n        focus: { path, offset: (leaf.text || '').length },\n      };\n      return newSel;\n    }\n    return defaultSelection;\n  }\n}\n"],"mappings":";;;;AACA,SAASA,MAAM,EAAEC,UAAU,EAAEC,KAAK,EAAEC,IAAI,QAAQ,OAAO;AACvD,SAASC,WAAW,QAAQ,aAAa;AACzC,SAASC,cAAc,QAAQ,0BAA0B;AACzD,SAASC,EAAE,QAAQ,8BAA8B;AACjD,OAAOC,MAAM,MAAM,uBAAuB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,uBAAuB,CAACC,MAAM,EAAEC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACnED,KAAK,GAAG,WAAUA,KAAK,CAAC;EAExB,OAAOV,MAAM,CAACY,KAAK,CAACH,MAAM;IACxBI,KAAK,EAAGC,CAAC,IAAK;MACZ,OAAOJ,KAAK,CAACK,QAAQ,CAACD,CAAC,CAACE,IAAI,CAAC;IAC/B;EAAC,GACEL,OAAO,EACV;AACJ;;AAEA;AACA;AACA;AACA,OAAO,SAASM,iBAAiB,CAACR,MAAM,EAAEC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EAC7D,MAAM,CAACE,KAAK,CAAC,GAAGL,uBAAuB,CAACC,MAAM,EAAEC,KAAK,EAAEC,OAAO,CAAC;EAC/D,OAAO,CAAC,CAACE,KAAK;AAChB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,4BAA4B,CAACT,MAAM,EAAEC,KAAK,EAAEC,OAAO,GAAG,CAAC,CAAC,EAAE;EACxE,OAAOQ,KAAK,CAACC,IAAI,CAACZ,uBAAuB,CAACC,MAAM,EAAEC,KAAK,EAAEC,OAAO,CAAC,CAAC;AACpE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASU,WAAW,CAACZ,MAAM,EAAE;EAClC,MAAMa,QAAQ,GAAG;IACfC,MAAM,EAAEvB,MAAM,CAACwB,KAAK,CAACf,MAAM,EAAE,CAAC,CAAC,CAAC,CAAC;IACjCgB,KAAK,EAAEzB,MAAM,CAAC0B,GAAG,CAACjB,MAAM,EAAE,CAAC,CAAC,CAAC;EAC/B,CAAC;EACD,OAAOa,QAAQ;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,SAAS,CAAClB,MAAM,EAAE;EAChCR,UAAU,CAAC2B,MAAM,CAACnB,MAAM,EAAEY,WAAW,CAACZ,MAAM,CAAC,CAAC;AAChD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASoB,oBAAoB,CAACpB,MAAM,EAAE;EAC3C;;EAEA,IAAIA,MAAM,CAACqB,SAAS,IAAI5B,KAAK,CAAC6B,WAAW,CAACtB,MAAM,CAACqB,SAAS,CAAC,EAAE;IAC3D,MAAM;MAAEP;IAAO,CAAC,GAAGd,MAAM,CAACqB,SAAS;IACnC,OAAOP,MAAM,CAACS,MAAM,GAAG,CAAC,GACpB,KAAK,GACLT,MAAM,CAACU,IAAI,CAACC,MAAM,CAAC,CAACC,GAAG,EAAEC,CAAC,KAAKD,GAAG,GAAGC,CAAC,EAAE,CAAC,CAAC,KAAK,CAAC;IACpD;EACF;;EACA,OAAO,KAAK;AACd;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,kBAAkB,CAAC5B,MAAM,EAAE;EACzC;;EAEA;EACA,IAAIA,MAAM,CAACqB,SAAS,IAAI5B,KAAK,CAAC6B,WAAW,CAACtB,MAAM,CAACqB,SAAS,CAAC,EAAE;IAAA;IAC3D,MAAMP,MAAM,GAAG,sBAAAd,MAAM,CAACqB,SAAS,sDAAhB,kBAAkBP,MAAM,KAAI,CAAC,CAAC;;IAE7C;IACA,MAAM,CAACe,IAAI,CAAC,GAAGnC,IAAI,CAACoC,IAAI,CAAC9B,MAAM,EAAE,EAAE,CAAC;IAEpC;IACE;IACAN,IAAI,CAACqC,GAAG,CAAC/B,MAAM,EAAEc,MAAM,CAACU,IAAI,CAAC,KAAKK,IAAI;IACtC;IACAf,MAAM,CAACS,MAAM,KAAKM,IAAI,CAACG,IAAI,CAACC,MAAM,EAClC;MACA,OAAO,IAAI;IACb;EACF;EACA,OAAO,KAAK;AACd;AAEA,MAAMC,oBAAoB,GAAG,MAAM;EACjC,MAAM;IAAEC;EAAM,CAAC,GAAGrC,MAAM,CAACsC,QAAQ;EACjC,MAAMC,EAAE,GAAGF,KAAK,CAACG,YAAY,EAAE;EAC/BD,EAAE,CAAC,CAAC,CAAC,CAAC9B,IAAI,GAAGV,EAAE;EACf,OAAOwC,EAAE;AACX,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,SAASE,4CAA4C,CAC1DvC,MAAM,EACNwC,gBAAgB,EAChB;EACA,IAAI,OAAOA,gBAAgB,KAAK,WAAW,EAAE;IAC3CA,gBAAgB,GAAGxC,MAAM,CAACqB,SAAS;EACrC;EAEA,MAAM;IAAEc;EAAM,CAAC,GAAGrC,MAAM,CAACsC,QAAQ;EACjC,MAAMK,KAAK,GAAGlD,MAAM,CAACkD,KAAK,CACxBzC,MAAM,EACNP,KAAK,CAACiD,UAAU,CAACF,gBAAgB,CAAC,GAC9BA,gBAAgB,CAACxB,KAAK,GACtBwB,gBAAgB,CAAC1B,MAAM,EAC3BvB,MAAM,CAAC0B,GAAG,CAACjB,MAAM,EAAE,EAAE,CAAC,CACvB;;EAED;EACA;EACA,IAAIP,KAAK,CAAC6B,WAAW,CAACmB,KAAK,CAAC,EAAE;IAC5B,IAAI7C,cAAc,CAACI,MAAM,CAAC,EAAE;MAC1B,OAAOkC,oBAAoB,EAAE;IAC/B,CAAC,MAAM;MACL,OAAOC,KAAK,CAACG,YAAY,EAAE;IAC7B;EACF;;EAEA;EACA,MAAMK,SAAS,GAAG;IAAEC,QAAQ,EAAE5C,MAAM,CAAC4C;EAAS,CAAC;EAC/C,OAAOrD,MAAM,CAACsD,QAAQ,CAACF,SAAS,EAAEF,KAAK,CAAC;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,kDAAkD,CAChE9C,MAAM,EACNwC,gBAAgB,EAChB;EACA,IAAI,OAAOA,gBAAgB,KAAK,WAAW,EAAE;IAC3CA,gBAAgB,GAAGxC,MAAM,CAACqB,SAAS;EACrC;;EAEA;EACA;EACA,MAAMsB,SAAS,GAAG;IAAEC,QAAQ,EAAE5C,MAAM,CAAC4C;EAAS,CAAC;EAC/C,OAAOrD,MAAM,CAACsD,QAAQ,CACpBF,SAAS,EACTpD,MAAM,CAACkD,KAAK,CACVE,SAAS,EACT,EAAE,EACFlD,KAAK,CAACiD,UAAU,CAACF,gBAAgB,CAAC,GAC9BA,gBAAgB,CAACxB,KAAK,GACtBwB,gBAAgB,CAAC1B,MAAM,CAC5B,CACF;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASiC,iBAAiB,CAAC/C,MAAM,EAAEgD,iBAAiB,GAAG,IAAI,EAAE;EAClE,MAAM;IAAE3B;EAAU,CAAC,GAAGrB,MAAM;EAC5B,MAAMiD,cAAc,GAAGjD,MAAM,CAACkD,iBAAiB,EAAE;EAEjD,MAAMT,KAAK,GAAG9C,WAAW,CAACwD,SAAS,CAACnD,MAAM,CAAC,GACvCqB,SAAS,KAAK2B,iBAAiB,GAAGC,cAAc,GAAG,IAAI,CAAC,GACxDA,cAAc;EAElB,IAAI,CAACR,KAAK,EAAE;IACV;IACA;EACF;EAEA,MAAMW,GAAG,GAAG3D,KAAK,CAAC4D,UAAU,CAACZ,KAAK,CAAC;EACnC;EACA,OAAOW,GAAG;AACZ;AAEA,OAAO,SAASE,qBAAqB,CAACtD,MAAM,EAAEuD,gBAAgB,EAAE;EAC9D,IAAIA,gBAAgB,EAAE;IACpB,IAAIA,gBAAgB,KAAK,OAAO,EAAE;MAChC,MAAM,GAAG/B,IAAI,CAAC,GAAG9B,IAAI,CAAC8D,KAAK,CAACxD,MAAM,EAAE,EAAE,CAAC;MACvC,MAAMyD,MAAM,GAAG;QACb3C,MAAM,EAAE;UAAEU,IAAI;UAAED,MAAM,EAAE;QAAE,CAAC;QAC3BP,KAAK,EAAE;UAAEQ,IAAI;UAAED,MAAM,EAAE;QAAE;MAC3B,CAAC;MACD,OAAOkC,MAAM;IACf;IACA,IAAIF,gBAAgB,KAAK,KAAK,EAAE;MAC9B,MAAM,CAACG,IAAI,EAAElC,IAAI,CAAC,GAAG9B,IAAI,CAACoC,IAAI,CAAC9B,MAAM,EAAE,EAAE,CAAC;MAC1C,MAAMyD,MAAM,GAAG;QACb3C,MAAM,EAAE;UAAEU,IAAI;UAAED,MAAM,EAAE,CAACmC,IAAI,CAAC1B,IAAI,IAAI,EAAE,EAAEC;QAAO,CAAC;QAClDjB,KAAK,EAAE;UAAEQ,IAAI;UAAED,MAAM,EAAE,CAACmC,IAAI,CAAC1B,IAAI,IAAI,EAAE,EAAEC;QAAO;MAClD,CAAC;MACD,OAAOwB,MAAM;IACf;IACA,OAAOF,gBAAgB;EACzB;AACF"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}