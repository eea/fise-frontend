{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n// The default behavior is to allow images to be copy/pasted inside the editor\n// The TextBlockEdit extensions will come and then split the images into\n// separate dedicated Volto image blocks.\n\nimport { IMAGE } from '@plone/volto-slate/constants';\nimport { jsx } from 'slate-hyperscript';\nexport const deserializeImageTag = (editor, el) => {\n  const attrs = {\n    type: IMAGE\n  };\n\n  // TODO: not all of these attributes should be stored in the DB\n  for (const name of el.getAttributeNames()) {\n    attrs[name] = el.getAttribute(name);\n  }\n\n  // TODO: recognize more unsupported protocols\n  if (typeof attrs.src === 'undefined' || attrs.src.startsWith('file:///')) {\n    return null;\n  }\n  attrs.url = attrs.src;\n  delete attrs.src;\n  return [jsx('element', attrs, [{\n    text: ''\n  }])];\n};\n\n/**\n * Allows for pasting images from clipboard.\n * Not yet: dragging and dropping images, selecting them through a file system dialog.\n * @param typeImg\n */\nexport const withImage = editor => {\n  const {\n    isVoid,\n    isInline\n  } = editor;\n  editor.isVoid = element => {\n    return element.type === IMAGE ? true : isVoid(element);\n  };\n\n  // If it's not marked as inline, Slate will strip the {type:'img\"} nodes when\n  // it finds them next to {text: ''} nodes\n  editor.isInline = element => {\n    return element && element.type === IMAGE ? true : isInline(element);\n  };\n  editor.htmlTagsToSlate = _objectSpread(_objectSpread({}, editor.htmlTagsToSlate), {}, {\n    IMG: deserializeImageTag\n  });\n  return editor;\n};","map":{"version":3,"names":["IMAGE","jsx","deserializeImageTag","editor","el","attrs","type","name","getAttributeNames","getAttribute","src","startsWith","url","text","withImage","isVoid","isInline","element","htmlTagsToSlate","IMG"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/packages/volto-slate/src/editor/plugins/Image/extensions.js"],"sourcesContent":["// The default behavior is to allow images to be copy/pasted inside the editor\n// The TextBlockEdit extensions will come and then split the images into\n// separate dedicated Volto image blocks.\n\nimport { IMAGE } from '@plone/volto-slate/constants';\nimport { jsx } from 'slate-hyperscript';\n\nexport const deserializeImageTag = (editor, el) => {\n  const attrs = { type: IMAGE };\n\n  // TODO: not all of these attributes should be stored in the DB\n  for (const name of el.getAttributeNames()) {\n    attrs[name] = el.getAttribute(name);\n  }\n\n  // TODO: recognize more unsupported protocols\n  if (typeof attrs.src === 'undefined' || attrs.src.startsWith('file:///')) {\n    return null;\n  }\n\n  attrs.url = attrs.src;\n  delete attrs.src;\n\n  return [jsx('element', attrs, [{ text: '' }])];\n};\n\n/**\n * Allows for pasting images from clipboard.\n * Not yet: dragging and dropping images, selecting them through a file system dialog.\n * @param typeImg\n */\nexport const withImage = (editor) => {\n  const { isVoid, isInline } = editor;\n\n  editor.isVoid = (element) => {\n    return element.type === IMAGE ? true : isVoid(element);\n  };\n\n  // If it's not marked as inline, Slate will strip the {type:'img\"} nodes when\n  // it finds them next to {text: ''} nodes\n  editor.isInline = (element) => {\n    return element && element.type === IMAGE ? true : isInline(element);\n  };\n\n  editor.htmlTagsToSlate = {\n    ...editor.htmlTagsToSlate,\n    IMG: deserializeImageTag,\n  };\n\n  return editor;\n};\n"],"mappings":";;;AAAA;AACA;AACA;;AAEA,SAASA,KAAK,QAAQ,8BAA8B;AACpD,SAASC,GAAG,QAAQ,mBAAmB;AAEvC,OAAO,MAAMC,mBAAmB,GAAG,CAACC,MAAM,EAAEC,EAAE,KAAK;EACjD,MAAMC,KAAK,GAAG;IAAEC,IAAI,EAAEN;EAAM,CAAC;;EAE7B;EACA,KAAK,MAAMO,IAAI,IAAIH,EAAE,CAACI,iBAAiB,EAAE,EAAE;IACzCH,KAAK,CAACE,IAAI,CAAC,GAAGH,EAAE,CAACK,YAAY,CAACF,IAAI,CAAC;EACrC;;EAEA;EACA,IAAI,OAAOF,KAAK,CAACK,GAAG,KAAK,WAAW,IAAIL,KAAK,CAACK,GAAG,CAACC,UAAU,CAAC,UAAU,CAAC,EAAE;IACxE,OAAO,IAAI;EACb;EAEAN,KAAK,CAACO,GAAG,GAAGP,KAAK,CAACK,GAAG;EACrB,OAAOL,KAAK,CAACK,GAAG;EAEhB,OAAO,CAACT,GAAG,CAAC,SAAS,EAAEI,KAAK,EAAE,CAAC;IAAEQ,IAAI,EAAE;EAAG,CAAC,CAAC,CAAC,CAAC;AAChD,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,SAAS,GAAIX,MAAM,IAAK;EACnC,MAAM;IAAEY,MAAM;IAAEC;EAAS,CAAC,GAAGb,MAAM;EAEnCA,MAAM,CAACY,MAAM,GAAIE,OAAO,IAAK;IAC3B,OAAOA,OAAO,CAACX,IAAI,KAAKN,KAAK,GAAG,IAAI,GAAGe,MAAM,CAACE,OAAO,CAAC;EACxD,CAAC;;EAED;EACA;EACAd,MAAM,CAACa,QAAQ,GAAIC,OAAO,IAAK;IAC7B,OAAOA,OAAO,IAAIA,OAAO,CAACX,IAAI,KAAKN,KAAK,GAAG,IAAI,GAAGgB,QAAQ,CAACC,OAAO,CAAC;EACrE,CAAC;EAEDd,MAAM,CAACe,eAAe,mCACjBf,MAAM,CAACe,eAAe;IACzBC,GAAG,EAAEjB;EAAmB,EACzB;EAED,OAAOC,MAAM;AACf,CAAC"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}