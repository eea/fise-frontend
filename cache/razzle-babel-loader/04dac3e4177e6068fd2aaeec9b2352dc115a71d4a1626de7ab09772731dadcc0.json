{"ast":null,"code":"import _isString from \"lodash/isString\";\nimport _isObject from \"lodash/isObject\";\nimport _isBoolean from \"lodash/isBoolean\";\nimport { getBoolean } from '@plone/volto/helpers';\nimport { defineMessages } from 'react-intl';\nconst messages = defineMessages({\n  no_value: {\n    \"id\": \"No value\",\n    \"defaultMessage\": \"No value\"\n  }\n});\n\n/**\n * Prepares a vocab endpoint query for tokens based on passed value.\n *\n * This can be used to facilitate querying a vocabulary endpoint for labels,\n * given some token values. This assumes that the value has already been\n * normalized by normalizeValue.\n */\nexport function convertValueToVocabQuery(value) {\n  var _value$value;\n  if (_isString(value) || _isBoolean(value)) return {\n    token: value.toString()\n  };\n  if (!value) return {};\n  if (Array.isArray(value)) {\n    return {\n      tokens: value.map(v => {\n        var _v$value;\n        return _isObject(v) ? (_v$value = v.value) !== null && _v$value !== void 0 ? _v$value : v.token : _isString(v) || _isBoolean(v) ? v : null;\n      }).filter(f => f !== null)\n    };\n  }\n  const token = (_value$value = value.value) !== null && _value$value !== void 0 ? _value$value : value.token;\n  return _isString(token) ? {\n    token\n  } : {};\n}\n\n/**\n * Normalizes provided value to a \"best representation\" value, as accepted by\n * react-select. In this case, it is an object of shape `{ label, value }`\n */\nexport function normalizeSingleSelectOption(value, intl) {\n  var _ref, _value$token, _ref2, _ref3, _ref4;\n  if (!value) return value;\n  if (Array.isArray(value)) {\n    // assuming [token, title] pair.\n    if (value.length === 2) return {\n      value: value[0],\n      label: value[1] || value[0]\n    };\n    throw new Error(`Unknown value type of select widget: ${value}`);\n  }\n  const token = (_ref = (_value$token = value.token) !== null && _value$token !== void 0 ? _value$token : value.value) !== null && _ref !== void 0 ? _ref : 'no-value';\n  const label = (_ref2 = (_ref3 = (_ref4 = value.title && value.title !== 'None' ? value.title : undefined) !== null && _ref4 !== void 0 ? _ref4 : value.label) !== null && _ref3 !== void 0 ? _ref3 : value.token) !== null && _ref2 !== void 0 ? _ref2 : intl.formatMessage(messages.no_value);\n  return {\n    value: token,\n    label\n  };\n}\nexport const normalizeChoices = (items, intl) => items.map(item => normalizeSingleSelectOption(item, intl));\n\n/**\n * Given the value from the API, it normalizes to a value valid to use in react-select.\n * This is necessary because of the inconsistencies in p.restapi vocabularies implementations as\n * they need to adapt to react-select public interface.\n * @function normalizeValue\n * @param {array} choices The choices\n * @param {string|object|boolean|array} value The value\n * @returns {Object} An object of shape {label: \"\", value: \"\"} (or an array)\n */\nexport function normalizeValue(choices, value, intl) {\n  choices = normalizeChoices(choices || [], intl);\n  const choiceMap = Object.assign({}, ...choices.map(({\n    label,\n    value\n  }) => ({\n    [value]: label\n  })));\n  if (!_isObject(value) && _isBoolean(value)) {\n    // We have a boolean value, which means we need to provide a \"No value\"\n    // option\n    const label = choiceMap[getBoolean(value)];\n    return label ? {\n      label,\n      value\n    } : {};\n  }\n  if (value === 'no-value') {\n    return {\n      label: intl.formatMessage(messages.no_value),\n      value: 'no-value'\n    };\n  }\n  if (value === undefined || !value || value.length === 0) return null;\n  if (Array.isArray(value)) {\n    // a list of values, like ['foo', 'bar'];\n    return value.map(v => normalizeValue(choices, v));\n  }\n  if (_isObject(value)) {\n    // an object like `{label, value}` or `{ title, value }`\n    return normalizeSingleSelectOption(value, intl);\n  }\n\n  // fallback: treat value as a token and look it up in choices\n  return Object.keys(choiceMap).includes(value) ? {\n    label: choiceMap[value],\n    value\n  } : {\n    label: value,\n    value\n  };\n}","map":{"version":3,"names":["getBoolean","defineMessages","messages","no_value","convertValueToVocabQuery","value","token","toString","Array","isArray","tokens","map","v","filter","f","normalizeSingleSelectOption","intl","length","label","Error","title","undefined","formatMessage","normalizeChoices","items","item","normalizeValue","choices","choiceMap","Object","assign","keys","includes"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/components/manage/Widgets/SelectUtils.js"],"sourcesContent":["import { isBoolean, isObject, isString } from 'lodash';\nimport { getBoolean } from '@plone/volto/helpers';\nimport { defineMessages } from 'react-intl';\n\nconst messages = defineMessages({\n  no_value: {\n    id: 'No value',\n    defaultMessage: 'No value',\n  },\n});\n\n/**\n * Prepares a vocab endpoint query for tokens based on passed value.\n *\n * This can be used to facilitate querying a vocabulary endpoint for labels,\n * given some token values. This assumes that the value has already been\n * normalized by normalizeValue.\n */\nexport function convertValueToVocabQuery(value) {\n  if (isString(value) || isBoolean(value)) return { token: value.toString() };\n\n  if (!value) return {};\n\n  if (Array.isArray(value)) {\n    return {\n      tokens: value\n        .map((v) =>\n          isObject(v)\n            ? v.value ?? v.token\n            : isString(v) || isBoolean(v)\n            ? v\n            : null,\n        )\n        .filter((f) => f !== null),\n    };\n  }\n\n  const token = value.value ?? value.token;\n  return isString(token) ? { token } : {};\n}\n\n/**\n * Normalizes provided value to a \"best representation\" value, as accepted by\n * react-select. In this case, it is an object of shape `{ label, value }`\n */\nexport function normalizeSingleSelectOption(value, intl) {\n  if (!value) return value;\n\n  if (Array.isArray(value)) {\n    // assuming [token, title] pair.\n    if (value.length === 2)\n      return { value: value[0], label: value[1] || value[0] };\n\n    throw new Error(`Unknown value type of select widget: ${value}`);\n  }\n\n  const token = value.token ?? value.value ?? 'no-value';\n  const label =\n    (value.title && value.title !== 'None' ? value.title : undefined) ??\n    value.label ??\n    value.token ??\n    intl.formatMessage(messages.no_value);\n\n  return {\n    value: token,\n    label,\n  };\n}\n\nexport const normalizeChoices = (items, intl) =>\n  items.map((item) => normalizeSingleSelectOption(item, intl));\n\n/**\n * Given the value from the API, it normalizes to a value valid to use in react-select.\n * This is necessary because of the inconsistencies in p.restapi vocabularies implementations as\n * they need to adapt to react-select public interface.\n * @function normalizeValue\n * @param {array} choices The choices\n * @param {string|object|boolean|array} value The value\n * @returns {Object} An object of shape {label: \"\", value: \"\"} (or an array)\n */\nexport function normalizeValue(choices, value, intl) {\n  choices = normalizeChoices(choices || [], intl);\n  const choiceMap = Object.assign(\n    {},\n    ...choices.map(({ label, value }) => ({\n      [value]: label,\n    })),\n  );\n\n  if (!isObject(value) && isBoolean(value)) {\n    // We have a boolean value, which means we need to provide a \"No value\"\n    // option\n    const label = choiceMap[getBoolean(value)];\n    return label\n      ? {\n          label,\n          value,\n        }\n      : {};\n  }\n  if (value === 'no-value') {\n    return {\n      label: intl.formatMessage(messages.no_value),\n      value: 'no-value',\n    };\n  }\n\n  if (value === undefined || !value || value.length === 0) return null;\n\n  if (Array.isArray(value)) {\n    // a list of values, like ['foo', 'bar'];\n    return value.map((v) => normalizeValue(choices, v));\n  }\n\n  if (isObject(value)) {\n    // an object like `{label, value}` or `{ title, value }`\n    return normalizeSingleSelectOption(value, intl);\n  }\n\n  // fallback: treat value as a token and look it up in choices\n  return Object.keys(choiceMap).includes(value)\n    ? { label: choiceMap[value], value }\n    : { label: value, value };\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[{"id":"No value","defaultMessage":"No value"}]}},"sourceType":"module","externalDependencies":[]}