{"ast":null,"code":"import _defineProperty from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { withRouter } from 'react-router';\nimport { connect } from 'react-redux';\nimport config from '@plone/volto/registry';\nimport { matchAllRoutes } from './utils';\nimport { load, loadSuccess, loadFail, beginGlobalLoad, endGlobalLoad } from '@plone/volto/actions/asyncConnect/asyncConnect';\nimport { isPromise, getMutableState, getImmutableState } from './utils';\nimport { AsyncConnectWithContext } from './AsyncConnect';\nexport { loadOnServer, loadAsyncConnect } from './ssr';\n\n// options is: { location, store: { dispatch }, route, match, routes }\nvar wrapWithDispatch = function wrapWithDispatch(Component) {\n  var asyncItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  return [{\n    key: 'voltoLoadAsyncProps',\n    promise: function promise(options) {\n      var dispatch = options.store.dispatch,\n        pathname = options.location.pathname;\n      var foundAsyncItems = applyExtenders(asyncItems, pathname);\n      var connects = foundAsyncItems.map(function (item) {\n        var key = item.key;\n        if (!key) return item;\n        var next = item.promise(options);\n        if (isPromise(next)) {\n          dispatch(load(key));\n          // add action dispatchers\n          next.then(function (data) {\n            return dispatch(loadSuccess(key, data));\n          })[\"catch\"](function (err) {\n            return dispatch(loadFail(key, err));\n          });\n        } else if (next) {\n          dispatch(loadSuccess(key, next));\n        }\n        return _objectSpread(_objectSpread({}, item), {}, {\n          promise: next\n        });\n      });\n      Component.reduxAsyncConnect = connects;\n      return connects;\n    }\n  }];\n};\nvar applyExtenders = function applyExtenders(asyncItems, pathname) {\n  var _config$settings$asyn = config.settings.asyncPropsExtenders,\n    asyncPropsExtenders = _config$settings$asyn === void 0 ? [] : _config$settings$asyn;\n  var extenders = matchAllRoutes(asyncPropsExtenders, pathname);\n  var foundAsyncItems = extenders.reduce(function (acc, extender) {\n    return extender.route.extend(acc);\n  }, asyncItems);\n  var uniqueAsyncItems = foundAsyncItems.reduce(function (a, d) {\n    if (!a.some(function (el) {\n      return el.key === d.key;\n    })) {\n      a.push(d);\n    }\n    return a;\n  }, []);\n  return uniqueAsyncItems;\n};\n\n/**\n * A replacement for redux-connect's asyncConnect.\n *\n * It was needed because asyncConnect works as a direct wrapper on top of\n * a Component, so the config registry is not yet initialized. To solve this\n * problem we replace the original reduxAsyncConnect implementation (which was\n * a list of asyncConnected \"object promises\") with as single promise exposed\n * as { key: 'voltoLoadAsyncProps', promise: ... }.\n *\n * In more details, the original asyncConnect worked by replacing all our\n * \"object promises\" with a special version that's integrated with its own\n * Redux actions. We do another wrap, which takes the initial passed \"object\n * promises\", finds registered, per route, \"extenders\", calls these extenders\n * with the \"object promises\" and that's our \"object promises\" (which it calls\n * internally \"asyncItems\").\n */\nexport function asyncConnect(asyncItems, mapStateToProps, mapDispatchToProps, mergeProps, options) {\n  return function (Component) {\n    Component.reduxAsyncConnect = wrapWithDispatch(Component, asyncItems);\n    var finalMapStateToProps = function finalMapStateToProps(state, ownProps) {\n      var pathname = state.router.location.pathname;\n      var foundAsyncItems = applyExtenders(asyncItems, pathname);\n      var mutableState = getMutableState(state);\n      var asyncStateToProps = foundAsyncItems.reduce(function (result, _ref) {\n        var key = _ref.key;\n        if (!key) {\n          return result;\n        }\n        return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, key, mutableState.reduxAsyncConnect[key]));\n      }, {});\n      if (typeof mapStateToProps !== 'function') {\n        return asyncStateToProps;\n      }\n      return _objectSpread(_objectSpread({}, mapStateToProps(getImmutableState(mutableState), ownProps)), asyncStateToProps);\n    };\n    return connect(finalMapStateToProps, mapDispatchToProps, mergeProps, options)(Component);\n  };\n}\nexport var ReduxAsyncConnect = connect(null, {\n  beginGlobalLoad: beginGlobalLoad,\n  endGlobalLoad: endGlobalLoad\n})(withRouter(AsyncConnectWithContext));","map":{"version":3,"names":["withRouter","connect","config","matchAllRoutes","load","loadSuccess","loadFail","beginGlobalLoad","endGlobalLoad","isPromise","getMutableState","getImmutableState","AsyncConnectWithContext","loadOnServer","loadAsyncConnect","wrapWithDispatch","Component","asyncItems","key","promise","options","dispatch","store","pathname","location","foundAsyncItems","applyExtenders","connects","map","item","next","then","data","err","reduxAsyncConnect","settings","asyncPropsExtenders","extenders","reduce","acc","extender","route","extend","uniqueAsyncItems","a","d","some","el","push","asyncConnect","mapStateToProps","mapDispatchToProps","mergeProps","finalMapStateToProps","state","ownProps","router","mutableState","asyncStateToProps","result","ReduxAsyncConnect"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/AsyncConnect/index.js"],"sourcesContent":["import { withRouter } from 'react-router';\nimport { connect } from 'react-redux';\nimport config from '@plone/volto/registry';\nimport { matchAllRoutes } from './utils';\n\nimport {\n  load,\n  loadSuccess,\n  loadFail,\n  beginGlobalLoad,\n  endGlobalLoad,\n} from '@plone/volto/actions/asyncConnect/asyncConnect';\n\nimport { isPromise, getMutableState, getImmutableState } from './utils';\nimport { AsyncConnectWithContext } from './AsyncConnect';\nexport { loadOnServer, loadAsyncConnect } from './ssr';\n\n// options is: { location, store: { dispatch }, route, match, routes }\nconst wrapWithDispatch = (Component, asyncItems = []) => {\n  return [\n    {\n      key: 'voltoLoadAsyncProps',\n      promise: (options) => {\n        const {\n          store: { dispatch },\n          location: { pathname },\n        } = options;\n\n        const foundAsyncItems = applyExtenders(asyncItems, pathname);\n\n        const connects = foundAsyncItems.map((item) => {\n          const { key } = item;\n          if (!key) return item;\n          const next = item.promise(options);\n\n          if (isPromise(next)) {\n            dispatch(load(key));\n            // add action dispatchers\n            next\n              .then((data) => dispatch(loadSuccess(key, data)))\n              .catch((err) => dispatch(loadFail(key, err)));\n          } else if (next) {\n            dispatch(loadSuccess(key, next));\n          }\n          return {\n            ...item,\n            promise: next,\n          };\n        });\n\n        Component.reduxAsyncConnect = connects;\n        return connects;\n      },\n    },\n  ];\n};\n\nconst applyExtenders = (asyncItems, pathname) => {\n  const { asyncPropsExtenders = [] } = config.settings;\n  const extenders = matchAllRoutes(asyncPropsExtenders, pathname);\n\n  const foundAsyncItems = extenders.reduce(\n    (acc, extender) => extender.route.extend(acc),\n    asyncItems,\n  );\n\n  let uniqueAsyncItems = foundAsyncItems.reduce((a, d) => {\n    if (!a.some((el) => el.key === d.key)) {\n      a.push(d);\n    }\n    return a;\n  }, []);\n\n  return uniqueAsyncItems;\n};\n\n/**\n * A replacement for redux-connect's asyncConnect.\n *\n * It was needed because asyncConnect works as a direct wrapper on top of\n * a Component, so the config registry is not yet initialized. To solve this\n * problem we replace the original reduxAsyncConnect implementation (which was\n * a list of asyncConnected \"object promises\") with as single promise exposed\n * as { key: 'voltoLoadAsyncProps', promise: ... }.\n *\n * In more details, the original asyncConnect worked by replacing all our\n * \"object promises\" with a special version that's integrated with its own\n * Redux actions. We do another wrap, which takes the initial passed \"object\n * promises\", finds registered, per route, \"extenders\", calls these extenders\n * with the \"object promises\" and that's our \"object promises\" (which it calls\n * internally \"asyncItems\").\n */\nexport function asyncConnect(\n  asyncItems,\n  mapStateToProps,\n  mapDispatchToProps,\n  mergeProps,\n  options,\n) {\n  return (Component) => {\n    Component.reduxAsyncConnect = wrapWithDispatch(Component, asyncItems);\n\n    const finalMapStateToProps = (state, ownProps) => {\n      const { pathname } = state.router.location;\n      const foundAsyncItems = applyExtenders(asyncItems, pathname);\n      const mutableState = getMutableState(state);\n      const asyncStateToProps = foundAsyncItems.reduce((result, { key }) => {\n        if (!key) {\n          return result;\n        }\n\n        return {\n          ...result,\n          [key]: mutableState.reduxAsyncConnect[key],\n        };\n      }, {});\n\n      if (typeof mapStateToProps !== 'function') {\n        return asyncStateToProps;\n      }\n\n      return {\n        ...mapStateToProps(getImmutableState(mutableState), ownProps),\n        ...asyncStateToProps,\n      };\n    };\n\n    return connect(\n      finalMapStateToProps,\n      mapDispatchToProps,\n      mergeProps,\n      options,\n    )(Component);\n  };\n}\n\nexport const ReduxAsyncConnect = connect(null, {\n  beginGlobalLoad,\n  endGlobalLoad,\n})(withRouter(AsyncConnectWithContext));\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}