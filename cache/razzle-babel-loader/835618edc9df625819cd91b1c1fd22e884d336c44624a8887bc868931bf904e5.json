{"ast":null,"code":"var _jsxFileName = \"/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/packages/volto-slate/src/elementEditor/SidebarEditor.jsx\";\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n/**\n * A small wrapper around PluginEditor. Its purpose it to allow for clearer\n * code, otherwise it would mix too many hooks and it's not possible to render\n * a variable number of hooks in a component\n */\nimport React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { SidebarPopup } from '@plone/volto/components';\nimport { setPluginOptions } from '@plone/volto-slate/actions';\nconst SidebarEditor = props => {\n  const {\n    editor,\n    pluginId,\n    getActiveElement,\n    pluginEditor\n  } = props;\n  const pid = `${editor.uid}-${pluginId}`;\n  const PluginEditor = pluginEditor;\n  const showEditor = useSelector(state => {\n    var _state$slate_plugins, _state$slate_plugins$;\n    return (_state$slate_plugins = state['slate_plugins']) === null || _state$slate_plugins === void 0 ? void 0 : (_state$slate_plugins$ = _state$slate_plugins[pid]) === null || _state$slate_plugins$ === void 0 ? void 0 : _state$slate_plugins$.show_sidebar_editor;\n  });\n  const dispatch = useDispatch();\n  let active;\n  try {\n    active = getActiveElement(editor);\n  } catch (error) {\n    // eslint-disable-next-line\n    console.warn('Error in getting active element', error);\n  }\n\n  // Hide the editor when switching to another text element\n  React.useEffect(() => {\n    if (!active) dispatch(setPluginOptions(pid, {\n      show_sidebar_editor: false\n    }));\n  }, [active, dispatch, pluginId, pid]);\n  editor.isSidebarOpen = showEditor && active;\n  return editor.isSidebarOpen ? __jsx(SidebarPopup, {\n    open: true,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 5\n    }\n  }, __jsx(PluginEditor, _extends({}, props, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 39,\n      columnNumber: 7\n    }\n  }))) : '';\n};\nexport default SidebarEditor;","map":{"version":3,"names":["React","useSelector","useDispatch","SidebarPopup","setPluginOptions","SidebarEditor","props","editor","pluginId","getActiveElement","pluginEditor","pid","uid","PluginEditor","showEditor","state","show_sidebar_editor","dispatch","active","error","console","warn","useEffect","isSidebarOpen"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/packages/volto-slate/src/elementEditor/SidebarEditor.jsx"],"sourcesContent":["/**\n * A small wrapper around PluginEditor. Its purpose it to allow for clearer\n * code, otherwise it would mix too many hooks and it's not possible to render\n * a variable number of hooks in a component\n */\nimport React from 'react';\nimport { useSelector, useDispatch } from 'react-redux';\nimport { SidebarPopup } from '@plone/volto/components';\nimport { setPluginOptions } from '@plone/volto-slate/actions';\n\nconst SidebarEditor = (props) => {\n  const { editor, pluginId, getActiveElement, pluginEditor } = props;\n  const pid = `${editor.uid}-${pluginId}`;\n  const PluginEditor = pluginEditor;\n  const showEditor = useSelector((state) => {\n    return state['slate_plugins']?.[pid]?.show_sidebar_editor;\n  });\n\n  const dispatch = useDispatch();\n\n  let active;\n  try {\n    active = getActiveElement(editor);\n  } catch (error) {\n    // eslint-disable-next-line\n    console.warn('Error in getting active element', error);\n  }\n\n  // Hide the editor when switching to another text element\n  React.useEffect(() => {\n    if (!active)\n      dispatch(setPluginOptions(pid, { show_sidebar_editor: false }));\n  }, [active, dispatch, pluginId, pid]);\n\n  editor.isSidebarOpen = showEditor && active;\n\n  return editor.isSidebarOpen ? (\n    <SidebarPopup open={true}>\n      <PluginEditor {...props} />\n    </SidebarPopup>\n  ) : (\n    ''\n  );\n};\n\nexport default SidebarEditor;\n"],"mappings":";;;AAAA;AACA;AACA;AACA;AACA;AACA,OAAOA,KAAK,MAAM,OAAO;AACzB,SAASC,WAAW,EAAEC,WAAW,QAAQ,aAAa;AACtD,SAASC,YAAY,QAAQ,yBAAyB;AACtD,SAASC,gBAAgB,QAAQ,4BAA4B;AAE7D,MAAMC,aAAa,GAAIC,KAAK,IAAK;EAC/B,MAAM;IAAEC,MAAM;IAAEC,QAAQ;IAAEC,gBAAgB;IAAEC;EAAa,CAAC,GAAGJ,KAAK;EAClE,MAAMK,GAAG,GAAI,GAAEJ,MAAM,CAACK,GAAI,IAAGJ,QAAS,EAAC;EACvC,MAAMK,YAAY,GAAGH,YAAY;EACjC,MAAMI,UAAU,GAAGb,WAAW,CAAEc,KAAK,IAAK;IAAA;IACxC,+BAAOA,KAAK,CAAC,eAAe,CAAC,kFAAtB,qBAAyBJ,GAAG,CAAC,0DAA7B,sBAA+BK,mBAAmB;EAC3D,CAAC,CAAC;EAEF,MAAMC,QAAQ,GAAGf,WAAW,EAAE;EAE9B,IAAIgB,MAAM;EACV,IAAI;IACFA,MAAM,GAAGT,gBAAgB,CAACF,MAAM,CAAC;EACnC,CAAC,CAAC,OAAOY,KAAK,EAAE;IACd;IACAC,OAAO,CAACC,IAAI,CAAC,iCAAiC,EAAEF,KAAK,CAAC;EACxD;;EAEA;EACAnB,KAAK,CAACsB,SAAS,CAAC,MAAM;IACpB,IAAI,CAACJ,MAAM,EACTD,QAAQ,CAACb,gBAAgB,CAACO,GAAG,EAAE;MAAEK,mBAAmB,EAAE;IAAM,CAAC,CAAC,CAAC;EACnE,CAAC,EAAE,CAACE,MAAM,EAAED,QAAQ,EAAET,QAAQ,EAAEG,GAAG,CAAC,CAAC;EAErCJ,MAAM,CAACgB,aAAa,GAAGT,UAAU,IAAII,MAAM;EAE3C,OAAOX,MAAM,CAACgB,aAAa,GACzB,MAAC,YAAY;IAAC,IAAI,EAAE,IAAK;IAAA;IAAA;MAAA;MAAA;MAAA;IAAA;EAAA,GACvB,MAAC,YAAY,eAAKjB,KAAK;IAAA;IAAA;MAAA;MAAA;MAAA;IAAA;EAAA,GAAI,CACd,GAEf,EACD;AACH,CAAC;AAED,eAAeD,aAAa"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}