{"ast":null,"code":"var _jsxFileName = \"/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/components/manage/Blocks/Search/hocs/withSearch.jsx\";\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport React from 'react';\nimport { useSelector } from 'react-redux';\nimport qs from 'query-string';\nimport { useLocation, useHistory } from 'react-router-dom';\nimport { resolveExtension } from '@plone/volto/helpers/Extensions/withBlockExtensions';\nimport config from '@plone/volto/registry';\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\nconst SEARCH_ENDPOINT_FIELDS = ['SearchableText', 'b_size', 'limit', 'sort_on', 'sort_order'];\nconst PAQO = 'plone.app.querystring.operation';\n\n/**\n * Based on URL state, gets an initial internal state for the search\n *\n * @function getInitialState\n *\n */\nfunction getInitialState(data, facets, urlSearchText, id) {\n  var _data$query, _data$query2, _data$query3, _data$query4, _data$query5;\n  const {\n    types: facetWidgetTypes\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const facetSettings = (data === null || data === void 0 ? void 0 : data.facets) || [];\n  return {\n    query: [...(((_data$query = data.query) === null || _data$query === void 0 ? void 0 : _data$query.query) || []), ...(facetSettings || []).map(facet => {\n      if (!(facet !== null && facet !== void 0 && facet.field)) return null;\n      const {\n        valueToQuery\n      } = resolveExtension('type', facetWidgetTypes, facet);\n      const name = facet.field.value;\n      const value = facets[name];\n      return valueToQuery({\n        value,\n        facet\n      });\n    }).filter(f => !!f), ...(urlSearchText ? [{\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: urlSearchText\n    }] : [])],\n    sort_on: (_data$query2 = data.query) === null || _data$query2 === void 0 ? void 0 : _data$query2.sort_on,\n    sort_order: (_data$query3 = data.query) === null || _data$query3 === void 0 ? void 0 : _data$query3.sort_order,\n    b_size: (_data$query4 = data.query) === null || _data$query4 === void 0 ? void 0 : _data$query4.b_size,\n    limit: (_data$query5 = data.query) === null || _data$query5 === void 0 ? void 0 : _data$query5.limit,\n    block: id\n  };\n}\n\n/**\n * \"Normalizes\" the search state to something that's serializable\n * (for querying) and used to compute data for the ListingBody\n *\n * @function normalizeState\n *\n */\nfunction normalizeState({\n  query,\n  // base query\n  facets,\n  // facet values\n  id,\n  // block id\n  searchText,\n  // SearchableText\n  sortOn,\n  sortOrder,\n  facetSettings // data.facets extracted from block data\n}) {\n  const {\n    types: facetWidgetTypes\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const params = {\n    query: [...(query.query || []), ...(facetSettings || []).map(facet => {\n      if (!(facet !== null && facet !== void 0 && facet.field)) return null;\n      const {\n        valueToQuery\n      } = resolveExtension('type', facetWidgetTypes, facet);\n      const name = facet.field.value;\n      const value = facets[name];\n      return valueToQuery({\n        value,\n        facet\n      });\n    })].filter(o => !!o),\n    sort_on: sortOn || query.sort_on,\n    sort_order: sortOrder || query.sort_order,\n    b_size: query.b_size,\n    limit: query.limit,\n    block: id\n  };\n\n  // TODO: need to check if SearchableText facet is not already in the query\n  // Ideally the searchtext functionality should be restructured as being just\n  // another facet\n  params.query = params.query.reduce(\n  // Remove SearchableText from query\n  (acc, kvp) => kvp.i === 'SearchableText' ? acc : [...acc, kvp], []);\n  if (searchText) {\n    params.query.push({\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: searchText\n    });\n  }\n  return params;\n}\nconst getSearchFields = searchData => {\n  return Object.assign({}, ...SEARCH_ENDPOINT_FIELDS.map(k => {\n    return searchData[k] ? {\n      [k]: searchData[k]\n    } : {};\n  }), searchData.query ? {\n    query: serializeQuery(searchData['query'])\n  } : {});\n};\n\n/**\n * A HOC that will mirror the search block state to a hash location\n */\nconst useHashState = () => {\n  const location = useLocation();\n  const history = useHistory();\n  const oldState = React.useMemo(() => {\n    return _objectSpread(_objectSpread({}, qs.parse(location.search)), qs.parse(location.hash));\n  }, [location.hash, location.search]);\n\n  // This creates a shallow copy. Why is this needed?\n  const current = Object.assign({}, ...Array.from(Object.keys(oldState)).map(k => ({\n    [k]: oldState[k]\n  })));\n  const setSearchData = React.useCallback(searchData => {\n    const newParams = qs.parse(location.hash);\n    let changed = false;\n    Object.keys(searchData).sort().forEach(k => {\n      if (searchData[k]) {\n        newParams[k] = searchData[k];\n        if (oldState[k] !== searchData[k]) {\n          changed = true;\n        }\n      }\n    });\n    if (changed) {\n      history.push({\n        hash: qs.stringify(newParams)\n      });\n    }\n  }, [history, oldState, location.hash]);\n  return [current, setSearchData];\n};\n\n/**\n * A hook to make it possible to switch disable mirroring the search block\n * state to the window location. When using the internal state we \"start from\n * scratch\", as it's intended to be used in the edit page.\n */\nconst useSearchBlockState = (uniqueId, isEditMode) => {\n  const [hashState, setHashState] = useHashState();\n  const [internalState, setInternalState] = React.useState({});\n  return isEditMode ? [internalState, setInternalState] : [hashState, setHashState];\n};\n\n// Simple compress/decompress the state in URL by replacing the lengthy string\nconst deserializeQuery = q => {\n  var _JSON$parse;\n  return (_JSON$parse = JSON.parse(q)) === null || _JSON$parse === void 0 ? void 0 : _JSON$parse.map(kvp => _objectSpread(_objectSpread({}, kvp), {}, {\n    o: kvp.o.replace(/^paqo/, PAQO)\n  }));\n};\nconst serializeQuery = q => {\n  return JSON.stringify(q === null || q === void 0 ? void 0 : q.map(kvp => _objectSpread(_objectSpread({}, kvp), {}, {\n    o: kvp.o.replace(PAQO, 'paqo')\n  })));\n};\nconst withSearch = options => WrappedComponent => {\n  const {\n    inputDelay = 1000\n  } = options || {};\n  function WithSearch(props) {\n    var _urlQuery$find, _data$facets, _data$facets2, _data$query6, _data$query7, _querystringResults$i, _querystringResults$i2, _querystringResults$i3;\n    const {\n      data,\n      id,\n      editable = false\n    } = props;\n    const [locationSearchData, setLocationSearchData] = useSearchBlockState(id, editable);\n    const urlQuery = locationSearchData.query ? deserializeQuery(locationSearchData.query) : [];\n    const urlSearchText = locationSearchData.SearchableText || ((_urlQuery$find = urlQuery.find(({\n      i\n    }) => i === 'SearchableText')) === null || _urlQuery$find === void 0 ? void 0 : _urlQuery$find.v) || '';\n\n    // TODO: refactor, should use only useLocationStateManager()!!!\n    const [searchText, setSearchText] = React.useState(urlSearchText);\n    const configuredFacets = ((_data$facets = data.facets) === null || _data$facets === void 0 ? void 0 : _data$facets.map(facet => {\n      var _facet$field;\n      return facet === null || facet === void 0 ? void 0 : (_facet$field = facet.field) === null || _facet$field === void 0 ? void 0 : _facet$field.value;\n    })) || [];\n    const multiFacets = (_data$facets2 = data.facets) === null || _data$facets2 === void 0 ? void 0 : _data$facets2.filter(facet => facet === null || facet === void 0 ? void 0 : facet.multiple).map(facet => {\n      var _facet$field2;\n      return facet === null || facet === void 0 ? void 0 : (_facet$field2 = facet.field) === null || _facet$field2 === void 0 ? void 0 : _facet$field2.value;\n    });\n    const [facets, setFacets] = React.useState(Object.assign({}, ...urlQuery.map(({\n      i,\n      v\n    }) => ({\n      [i]: v\n    })),\n    // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n\n    // support for simple filters like ?Subject=something\n    // TODO: since the move to hash params this is no longer working.\n    // We'd have to treat the location.search and manage it just like the\n    // hash, to support it. We can read it, but we'd have to reset it as\n    // well, so at that point what's the difference to the hash?\n    ...configuredFacets.map(f => locationSearchData[f] ? {\n      [f]: multiFacets.indexOf(f) > -1 ? [locationSearchData[f]] : locationSearchData[f]\n    } : {})));\n    const [sortOn, setSortOn] = React.useState(data === null || data === void 0 ? void 0 : (_data$query6 = data.query) === null || _data$query6 === void 0 ? void 0 : _data$query6.sort_on);\n    const [sortOrder, setSortOrder] = React.useState(data === null || data === void 0 ? void 0 : (_data$query7 = data.query) === null || _data$query7 === void 0 ? void 0 : _data$query7.sort_order);\n    const [searchData, setSearchData] = React.useState(getInitialState(data, facets, urlSearchText, id));\n    const timeoutRef = React.useRef();\n    const facetSettings = data === null || data === void 0 ? void 0 : data.facets;\n    const onTriggerSearch = React.useCallback((toSearchText, toSearchFacets, toSortOn, toSortOrder) => {\n      if (timeoutRef.current) clearTimeout(timeoutRef.current);\n      timeoutRef.current = setTimeout(() => {\n        const searchData = normalizeState({\n          id,\n          query: data.query || {},\n          facets: toSearchFacets || facets,\n          searchText: toSearchText,\n          sortOn: toSortOn || sortOn,\n          sortOrder: toSortOrder || sortOrder,\n          facetSettings\n        });\n        if (toSearchFacets) setFacets(toSearchFacets);\n        if (toSortOn) setSortOn(toSortOn);\n        if (toSortOrder) setSortOrder(toSortOrder);\n        setSearchData(searchData);\n        setLocationSearchData(getSearchFields(searchData));\n      }, toSearchFacets ? inputDelay / 3 : inputDelay);\n    }, [data.query, facets, id, setLocationSearchData, sortOn, sortOrder, facetSettings]);\n    const querystringResults = useSelector(state => state.querystringsearch.subrequests);\n    const totalItems = ((_querystringResults$i = querystringResults[id]) === null || _querystringResults$i === void 0 ? void 0 : _querystringResults$i.total) || ((_querystringResults$i2 = querystringResults[id]) === null || _querystringResults$i2 === void 0 ? void 0 : (_querystringResults$i3 = _querystringResults$i2.items) === null || _querystringResults$i3 === void 0 ? void 0 : _querystringResults$i3.length);\n    return __jsx(WrappedComponent, _extends({}, props, {\n      searchData: searchData,\n      facets: facets,\n      setFacets: setFacets,\n      setSortOn: setSortOn,\n      setSortOrder: setSortOrder,\n      sortOn: sortOn,\n      sortOrder: sortOrder,\n      searchedText: urlSearchText,\n      searchText: searchText,\n      setSearchText: setSearchText,\n      onTriggerSearch: onTriggerSearch,\n      totalItems: totalItems,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 322,\n        columnNumber: 7\n      }\n    }));\n  }\n  WithSearch.displayName = `WithSearch(${getDisplayName(WrappedComponent)})`;\n  return WithSearch;\n};\nexport default withSearch;","map":{"version":3,"names":["React","useSelector","qs","useLocation","useHistory","resolveExtension","config","getDisplayName","WrappedComponent","displayName","name","SEARCH_ENDPOINT_FIELDS","PAQO","getInitialState","data","facets","urlSearchText","id","types","facetWidgetTypes","blocks","blocksConfig","search","extensions","facetWidgets","facetSettings","query","map","facet","field","valueToQuery","value","filter","f","i","o","v","sort_on","sort_order","b_size","limit","block","normalizeState","searchText","sortOn","sortOrder","params","reduce","acc","kvp","push","getSearchFields","searchData","Object","assign","k","serializeQuery","useHashState","location","history","oldState","useMemo","parse","hash","current","Array","from","keys","setSearchData","useCallback","newParams","changed","sort","forEach","stringify","useSearchBlockState","uniqueId","isEditMode","hashState","setHashState","internalState","setInternalState","useState","deserializeQuery","q","JSON","replace","withSearch","options","inputDelay","WithSearch","props","editable","locationSearchData","setLocationSearchData","urlQuery","SearchableText","find","setSearchText","configuredFacets","multiFacets","multiple","setFacets","indexOf","setSortOn","setSortOrder","timeoutRef","useRef","onTriggerSearch","toSearchText","toSearchFacets","toSortOn","toSortOrder","clearTimeout","setTimeout","querystringResults","state","querystringsearch","subrequests","totalItems","total","items","length"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/components/manage/Blocks/Search/hocs/withSearch.jsx"],"sourcesContent":["import React from 'react';\nimport { useSelector } from 'react-redux';\nimport qs from 'query-string';\nimport { useLocation, useHistory } from 'react-router-dom';\n\nimport { resolveExtension } from '@plone/volto/helpers/Extensions/withBlockExtensions';\nimport config from '@plone/volto/registry';\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nconst SEARCH_ENDPOINT_FIELDS = [\n  'SearchableText',\n  'b_size',\n  'limit',\n  'sort_on',\n  'sort_order',\n];\n\nconst PAQO = 'plone.app.querystring.operation';\n\n/**\n * Based on URL state, gets an initial internal state for the search\n *\n * @function getInitialState\n *\n */\nfunction getInitialState(data, facets, urlSearchText, id) {\n  const {\n    types: facetWidgetTypes,\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const facetSettings = data?.facets || [];\n\n  return {\n    query: [\n      ...(data.query?.query || []),\n      ...(facetSettings || [])\n        .map((facet) => {\n          if (!facet?.field) return null;\n\n          const { valueToQuery } = resolveExtension(\n            'type',\n            facetWidgetTypes,\n            facet,\n          );\n\n          const name = facet.field.value;\n          const value = facets[name];\n\n          return valueToQuery({ value, facet });\n        })\n        .filter((f) => !!f),\n      ...(urlSearchText\n        ? [\n            {\n              i: 'SearchableText',\n              o: 'plone.app.querystring.operation.string.contains',\n              v: urlSearchText,\n            },\n          ]\n        : []),\n    ],\n    sort_on: data.query?.sort_on,\n    sort_order: data.query?.sort_order,\n    b_size: data.query?.b_size,\n    limit: data.query?.limit,\n    block: id,\n  };\n}\n\n/**\n * \"Normalizes\" the search state to something that's serializable\n * (for querying) and used to compute data for the ListingBody\n *\n * @function normalizeState\n *\n */\nfunction normalizeState({\n  query, // base query\n  facets, // facet values\n  id, // block id\n  searchText, // SearchableText\n  sortOn,\n  sortOrder,\n  facetSettings, // data.facets extracted from block data\n}) {\n  const {\n    types: facetWidgetTypes,\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n\n  const params = {\n    query: [\n      ...(query.query || []),\n      ...(facetSettings || []).map((facet) => {\n        if (!facet?.field) return null;\n\n        const { valueToQuery } = resolveExtension(\n          'type',\n          facetWidgetTypes,\n          facet,\n        );\n\n        const name = facet.field.value;\n        const value = facets[name];\n\n        return valueToQuery({ value, facet });\n      }),\n    ].filter((o) => !!o),\n    sort_on: sortOn || query.sort_on,\n    sort_order: sortOrder || query.sort_order,\n    b_size: query.b_size,\n    limit: query.limit,\n    block: id,\n  };\n\n  // TODO: need to check if SearchableText facet is not already in the query\n  // Ideally the searchtext functionality should be restructured as being just\n  // another facet\n  params.query = params.query.reduce(\n    // Remove SearchableText from query\n    (acc, kvp) => (kvp.i === 'SearchableText' ? acc : [...acc, kvp]),\n    [],\n  );\n  if (searchText) {\n    params.query.push({\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: searchText,\n    });\n  }\n\n  return params;\n}\n\nconst getSearchFields = (searchData) => {\n  return Object.assign(\n    {},\n    ...SEARCH_ENDPOINT_FIELDS.map((k) => {\n      return searchData[k] ? { [k]: searchData[k] } : {};\n    }),\n    searchData.query ? { query: serializeQuery(searchData['query']) } : {},\n  );\n};\n\n/**\n * A HOC that will mirror the search block state to a hash location\n */\nconst useHashState = () => {\n  const location = useLocation();\n  const history = useHistory();\n\n  const oldState = React.useMemo(() => {\n    return {\n      ...qs.parse(location.search),\n      ...qs.parse(location.hash),\n    };\n  }, [location.hash, location.search]);\n\n  // This creates a shallow copy. Why is this needed?\n  const current = Object.assign(\n    {},\n    ...Array.from(Object.keys(oldState)).map((k) => ({ [k]: oldState[k] })),\n  );\n\n  const setSearchData = React.useCallback(\n    (searchData) => {\n      const newParams = qs.parse(location.hash);\n\n      let changed = false;\n\n      Object.keys(searchData)\n        .sort()\n        .forEach((k) => {\n          if (searchData[k]) {\n            newParams[k] = searchData[k];\n            if (oldState[k] !== searchData[k]) {\n              changed = true;\n            }\n          }\n        });\n\n      if (changed) {\n        history.push({\n          hash: qs.stringify(newParams),\n        });\n      }\n    },\n    [history, oldState, location.hash],\n  );\n\n  return [current, setSearchData];\n};\n\n/**\n * A hook to make it possible to switch disable mirroring the search block\n * state to the window location. When using the internal state we \"start from\n * scratch\", as it's intended to be used in the edit page.\n */\nconst useSearchBlockState = (uniqueId, isEditMode) => {\n  const [hashState, setHashState] = useHashState();\n  const [internalState, setInternalState] = React.useState({});\n\n  return isEditMode\n    ? [internalState, setInternalState]\n    : [hashState, setHashState];\n};\n\n// Simple compress/decompress the state in URL by replacing the lengthy string\nconst deserializeQuery = (q) => {\n  return JSON.parse(q)?.map((kvp) => ({\n    ...kvp,\n    o: kvp.o.replace(/^paqo/, PAQO),\n  }));\n};\nconst serializeQuery = (q) => {\n  return JSON.stringify(\n    q?.map((kvp) => ({ ...kvp, o: kvp.o.replace(PAQO, 'paqo') })),\n  );\n};\n\nconst withSearch = (options) => (WrappedComponent) => {\n  const { inputDelay = 1000 } = options || {};\n\n  function WithSearch(props) {\n    const { data, id, editable = false } = props;\n\n    const [locationSearchData, setLocationSearchData] = useSearchBlockState(\n      id,\n      editable,\n    );\n\n    const urlQuery = locationSearchData.query\n      ? deserializeQuery(locationSearchData.query)\n      : [];\n    const urlSearchText =\n      locationSearchData.SearchableText ||\n      urlQuery.find(({ i }) => i === 'SearchableText')?.v ||\n      '';\n\n    // TODO: refactor, should use only useLocationStateManager()!!!\n    const [searchText, setSearchText] = React.useState(urlSearchText);\n    const configuredFacets =\n      data.facets?.map((facet) => facet?.field?.value) || [];\n    const multiFacets = data.facets\n      ?.filter((facet) => facet?.multiple)\n      .map((facet) => facet?.field?.value);\n    const [facets, setFacets] = React.useState(\n      Object.assign(\n        {},\n        ...urlQuery.map(({ i, v }) => ({ [i]: v })), // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n\n        // support for simple filters like ?Subject=something\n        // TODO: since the move to hash params this is no longer working.\n        // We'd have to treat the location.search and manage it just like the\n        // hash, to support it. We can read it, but we'd have to reset it as\n        // well, so at that point what's the difference to the hash?\n        ...configuredFacets.map((f) =>\n          locationSearchData[f]\n            ? {\n                [f]:\n                  multiFacets.indexOf(f) > -1\n                    ? [locationSearchData[f]]\n                    : locationSearchData[f],\n              }\n            : {},\n        ),\n      ),\n    );\n\n    const [sortOn, setSortOn] = React.useState(data?.query?.sort_on);\n    const [sortOrder, setSortOrder] = React.useState(data?.query?.sort_order);\n\n    const [searchData, setSearchData] = React.useState(\n      getInitialState(data, facets, urlSearchText, id),\n    );\n\n    const timeoutRef = React.useRef();\n    const facetSettings = data?.facets;\n\n    const onTriggerSearch = React.useCallback(\n      (toSearchText, toSearchFacets, toSortOn, toSortOrder) => {\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(\n          () => {\n            const searchData = normalizeState({\n              id,\n              query: data.query || {},\n              facets: toSearchFacets || facets,\n              searchText: toSearchText,\n              sortOn: toSortOn || sortOn,\n              sortOrder: toSortOrder || sortOrder,\n              facetSettings,\n            });\n            if (toSearchFacets) setFacets(toSearchFacets);\n            if (toSortOn) setSortOn(toSortOn);\n            if (toSortOrder) setSortOrder(toSortOrder);\n            setSearchData(searchData);\n            setLocationSearchData(getSearchFields(searchData));\n          },\n          toSearchFacets ? inputDelay / 3 : inputDelay,\n        );\n      },\n      [\n        data.query,\n        facets,\n        id,\n        setLocationSearchData,\n        sortOn,\n        sortOrder,\n        facetSettings,\n      ],\n    );\n\n    const querystringResults = useSelector(\n      (state) => state.querystringsearch.subrequests,\n    );\n    const totalItems =\n      querystringResults[id]?.total || querystringResults[id]?.items?.length;\n\n    return (\n      <WrappedComponent\n        {...props}\n        searchData={searchData}\n        facets={facets}\n        setFacets={setFacets}\n        setSortOn={setSortOn}\n        setSortOrder={setSortOrder}\n        sortOn={sortOn}\n        sortOrder={sortOrder}\n        searchedText={urlSearchText}\n        searchText={searchText}\n        setSearchText={setSearchText}\n        onTriggerSearch={onTriggerSearch}\n        totalItems={totalItems}\n      />\n    );\n  }\n  WithSearch.displayName = `WithSearch(${getDisplayName(WrappedComponent)})`;\n\n  return WithSearch;\n};\n\nexport default withSearch;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}