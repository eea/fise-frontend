{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n/**\n * Vocabularies reducer.\n * @module reducers/vocabularies/vocabularies\n */\n\nimport { GET_VOCABULARY, GET_VOCABULARY_TOKEN_TITLE } from '@plone/volto/constants/ActionTypes';\nconst initialState = {};\n\n/**\n * Vocabularies reducer.\n * @function vocabularies\n * @param {Object} state Current state.\n * @param {Object} action Action to be handled.\n * @returns {Object} New state.\n */\nexport default function vocabularies(state = initialState, action = {}) {\n  var _vocabState$subreques, _vocabState$action$su, _vocabState$action$su2;\n  const vocabState = state[action.vocabulary] || {};\n  const subrequestState = action.subrequest ? ((_vocabState$subreques = vocabState.subrequests) === null || _vocabState$subreques === void 0 ? void 0 : _vocabState$subreques[action.subrequest]) || {} : {};\n  switch (action.type) {\n    case `${GET_VOCABULARY}_PENDING`:\n    case `${GET_VOCABULARY_TOKEN_TITLE}_PENDING`:\n      return action.subrequest ? _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          subrequests: _objectSpread(_objectSpread({}, vocabState.subrequests), {}, {\n            [action.subrequest]: _objectSpread(_objectSpread({}, subrequestState || {\n              data: null\n            }), {}, {\n              loaded: (vocabState === null || vocabState === void 0 ? void 0 : (_vocabState$action$su = vocabState[action.subrequest]) === null || _vocabState$action$su === void 0 ? void 0 : _vocabState$action$su.loaded) || false,\n              loading: !!(((vocabState === null || vocabState === void 0 ? void 0 : (_vocabState$action$su2 = vocabState[action.subrequest]) === null || _vocabState$action$su2 === void 0 ? void 0 : _vocabState$action$su2.loading) || 0) + 1),\n              error: null\n            })\n          })\n        })\n      }) : _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          error: null,\n          loaded: vocabState.loaded || false,\n          loading: !!((vocabState.loading || 0) + 1)\n        })\n      });\n    case `${GET_VOCABULARY}_SUCCESS`:\n      return action.subrequest ? _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          subrequests: _objectSpread(_objectSpread({}, vocabState.subrequests), {}, {\n            [action.subrequest]: _objectSpread(_objectSpread({}, subrequestState), {}, {\n              error: null,\n              loaded: true,\n              loading: !!(subrequestState.loading - 1),\n              items: [...action.result.items.map(item => ({\n                label: item.title,\n                value: item.token\n              }))],\n              batching: action.result.batching,\n              itemsTotal: action.result.items_total\n            })\n          })\n        })\n      }) : _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          error: null,\n          loaded: true,\n          loading: !!(vocabState.loading - 1),\n          items: [...action.result.items.map(item => ({\n            label: item.title,\n            value: item.token\n          }))],\n          batching: action.result.batching,\n          itemsTotal: action.result.items_total\n        })\n      });\n    case `${GET_VOCABULARY}_FAIL`:\n    case `${GET_VOCABULARY_TOKEN_TITLE}_FAIL`:\n      return action.subrequest ? _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: {\n          subrequests: _objectSpread(_objectSpread({}, vocabState.subrequests), {}, {\n            [action.subrequest]: {\n              error: action.error,\n              loaded: false,\n              loading: !!(subrequestState.loading - 1)\n            }\n          })\n        }\n      }) : _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: {\n          error: action.error,\n          loaded: false,\n          loading: !!(vocabState.loading - 1)\n        }\n      });\n    case `${GET_VOCABULARY_TOKEN_TITLE}_SUCCESS`:\n      return action.subrequest ? _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          subrequests: _objectSpread(_objectSpread({}, vocabState.subrequests), {}, {\n            [action.subrequest]: _objectSpread(_objectSpread(_objectSpread({}, subrequestState), {}, {\n              error: null,\n              loaded: true,\n              loading: !!(subrequestState.loading - 1)\n            }, action.token && {\n              [action.token]: action.result.items[0].title\n            }), action.tokens && {\n              items: [...action.result.items.map(item => ({\n                label: item.title,\n                value: item.token\n              }))]\n            })\n          })\n        })\n      }) : _objectSpread(_objectSpread({}, state), {}, {\n        [action.vocabulary]: _objectSpread(_objectSpread({}, vocabState), {}, {\n          error: null,\n          loaded: true,\n          loading: !!(vocabState.loading - 1),\n          [action.token]: action.result.items[0].title\n        })\n      });\n    default:\n      return state;\n  }\n}","map":{"version":3,"names":["GET_VOCABULARY","GET_VOCABULARY_TOKEN_TITLE","initialState","vocabularies","state","action","vocabState","vocabulary","subrequestState","subrequest","subrequests","type","data","loaded","loading","error","items","result","map","item","label","title","value","token","batching","itemsTotal","items_total","tokens"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/reducers/vocabularies/vocabularies.js"],"sourcesContent":["/**\n * Vocabularies reducer.\n * @module reducers/vocabularies/vocabularies\n */\n\nimport {\n  GET_VOCABULARY,\n  GET_VOCABULARY_TOKEN_TITLE,\n} from '@plone/volto/constants/ActionTypes';\n\nconst initialState = {};\n\n/**\n * Vocabularies reducer.\n * @function vocabularies\n * @param {Object} state Current state.\n * @param {Object} action Action to be handled.\n * @returns {Object} New state.\n */\nexport default function vocabularies(state = initialState, action = {}) {\n  const vocabState = state[action.vocabulary] || {};\n  const subrequestState = action.subrequest\n    ? vocabState.subrequests?.[action.subrequest] || {}\n    : {};\n  switch (action.type) {\n    case `${GET_VOCABULARY}_PENDING`:\n    case `${GET_VOCABULARY_TOKEN_TITLE}_PENDING`:\n      return action.subrequest\n        ? {\n            ...state,\n            [action.vocabulary]: {\n              ...vocabState,\n              subrequests: {\n                ...vocabState.subrequests,\n                [action.subrequest]: {\n                  // We preserve here the previous items array to prevent the component\n                  // to rerender due to prop changes while the PENDING state is active,\n                  // this little trick allow us to use how react-select do things\n                  // internally. This has a very low consequences since in the SUCCESS\n                  // state the items are overwritten anyways.\n                  ...(subrequestState || {\n                    data: null,\n                  }),\n                  loaded: vocabState?.[action.subrequest]?.loaded || false,\n                  loading: !!(\n                    (vocabState?.[action.subrequest]?.loading || 0) + 1\n                  ),\n                  error: null,\n                },\n              },\n            },\n          }\n        : {\n            ...state,\n            [action.vocabulary]: {\n              // We preserve here the previous items array to prevent the component\n              // to rerender due to prop changes while the PENDING state is active,\n              // this little trick allow us to use how react-select do things\n              // internally. This has a very low consequences since in the SUCCESS\n              // state the items are overwritten anyways.\n              ...vocabState,\n              error: null,\n              loaded: vocabState.loaded || false,\n              loading: !!((vocabState.loading || 0) + 1),\n            },\n          };\n    case `${GET_VOCABULARY}_SUCCESS`:\n      return action.subrequest\n        ? {\n            ...state,\n            [action.vocabulary]: {\n              ...vocabState,\n              subrequests: {\n                ...vocabState.subrequests,\n                [action.subrequest]: {\n                  ...subrequestState,\n                  error: null,\n                  loaded: true,\n                  loading: !!(subrequestState.loading - 1),\n                  items: [\n                    ...action.result.items.map((item) => ({\n                      label: item.title,\n                      value: item.token,\n                    })),\n                  ],\n                  batching: action.result.batching,\n                  itemsTotal: action.result.items_total,\n                },\n              },\n            },\n          }\n        : {\n            ...state,\n            [action.vocabulary]: {\n              ...vocabState,\n              error: null,\n              loaded: true,\n              loading: !!(vocabState.loading - 1),\n              items: [\n                ...action.result.items.map((item) => ({\n                  label: item.title,\n                  value: item.token,\n                })),\n              ],\n              batching: action.result.batching,\n              itemsTotal: action.result.items_total,\n            },\n          };\n    case `${GET_VOCABULARY}_FAIL`:\n    case `${GET_VOCABULARY_TOKEN_TITLE}_FAIL`:\n      return action.subrequest\n        ? {\n            ...state,\n            [action.vocabulary]: {\n              subrequests: {\n                ...vocabState.subrequests,\n                [action.subrequest]: {\n                  error: action.error,\n                  loaded: false,\n                  loading: !!(subrequestState.loading - 1),\n                },\n              },\n            },\n          }\n        : {\n            ...state,\n            [action.vocabulary]: {\n              error: action.error,\n              loaded: false,\n              loading: !!(vocabState.loading - 1),\n            },\n          };\n    case `${GET_VOCABULARY_TOKEN_TITLE}_SUCCESS`:\n      return action.subrequest\n        ? {\n            ...state,\n            [action.vocabulary]: {\n              ...vocabState,\n              subrequests: {\n                ...vocabState.subrequests,\n                [action.subrequest]: {\n                  ...subrequestState,\n                  error: null,\n                  loaded: true,\n                  loading: !!(subrequestState.loading - 1),\n                  ...(action.token && {\n                    [action.token]: action.result.items[0].title,\n                  }),\n                  ...(action.tokens && {\n                    items: [\n                      ...action.result.items.map((item) => ({\n                        label: item.title,\n                        value: item.token,\n                      })),\n                    ],\n                  }),\n                },\n              },\n            },\n          }\n        : {\n            ...state,\n            [action.vocabulary]: {\n              ...vocabState,\n              error: null,\n              loaded: true,\n              loading: !!(vocabState.loading - 1),\n              [action.token]: action.result.items[0].title,\n            },\n          };\n    default:\n      return state;\n  }\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}