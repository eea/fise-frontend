{"ast":null,"code":"import _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _createForOfIteratorHelper from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _first from \"lodash/first\";\nimport _some from \"lodash/some\";\nimport _includes from \"lodash/includes\";\nimport _find from \"lodash/find\";\n/* eslint no-console: [\"error\", { allow: [\"error\", \"warn\"] }] */\nimport { Editor, Transforms } from 'slate'; // Range, RangeRef\nimport config from '@plone/volto/registry';\nimport { getBlocksFieldname, getBlocksLayoutFieldname } from '@plone/volto/helpers';\nimport { makeEditor } from './editor';\n\n// case sensitive; first in an inner array is the default and preffered format\n// in that array of formats\nvar formatAliases = [['strong', 'b'], ['em', 'i'], ['del', 's']];\n\n/**\n * Excerpt from Slate documentation, kept here for posterity:\n * See https://docs.slatejs.org/concepts/11-normalizing#built-in-constraints\n\n## Built-in Constraints\n\nSlate editors come with a few built-in constraints out of the box. These\nconstraints are there to make working with content much more predictable than\nstandard contenteditable. All of the built-in logic in Slate depends on these\nconstraints, so unfortunately you cannot omit them. They are...\n\n- All Element nodes must contain at least one Text descendant. If an element node\ndoes not contain any children, an empty text node will be added as its only\nchild. This constraint exists to ensure that the selection's anchor and focus\npoints (which rely on referencing text nodes) can always be placed inside any\nnode. With this, empty elements (or void elements) wouldn't be selectable.\n\n- Two adjacent texts with the same custom properties will be merged. If two\nadjacent text nodes have the same formatting, they're merged into a single text\nnode with a combined text string of the two. This exists to prevent the text\nnodes from only ever expanding in count in the document, since both adding and\nremoving formatting results in splitting text nodes.\n\n- Block nodes can only contain other blocks, or inline and text nodes. For\nexample, a paragraph block cannot have another paragraph block element and\na link inline element as children at the same time. The type of children\nallowed is determined by the first child, and any other non-conforming children\nare removed. This ensures that common richtext behaviors like \"splitting\na block in two\" function consistently.\n\n- Inline nodes cannot be the first or last child of a parent block, nor can it\nbe next to another inline node in the children array. If this is the case, an\nempty text node will be added to correct this to be in compliance with the\nconstraint.\n\n- The top-level editor node can only contain block nodes. If any of the\ntop-level children are inline or text nodes they will be removed. This ensures\nthat there are always block nodes in the editor so that behaviors like\n\"splitting a block in two\" work as expected.\n\n- These default constraints are all mandated because they make working with\nSlate documents much more predictable.\n\nAlthough these constraints are the best we've come up with now, we're always\nlooking for ways to have Slate's built-in constraints be less constraining if\npossible—as long as it keeps standard behaviors easy to reason about. If you\ncome up with a way to reduce or remove a built-in constraint with a different\napproach, we're all ears!\n *\n */\n\nexport var normalizeExternalData = function normalizeExternalData(editor, nodes) {\n  var fakeEditor = makeEditor({\n    extensions: editor._installedPlugins\n  });\n  fakeEditor.children = nodes;\n  // put all the non-blocks (e.g. images which are inline Elements) inside p-s\n  Editor.withoutNormalizing(fakeEditor, function () {\n    //for htmlSlateWidget compatibility\n    if (nodes && !Editor.isBlock(fakeEditor, nodes[0])) Transforms.wrapNodes(fakeEditor, {\n      type: 'p'\n    }, {\n      at: [],\n      match: function match(node, path) {\n        return !Editor.isEditor(node) && !Editor.isBlock(fakeEditor, node) || fakeEditor.isInline(node);\n      },\n      mode: 'highest'\n    });\n  });\n  Editor.normalize(fakeEditor, {\n    force: true\n  });\n  return fakeEditor.children;\n};\n\n/**\n * Is it text? Is it whitespace (space, newlines, tabs) ?\n *\n */\nexport var isWhitespace = function isWhitespace(c) {\n  return typeof c === 'string' && c.replace(/\\s/g, '').replace(/\\t/g, '').replace(/\\n/g, '').length === 0;\n};\nexport function createDefaultBlock(children) {\n  return {\n    type: config.settings.slate.defaultBlockType,\n    children: children || [{\n      text: ''\n    }]\n  };\n}\nexport function createEmptyParagraph() {\n  // TODO: rename to createEmptyBlock\n  return {\n    type: config.settings.slate.defaultBlockType,\n    children: [{\n      text: ''\n    }]\n  };\n}\nexport var isSingleBlockTypeActive = function isSingleBlockTypeActive(editor, format) {\n  var _Editor$nodes = Editor.nodes(editor, {\n      match: function match(n) {\n        return n.type === format;\n      }\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    match = _Editor$nodes2[0];\n  return !!match;\n};\nexport var isBlockActive = function isBlockActive(editor, format) {\n  var aliasList = _find(formatAliases, function (x) {\n    return _includes(x, format);\n  });\n  if (aliasList) {\n    var aliasFound = _some(aliasList, function (y) {\n      return isSingleBlockTypeActive(editor, y);\n    });\n    if (aliasFound) {\n      return true;\n    }\n  }\n  return isSingleBlockTypeActive(editor, format);\n};\nexport var getBlockTypeContextData = function getBlockTypeContextData(editor, format) {\n  var isActive, defaultFormat, matcher;\n  var aliasList = _find(formatAliases, function (x) {\n    return _includes(x, format);\n  });\n  if (aliasList) {\n    var aliasFound = _some(aliasList, function (y) {\n      return isSingleBlockTypeActive(editor, y);\n    });\n    if (aliasFound) {\n      isActive = true;\n      defaultFormat = _first(aliasList);\n      matcher = function matcher(n) {\n        return _includes(aliasList, n.type);\n      };\n      return {\n        isActive: isActive,\n        defaultFormat: defaultFormat,\n        matcher: matcher\n      };\n    }\n  }\n  isActive = isBlockActive(editor, format);\n  defaultFormat = format;\n  matcher = function matcher(n) {\n    return n.type === format;\n  };\n  return {\n    isActive: isActive,\n    defaultFormat: defaultFormat,\n    matcher: matcher\n  };\n};\nexport var toggleInlineFormat = function toggleInlineFormat(editor, format) {\n  var _getBlockTypeContextD = getBlockTypeContextData(editor, format),\n    isActive = _getBlockTypeContextD.isActive,\n    defaultFormat = _getBlockTypeContextD.defaultFormat,\n    matcher = _getBlockTypeContextD.matcher;\n  if (isActive) {\n    var rangeRef = Editor.rangeRef(editor, editor.selection);\n    Transforms.unwrapNodes(editor, {\n      match: matcher,\n      split: false\n    });\n    var newSel = JSON.parse(JSON.stringify(rangeRef.current));\n    Transforms.select(editor, newSel);\n    editor.setSavedSelection(newSel);\n    // editor.savedSelection = newSel;\n    return;\n  }\n\n  // `children` property is added automatically as an empty array then\n  // normalized\n  var block = {\n    type: defaultFormat\n  };\n  Transforms.wrapNodes(editor, block, {\n    split: true\n  });\n};\nexport var toggleBlock = function toggleBlock(editor, format) {\n  // We have 6 boolean variables which need to be accounted for.\n  // See https://docs.google.com/spreadsheets/d/1mVeMuqSTMABV2BhoHPrPAFjn7zUksbNgZ9AQK_dcd3U/edit?usp=sharing\n  var slate = config.settings.slate;\n  var listTypes = slate.listTypes;\n  var isListItem = isBlockActive(editor, slate.listItemType);\n  var isActive = isBlockActive(editor, format);\n  var wantsList = listTypes.includes(format);\n  // console.log({ isListItem, isActive, wantsList, format });\n\n  if (isListItem && !wantsList) {\n    toggleFormatAsListItem(editor, format);\n  } else if (isListItem && wantsList && !isActive) {\n    switchListType(editor, format);\n  } else if (!isListItem && wantsList) {\n    changeBlockToList(editor, format);\n  } else if (!isListItem && !wantsList) {\n    toggleFormat(editor, format);\n  } else if (isListItem && wantsList && isActive) {\n    toggleFormatAsListItem(editor, slate.defaultBlockType);\n  } else {\n    console.warn('toggleBlock case not covered, please examine:', {\n      wantsList: wantsList,\n      isActive: isActive,\n      isListItem: isListItem\n    });\n  }\n};\n\n/*\n * Applies a block format to a list item. Will split the list\n */\nexport var toggleFormatAsListItem = function toggleFormatAsListItem(editor, format) {\n  Transforms.setNodes(editor, {\n    type: format\n  });\n  Editor.normalize(editor);\n};\n\n/*\n * Toggles between list types by exploding the block\n */\nexport var switchListType = function switchListType(editor, format) {\n  var slate = config.settings.slate;\n  Transforms.unwrapNodes(editor, {\n    match: function match(n) {\n      return slate.listTypes.includes(n.type);\n    },\n    split: true\n  });\n  var block = {\n    type: format,\n    children: []\n  };\n  Transforms.wrapNodes(editor, block);\n};\nexport var changeBlockToList = function changeBlockToList(editor, format) {\n  var slate = config.settings.slate;\n  var _Editor$nodes3 = Editor.nodes(editor, {\n      match: function match(n) {\n        return n.type === slate.listItemType;\n      }\n    }),\n    _Editor$nodes4 = _slicedToArray(_Editor$nodes3, 1),\n    match = _Editor$nodes4[0];\n  if (!match) {\n    Transforms.setNodes(editor, {\n      type: slate.listItemType\n      // id: nanoid(8),\n    });\n  }\n\n  // `children` property is added automatically as an empty array then\n  // normalized\n  var block = {\n    type: format\n  };\n  Transforms.wrapNodes(editor, block);\n};\nexport var toggleFormat = function toggleFormat(editor, format) {\n  var slate = config.settings.slate;\n  var isActive = isBlockActive(editor, format);\n  var type = isActive ? slate.defaultBlockType : format;\n  Transforms.setNodes(editor, {\n    type: type\n  });\n};\n\n/**\n * @param {object} properties A prop received by the View component\n *  which is read by the `getBlocksFieldname` and\n * `getBlocksLayoutFieldname` Volto helpers to produce the return value.\n * @returns {Array} All the blocks data taken from the Volto form.\n */\nexport var getAllBlocks = function getAllBlocks(properties, blocks) {\n  var _properties$blocksLay;\n  var blocksFieldName = getBlocksFieldname(properties);\n  var blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  var _iterator = _createForOfIteratorHelper((properties === null || properties === void 0 ? void 0 : (_properties$blocksLay = properties[blocksLayoutFieldname]) === null || _properties$blocksLay === void 0 ? void 0 : _properties$blocksLay.items) || []),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _block$data, _block$data2;\n      var n = _step.value;\n      var block = properties[blocksFieldName][n];\n      // TODO Make this configurable via block config getBlocks\n      if (block !== null && block !== void 0 && (_block$data = block.data) !== null && _block$data !== void 0 && _block$data[blocksLayoutFieldname] && block !== null && block !== void 0 && (_block$data2 = block.data) !== null && _block$data2 !== void 0 && _block$data2[blocksFieldName]) {\n        getAllBlocks(block.data, blocks);\n      } else if (block !== null && block !== void 0 && block[blocksLayoutFieldname] && block !== null && block !== void 0 && block[blocksFieldName]) {\n        getAllBlocks(block, blocks);\n      }\n      blocks.push(_objectSpread({\n        id: n\n      }, block));\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return blocks;\n};\nexport var clearFormatting = function clearFormatting(editor) {\n  var slate = config.settings.slate;\n  Transforms.setNodes(editor, {\n    type: slate.defaultBlockType\n  });\n  Transforms.unwrapNodes(editor, {\n    match: function match(n) {\n      return n.type && n.type !== slate.defaultBlockType;\n    },\n    mode: 'all',\n    split: false\n  });\n};","map":{"version":3,"names":["Editor","Transforms","config","getBlocksFieldname","getBlocksLayoutFieldname","makeEditor","formatAliases","normalizeExternalData","editor","nodes","fakeEditor","extensions","_installedPlugins","children","withoutNormalizing","isBlock","wrapNodes","type","at","match","node","path","isEditor","isInline","mode","normalize","force","isWhitespace","c","replace","length","createDefaultBlock","settings","slate","defaultBlockType","text","createEmptyParagraph","isSingleBlockTypeActive","format","n","isBlockActive","aliasList","x","aliasFound","y","getBlockTypeContextData","isActive","defaultFormat","matcher","toggleInlineFormat","rangeRef","selection","unwrapNodes","split","newSel","JSON","parse","stringify","current","select","setSavedSelection","block","toggleBlock","listTypes","isListItem","listItemType","wantsList","includes","toggleFormatAsListItem","switchListType","changeBlockToList","toggleFormat","console","warn","setNodes","getAllBlocks","properties","blocks","blocksFieldName","blocksLayoutFieldname","items","data","push","id","clearFormatting"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-slate/src/utils/blocks.js"],"sourcesContent":["/* eslint no-console: [\"error\", { allow: [\"error\", \"warn\"] }] */\nimport { Editor, Transforms } from 'slate'; // Range, RangeRef\nimport config from '@plone/volto/registry';\nimport {\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers';\nimport _ from 'lodash';\nimport { makeEditor } from './editor';\n\n// case sensitive; first in an inner array is the default and preffered format\n// in that array of formats\nconst formatAliases = [\n  ['strong', 'b'],\n  ['em', 'i'],\n  ['del', 's'],\n];\n\n/**\n * Excerpt from Slate documentation, kept here for posterity:\n * See https://docs.slatejs.org/concepts/11-normalizing#built-in-constraints\n\n## Built-in Constraints\n\nSlate editors come with a few built-in constraints out of the box. These\nconstraints are there to make working with content much more predictable than\nstandard contenteditable. All of the built-in logic in Slate depends on these\nconstraints, so unfortunately you cannot omit them. They are...\n\n- All Element nodes must contain at least one Text descendant. If an element node\ndoes not contain any children, an empty text node will be added as its only\nchild. This constraint exists to ensure that the selection's anchor and focus\npoints (which rely on referencing text nodes) can always be placed inside any\nnode. With this, empty elements (or void elements) wouldn't be selectable.\n\n- Two adjacent texts with the same custom properties will be merged. If two\nadjacent text nodes have the same formatting, they're merged into a single text\nnode with a combined text string of the two. This exists to prevent the text\nnodes from only ever expanding in count in the document, since both adding and\nremoving formatting results in splitting text nodes.\n\n- Block nodes can only contain other blocks, or inline and text nodes. For\nexample, a paragraph block cannot have another paragraph block element and\na link inline element as children at the same time. The type of children\nallowed is determined by the first child, and any other non-conforming children\nare removed. This ensures that common richtext behaviors like \"splitting\na block in two\" function consistently.\n\n- Inline nodes cannot be the first or last child of a parent block, nor can it\nbe next to another inline node in the children array. If this is the case, an\nempty text node will be added to correct this to be in compliance with the\nconstraint.\n\n- The top-level editor node can only contain block nodes. If any of the\ntop-level children are inline or text nodes they will be removed. This ensures\nthat there are always block nodes in the editor so that behaviors like\n\"splitting a block in two\" work as expected.\n\n- These default constraints are all mandated because they make working with\nSlate documents much more predictable.\n\nAlthough these constraints are the best we've come up with now, we're always\nlooking for ways to have Slate's built-in constraints be less constraining if\npossible—as long as it keeps standard behaviors easy to reason about. If you\ncome up with a way to reduce or remove a built-in constraint with a different\napproach, we're all ears!\n *\n */\n\nexport const normalizeExternalData = (editor, nodes) => {\n  let fakeEditor = makeEditor({ extensions: editor._installedPlugins });\n  fakeEditor.children = nodes;\n  // put all the non-blocks (e.g. images which are inline Elements) inside p-s\n  Editor.withoutNormalizing(fakeEditor, () => {\n    //for htmlSlateWidget compatibility\n    if (nodes && !Editor.isBlock(fakeEditor, nodes[0]))\n      Transforms.wrapNodes(\n        fakeEditor,\n        { type: 'p' },\n        {\n          at: [],\n          match: (node, path) =>\n            (!Editor.isEditor(node) && !Editor.isBlock(fakeEditor, node)) ||\n            fakeEditor.isInline(node),\n          mode: 'highest',\n        },\n      );\n  });\n\n  Editor.normalize(fakeEditor, { force: true });\n\n  return fakeEditor.children;\n};\n\n/**\n * Is it text? Is it whitespace (space, newlines, tabs) ?\n *\n */\nexport const isWhitespace = (c) => {\n  return (\n    typeof c === 'string' &&\n    c.replace(/\\s/g, '').replace(/\\t/g, '').replace(/\\n/g, '').length === 0\n  );\n};\n\nexport function createDefaultBlock(children) {\n  return {\n    type: config.settings.slate.defaultBlockType,\n    children: children || [{ text: '' }],\n  };\n}\n\nexport function createEmptyParagraph() {\n  // TODO: rename to createEmptyBlock\n  return {\n    type: config.settings.slate.defaultBlockType,\n    children: [{ text: '' }],\n  };\n}\n\nexport const isSingleBlockTypeActive = (editor, format) => {\n  const [match] = Editor.nodes(editor, {\n    match: (n) => n.type === format,\n  });\n\n  return !!match;\n};\n\nexport const isBlockActive = (editor, format) => {\n  const aliasList = _.find(formatAliases, (x) => _.includes(x, format));\n\n  if (aliasList) {\n    const aliasFound = _.some(aliasList, (y) => {\n      return isSingleBlockTypeActive(editor, y);\n    });\n\n    if (aliasFound) {\n      return true;\n    }\n  }\n\n  return isSingleBlockTypeActive(editor, format);\n};\n\nexport const getBlockTypeContextData = (editor, format) => {\n  let isActive, defaultFormat, matcher;\n\n  const aliasList = _.find(formatAliases, (x) => _.includes(x, format));\n\n  if (aliasList) {\n    const aliasFound = _.some(aliasList, (y) => {\n      return isSingleBlockTypeActive(editor, y);\n    });\n\n    if (aliasFound) {\n      isActive = true;\n      defaultFormat = _.first(aliasList);\n      matcher = (n) => _.includes(aliasList, n.type);\n\n      return { isActive, defaultFormat, matcher };\n    }\n  }\n\n  isActive = isBlockActive(editor, format);\n  defaultFormat = format;\n  matcher = (n) => n.type === format;\n\n  return { isActive, defaultFormat, matcher };\n};\n\nexport const toggleInlineFormat = (editor, format) => {\n  const { isActive, defaultFormat, matcher } = getBlockTypeContextData(\n    editor,\n    format,\n  );\n\n  if (isActive) {\n    const rangeRef = Editor.rangeRef(editor, editor.selection);\n\n    Transforms.unwrapNodes(editor, {\n      match: matcher,\n      split: false,\n    });\n\n    const newSel = JSON.parse(JSON.stringify(rangeRef.current));\n\n    Transforms.select(editor, newSel);\n    editor.setSavedSelection(newSel);\n    // editor.savedSelection = newSel;\n    return;\n  }\n\n  // `children` property is added automatically as an empty array then\n  // normalized\n  const block = { type: defaultFormat };\n  Transforms.wrapNodes(editor, block, { split: true });\n};\n\nexport const toggleBlock = (editor, format) => {\n  // We have 6 boolean variables which need to be accounted for.\n  // See https://docs.google.com/spreadsheets/d/1mVeMuqSTMABV2BhoHPrPAFjn7zUksbNgZ9AQK_dcd3U/edit?usp=sharing\n  const { slate } = config.settings;\n  const { listTypes } = slate;\n\n  const isListItem = isBlockActive(editor, slate.listItemType);\n  const isActive = isBlockActive(editor, format);\n  const wantsList = listTypes.includes(format);\n  // console.log({ isListItem, isActive, wantsList, format });\n\n  if (isListItem && !wantsList) {\n    toggleFormatAsListItem(editor, format);\n  } else if (isListItem && wantsList && !isActive) {\n    switchListType(editor, format);\n  } else if (!isListItem && wantsList) {\n    changeBlockToList(editor, format);\n  } else if (!isListItem && !wantsList) {\n    toggleFormat(editor, format);\n  } else if (isListItem && wantsList && isActive) {\n    toggleFormatAsListItem(editor, slate.defaultBlockType);\n  } else {\n    console.warn('toggleBlock case not covered, please examine:', {\n      wantsList,\n      isActive,\n      isListItem,\n    });\n  }\n};\n\n/*\n * Applies a block format to a list item. Will split the list\n */\nexport const toggleFormatAsListItem = (editor, format) => {\n  Transforms.setNodes(editor, {\n    type: format,\n  });\n\n  Editor.normalize(editor);\n};\n\n/*\n * Toggles between list types by exploding the block\n */\nexport const switchListType = (editor, format) => {\n  const { slate } = config.settings;\n  Transforms.unwrapNodes(editor, {\n    match: (n) => slate.listTypes.includes(n.type),\n    split: true,\n  });\n  const block = { type: format, children: [] };\n  Transforms.wrapNodes(editor, block);\n};\n\nexport const changeBlockToList = (editor, format) => {\n  const { slate } = config.settings;\n  const [match] = Editor.nodes(editor, {\n    match: (n) => n.type === slate.listItemType,\n  });\n\n  if (!match) {\n    Transforms.setNodes(editor, {\n      type: slate.listItemType,\n      // id: nanoid(8),\n    });\n  }\n\n  // `children` property is added automatically as an empty array then\n  // normalized\n  const block = { type: format };\n  Transforms.wrapNodes(editor, block);\n};\n\nexport const toggleFormat = (editor, format) => {\n  const { slate } = config.settings;\n  const isActive = isBlockActive(editor, format);\n  const type = isActive ? slate.defaultBlockType : format;\n  Transforms.setNodes(editor, {\n    type,\n  });\n};\n\n/**\n * @param {object} properties A prop received by the View component\n *  which is read by the `getBlocksFieldname` and\n * `getBlocksLayoutFieldname` Volto helpers to produce the return value.\n * @returns {Array} All the blocks data taken from the Volto form.\n */\nexport const getAllBlocks = (properties, blocks) => {\n  const blocksFieldName = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  for (const n of properties?.[blocksLayoutFieldname]?.items || []) {\n    const block = properties[blocksFieldName][n];\n    // TODO Make this configurable via block config getBlocks\n    if (\n      block?.data?.[blocksLayoutFieldname] &&\n      block?.data?.[blocksFieldName]\n    ) {\n      getAllBlocks(block.data, blocks);\n    } else if (block?.[blocksLayoutFieldname] && block?.[blocksFieldName]) {\n      getAllBlocks(block, blocks);\n    }\n    blocks.push({\n      id: n,\n      ...block,\n    });\n  }\n  return blocks;\n};\n\nexport const clearFormatting = (editor) => {\n  const { slate } = config.settings;\n  Transforms.setNodes(editor, {\n    type: slate.defaultBlockType,\n  });\n  Transforms.unwrapNodes(editor, {\n    match: (n) => n.type && n.type !== slate.defaultBlockType,\n    mode: 'all',\n    split: false,\n  });\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}