{"ast":null,"code":"import _extends from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/extends.js\";\nimport _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _classCallCheck from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nvar _excluded = [\"reduxConnectStore\"],\n  _excluded2 = [\"context\"];\nvar _jsxFileName = \"/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/AsyncConnect/AsyncConnect.jsx\",\n  _this4 = this;\nvar __jsx = React.createElement;\n/* eslint-disable react/forbid-prop-types,react/no-unused-prop-types,react/require-default-props */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Route } from 'react-router';\nimport { renderRoutes } from 'react-router-config';\nimport { ReactReduxContext } from 'react-redux';\nimport { loadAsyncConnect } from './ssr';\nimport { getMutableState } from './utils';\nexport var AsyncConnect = /*#__PURE__*/function (_Component) {\n  _inherits(AsyncConnect, _Component);\n  var _super = _createSuper(AsyncConnect);\n  function AsyncConnect(props) {\n    var _this;\n    _classCallCheck(this, AsyncConnect);\n    _this = _super.call(this, props);\n    _this.state = {\n      previousLocation: _this.isLoaded() ? null : props.location\n    };\n    _this.mounted = false;\n    _this.loadDataCounter = 0;\n    return _this;\n  }\n  _createClass(AsyncConnect, [{\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.mounted = true;\n      var dataLoaded = this.isLoaded();\n\n      // we dont need it if we already made it on server-side\n      if (!dataLoaded) {\n        this.loadAsyncData(this.props);\n      }\n    }\n  }, {\n    key: \"UNSAFE_componentWillReceiveProps\",\n    value: function UNSAFE_componentWillReceiveProps(nextProps) {\n      // eslint-disable-line camelcase\n      var _this$props = this.props,\n        location = _this$props.location,\n        reloadOnPropsChange = _this$props.reloadOnPropsChange;\n      var navigated = location !== nextProps.location;\n\n      // Allow a user supplied function to determine if an async reload is necessary\n      if (navigated && reloadOnPropsChange(this.props, nextProps)) {\n        this.loadAsyncData(nextProps);\n      }\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.mounted = false;\n    }\n  }, {\n    key: \"isLoaded\",\n    value: function isLoaded() {\n      var reduxConnectStore = this.props.reduxConnectStore;\n      return getMutableState(reduxConnectStore.getState()).reduxAsyncConnect.loaded;\n    }\n  }, {\n    key: \"loadAsyncData\",\n    value: function loadAsyncData(_ref) {\n      var _this2 = this;\n      var reduxConnectStore = _ref.reduxConnectStore,\n        otherProps = _objectWithoutProperties(_ref, _excluded);\n      var _this$props2 = this.props,\n        location = _this$props2.location,\n        beginGlobalLoad = _this$props2.beginGlobalLoad,\n        endGlobalLoad = _this$props2.endGlobalLoad;\n      var loadResult = loadAsyncConnect(_objectSpread(_objectSpread({}, otherProps), {}, {\n        store: reduxConnectStore\n      }));\n      this.setState({\n        previousLocation: location\n      });\n\n      // TODO: think of a better solution to a problem?\n      this.loadDataCounter += 1;\n      beginGlobalLoad();\n      return function (loadDataCounterOriginal) {\n        return loadResult.then(function () {\n          // We need to change propsToShow only if loadAsyncData that called this promise\n          // is the last invocation of loadAsyncData method. Otherwise we can face a situation\n          // when user is changing route several times and we finally show him route that has\n          // loaded props last time and not the last called route\n          if (_this2.loadDataCounter === loadDataCounterOriginal && _this2.mounted !== false) {\n            _this2.setState({\n              previousLocation: null\n            });\n          }\n\n          // TODO: investigate race conditions\n          // do we need to call this if it's not last invocation?\n          endGlobalLoad();\n        });\n      }(this.loadDataCounter);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n      var previousLocation = this.state.previousLocation;\n      var _this$props3 = this.props,\n        location = _this$props3.location,\n        _render = _this$props3.render;\n      return __jsx(Route, {\n        location: previousLocation || location,\n        render: function render() {\n          return _render(_this3.props);\n        },\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 89,\n          columnNumber: 7\n        }\n      });\n    }\n  }]);\n  return AsyncConnect;\n}(Component);\nAsyncConnect.propTypes = {\n  render: PropTypes.func,\n  beginGlobalLoad: PropTypes.func.isRequired,\n  endGlobalLoad: PropTypes.func.isRequired,\n  reloadOnPropsChange: PropTypes.func,\n  routes: PropTypes.array.isRequired,\n  location: PropTypes.object.isRequired,\n  match: PropTypes.object.isRequired,\n  helpers: PropTypes.any,\n  reduxConnectStore: PropTypes.object.isRequired\n};\nAsyncConnect.defaultProps = {\n  helpers: {},\n  reloadOnPropsChange: function reloadOnPropsChange() {\n    return true;\n  },\n  render: function render(_ref2) {\n    var routes = _ref2.routes;\n    return renderRoutes(routes);\n  }\n};\nexport var AsyncConnectWithContext = function AsyncConnectWithContext(_ref3) {\n  var context = _ref3.context,\n    otherProps = _objectWithoutProperties(_ref3, _excluded2);\n  var Context = context || ReactReduxContext;\n  if (Context == null) {\n    throw new Error('Please upgrade to react-redux v6');\n  }\n  return __jsx(Context.Consumer, {\n    __self: _this4,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 5\n    }\n  }, function (_ref4) {\n    var reduxConnectStore = _ref4.store;\n    return __jsx(AsyncConnect, _extends({\n      reduxConnectStore: reduxConnectStore\n    }, otherProps, {\n      __self: _this4,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 129,\n        columnNumber: 9\n      }\n    }));\n  });\n};\n_c = AsyncConnectWithContext;\nAsyncConnectWithContext.propTypes = {\n  context: PropTypes.object\n};\nvar _c;\n$RefreshReg$(_c, \"AsyncConnectWithContext\");","map":{"version":3,"names":["React","Component","PropTypes","Route","renderRoutes","ReactReduxContext","loadAsyncConnect","getMutableState","AsyncConnect","props","state","previousLocation","isLoaded","location","mounted","loadDataCounter","dataLoaded","loadAsyncData","nextProps","reloadOnPropsChange","navigated","reduxConnectStore","getState","reduxAsyncConnect","loaded","otherProps","beginGlobalLoad","endGlobalLoad","loadResult","store","setState","loadDataCounterOriginal","then","render","propTypes","func","isRequired","routes","array","object","match","helpers","any","defaultProps","AsyncConnectWithContext","context","Context","Error"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/AsyncConnect/AsyncConnect.jsx"],"sourcesContent":["/* eslint-disable react/forbid-prop-types,react/no-unused-prop-types,react/require-default-props */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Route } from 'react-router';\nimport { renderRoutes } from 'react-router-config';\nimport { ReactReduxContext } from 'react-redux';\nimport { loadAsyncConnect } from './ssr';\nimport { getMutableState } from './utils';\n\nexport class AsyncConnect extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      previousLocation: this.isLoaded() ? null : props.location,\n    };\n\n    this.mounted = false;\n    this.loadDataCounter = 0;\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n    const dataLoaded = this.isLoaded();\n\n    // we dont need it if we already made it on server-side\n    if (!dataLoaded) {\n      this.loadAsyncData(this.props);\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    // eslint-disable-line camelcase\n    const { location, reloadOnPropsChange } = this.props;\n    const navigated = location !== nextProps.location;\n\n    // Allow a user supplied function to determine if an async reload is necessary\n    if (navigated && reloadOnPropsChange(this.props, nextProps)) {\n      this.loadAsyncData(nextProps);\n    }\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  isLoaded() {\n    const { reduxConnectStore } = this.props;\n    return getMutableState(reduxConnectStore.getState()).reduxAsyncConnect\n      .loaded;\n  }\n\n  loadAsyncData({ reduxConnectStore, ...otherProps }) {\n    const { location, beginGlobalLoad, endGlobalLoad } = this.props;\n    const loadResult = loadAsyncConnect({\n      ...otherProps,\n      store: reduxConnectStore,\n    });\n\n    this.setState({ previousLocation: location });\n\n    // TODO: think of a better solution to a problem?\n    this.loadDataCounter += 1;\n    beginGlobalLoad();\n    return ((loadDataCounterOriginal) =>\n      loadResult.then(() => {\n        // We need to change propsToShow only if loadAsyncData that called this promise\n        // is the last invocation of loadAsyncData method. Otherwise we can face a situation\n        // when user is changing route several times and we finally show him route that has\n        // loaded props last time and not the last called route\n        if (\n          this.loadDataCounter === loadDataCounterOriginal &&\n          this.mounted !== false\n        ) {\n          this.setState({ previousLocation: null });\n        }\n\n        // TODO: investigate race conditions\n        // do we need to call this if it's not last invocation?\n        endGlobalLoad();\n      }))(this.loadDataCounter);\n  }\n\n  render() {\n    const { previousLocation } = this.state;\n    const { location, render } = this.props;\n\n    return (\n      <Route\n        location={previousLocation || location}\n        render={() => render(this.props)}\n      />\n    );\n  }\n}\n\nAsyncConnect.propTypes = {\n  render: PropTypes.func,\n  beginGlobalLoad: PropTypes.func.isRequired,\n  endGlobalLoad: PropTypes.func.isRequired,\n  reloadOnPropsChange: PropTypes.func,\n  routes: PropTypes.array.isRequired,\n  location: PropTypes.object.isRequired,\n  match: PropTypes.object.isRequired,\n  helpers: PropTypes.any,\n  reduxConnectStore: PropTypes.object.isRequired,\n};\n\nAsyncConnect.defaultProps = {\n  helpers: {},\n  reloadOnPropsChange() {\n    return true;\n  },\n  render({ routes }) {\n    return renderRoutes(routes);\n  },\n};\n\nexport const AsyncConnectWithContext = ({ context, ...otherProps }) => {\n  const Context = context || ReactReduxContext;\n\n  if (Context == null) {\n    throw new Error('Please upgrade to react-redux v6');\n  }\n\n  return (\n    <Context.Consumer>\n      {({ store: reduxConnectStore }) => (\n        <AsyncConnect reduxConnectStore={reduxConnectStore} {...otherProps} />\n      )}\n    </Context.Consumer>\n  );\n};\n\nAsyncConnectWithContext.propTypes = {\n  context: PropTypes.object,\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}