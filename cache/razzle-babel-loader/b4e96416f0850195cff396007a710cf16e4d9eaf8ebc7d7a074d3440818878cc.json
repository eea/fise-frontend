{"ast":null,"code":"import _isEqual from \"lodash/isEqual\";\nvar _jsxFileName = \"/home/tooler/code/work/forests-frontend/src/develop/volto-slate/src/editor/SlateEditor.jsx\",\n  _window;\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nimport ReactDOM from 'react-dom';\nimport cx from 'classnames';\nimport { Transforms, Editor } from 'slate'; // , Transforms\nimport { Slate, Editable, ReactEditor } from 'slate-react';\nimport React, { Component } from 'react'; // , useState\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\nimport config from '@plone/volto/registry';\nimport { Element, Leaf } from './render';\nimport withTestingFeatures from './extensions/withTestingFeatures';\nimport { makeEditor, toggleInlineFormat, toggleMark, parseDefaultSelection } from 'volto-slate/utils';\nimport { InlineToolbar } from './ui';\nimport EditorContext from './EditorContext';\nimport isHotkey from 'is-hotkey';\nimport './less/editor.less';\nimport Toolbar from './ui/Toolbar';\nconst handleHotKeys = (editor, event, config) => {\n  let wasHotkey = false;\n  for (const hk of Object.entries(config.hotkeys)) {\n    const [shortcut, {\n      format,\n      type\n    }] = hk;\n    if (isHotkey(shortcut, event)) {\n      event.preventDefault();\n      if (type === 'inline') {\n        toggleInlineFormat(editor, format);\n      } else {\n        // type === 'mark'\n        toggleMark(editor, format);\n      }\n      wasHotkey = true;\n    }\n  }\n  return wasHotkey;\n};\n\n// TODO: implement onFocus\nclass SlateEditor extends Component {\n  constructor(props) {\n    super(props);\n    this.createEditor = this.createEditor.bind(this);\n    this.multiDecorator = this.multiDecorator.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.getSavedSelection = this.getSavedSelection.bind(this);\n    this.setSavedSelection = this.setSavedSelection.bind(this);\n    this.savedSelection = null;\n    const uid = uuid(); // used to namespace the editor's plugins\n\n    this.slateSettings = props.slateSettings || config.settings.slate;\n    this.state = {\n      editor: this.createEditor(uid),\n      showExpandedToolbar: this.slateSettings.showExpandedToolbar,\n      internalValue: this.props.value || this.slateSettings.defaultValue(),\n      uid\n    };\n    this.editor = null;\n    this.selectionTimeout = null;\n  }\n  getSavedSelection() {\n    return this.savedSelection;\n  }\n  setSavedSelection(selection) {\n    this.savedSelection = selection;\n  }\n  createEditor(uid) {\n    // extensions are \"editor plugins\" or \"editor wrappers\". It's a similar\n    // similar to OOP inheritance, where a callable creates a new copy of the\n    // editor, while replacing or adding new capabilities to that editor.\n    // Extensions are purely JS, no React components.\n    const editor = makeEditor({\n      extensions: this.props.extensions\n    });\n\n    // When the editor loses focus it no longer has a valid selections. This\n    // makes it impossible to have complex types of interactions (like filling\n    // in another text box, operating a select menu, etc). For this reason we\n    // save the active selection\n\n    editor.getSavedSelection = this.getSavedSelection;\n    editor.setSavedSelection = this.setSavedSelection;\n    editor.uid = uid || this.state.uid;\n    return editor;\n  }\n  handleChange(value) {\n    ReactDOM.unstable_batchedUpdates(() => {\n      this.setState({\n        internalValue: value\n      });\n      if (this.props.onChange && !_isEqual(value, this.props.value)) {\n        this.props.onChange(value, this.editor);\n      }\n    });\n  }\n  multiDecorator([node, path]) {\n    // Decorations (such as higlighting node types, selection, etc).\n    const {\n      runtimeDecorators = []\n    } = this.slateSettings;\n    return runtimeDecorators.reduce((acc, deco) => deco(this.state.editor, [node, path], acc), []);\n  }\n  componentDidMount() {\n    // watch the dom change\n\n    if (this.props.selected) {\n      let focused = true;\n      try {\n        focused = ReactEditor.isFocused(this.state.editor);\n      } catch {}\n      if (!focused) {\n        setTimeout(() => {\n          try {\n            ReactEditor.focus(this.state.editor);\n          } catch {}\n        }, 100); // flush\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.isUnmounted = true;\n  }\n  componentDidUpdate(prevProps) {\n    if (!_isEqual(prevProps.extensions, this.props.extensions)) {\n      this.setState({\n        editor: this.createEditor()\n      });\n      return;\n    }\n    if (this.props.value && !_isEqual(this.props.value, this.state.internalValue)) {\n      const {\n        editor\n      } = this.state;\n      editor.children = this.props.value;\n      if (this.props.defaultSelection) {\n        const selection = parseDefaultSelection(editor, this.props.defaultSelection);\n        ReactEditor.focus(editor);\n        Transforms.select(editor, selection);\n      }\n      this.setState({\n        // editor,\n        internalValue: this.props.value\n      });\n      return;\n    }\n    const {\n      editor\n    } = this.state;\n    if (!prevProps.selected && this.props.selected) {\n      // if the SlateEditor becomes selected from unselected\n\n      if (window.getSelection().type === 'None') {\n        // TODO: why is this condition checked?\n        Transforms.select(this.state.editor, Editor.range(this.state.editor, Editor.start(this.state.editor, [])));\n      }\n      ReactEditor.focus(this.state.editor);\n    }\n    if (this.props.selected && this.props.onUpdate) {\n      this.props.onUpdate(editor);\n    }\n  }\n  shouldComponentUpdate(nextProps, nextState) {\n    const {\n      selected = true,\n      value,\n      readOnly\n    } = nextProps;\n    const res = selected || this.props.selected !== selected || this.props.readOnly !== readOnly || !_isEqual(value, this.props.value);\n    return res;\n  }\n  render() {\n    var _this$props$value;\n    const {\n      selected,\n      placeholder,\n      onKeyDown,\n      testingEditorRef,\n      readOnly,\n      className,\n      renderExtensions = []\n    } = this.props;\n    const slateSettings = this.slateSettings;\n\n    // renderExtensions is needed because the editor is memoized, so if these\n    // extensions need an updated state (for example to insert updated\n    // blockProps) then we need to always wrap the editor with them\n    const editor = renderExtensions.reduce((acc, apply) => apply(acc), this.state.editor);\n\n    // Reset selection if field is reset\n    if (editor.selection && ((_this$props$value = this.props.value) === null || _this$props$value === void 0 ? void 0 : _this$props$value.length) === 1 && this.props.value[0].children.length === 1 && this.props.value[0].children[0].text === '') {\n      Transforms.select(editor, {\n        anchor: {\n          path: [0, 0],\n          offset: 0\n        },\n        focus: {\n          path: [0, 0],\n          offset: 0\n        }\n      });\n    }\n    this.editor = editor;\n    if (testingEditorRef) {\n      testingEditorRef.current = editor;\n    }\n\n    // debug-values are `data-` HTML attributes in withTestingFeatures HOC\n\n    return __jsx(\"div\", _extends({}, this.props['debug-values'], {\n      className: cx('slate-editor', {\n        'show-toolbar': this.state.showExpandedToolbar,\n        selected\n      }),\n      tabIndex: -1,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 248,\n        columnNumber: 7\n      }\n    }), __jsx(EditorContext.Provider, {\n      value: editor,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 256,\n        columnNumber: 9\n      }\n    }, __jsx(Slate, {\n      editor: editor,\n      value: this.props.value || slateSettings.defaultValue(),\n      onChange: this.handleChange,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 257,\n        columnNumber: 11\n      }\n    }, selected ? __jsx(React.Fragment, null, __jsx(InlineToolbar, {\n      editor: editor,\n      className: className,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 264,\n        columnNumber: 17\n      }\n    }), Object.keys(slateSettings.elementToolbarButtons).map((t, i) => {\n      return __jsx(Toolbar, {\n        elementType: t,\n        key: i,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 268,\n          columnNumber: 23\n        }\n      }, slateSettings.elementToolbarButtons[t].map((Btn, b) => {\n        return __jsx(Btn, {\n          editor: editor,\n          key: b,\n          __self: this,\n          __source: {\n            fileName: _jsxFileName,\n            lineNumber: 271,\n            columnNumber: 36\n          }\n        });\n      }));\n    })) : '', __jsx(Editable, {\n      tabIndex: this.props.tabIndex || 0,\n      readOnly: readOnly,\n      placeholder: placeholder,\n      renderElement: props => __jsx(Element, _extends({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 286,\n          columnNumber: 41\n        }\n      })),\n      renderLeaf: props => __jsx(Leaf, _extends({}, props, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 287,\n          columnNumber: 38\n        }\n      })),\n      decorate: this.multiDecorator,\n      spellCheck: false,\n      onBlur: () => {\n        this.props.onBlur && this.props.onBlur();\n        return null;\n      },\n      onClick: this.props.onClick,\n      onSelect: e => {\n        if (!selected && this.props.onFocus) {\n          // we can't overwrite the onFocus of Editable, as the onFocus\n          // in Slate has too much builtin behaviour that's not\n          // accessible otherwise. Instead we try to detect such an\n          // event based on observing selected state\n          if (!editor.selection) {\n            setTimeout(() => {\n              this.props.onFocus();\n            }, 100); // TODO: why 100 is chosen here?\n          }\n        }\n\n        if (this.selectionTimeout) clearTimeout(this.selectionTimeout);\n        this.selectionTimeout = setTimeout(() => {\n          if (editor.selection && !_isEqual(editor.selection, this.savedSelection) && !this.isUnmounted) {\n            this.setState(state => ({\n              update: !this.state.update\n            }));\n            this.setSavedSelection(JSON.parse(JSON.stringify(editor.selection)));\n          }\n        }, 200);\n      },\n      onKeyDown: event => {\n        const handled = handleHotKeys(editor, event, slateSettings);\n        if (handled) return;\n        onKeyDown && onKeyDown({\n          editor,\n          event\n        });\n      },\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 282,\n        columnNumber: 13\n      }\n    }), selected && slateSettings.persistentHelpers.map((Helper, i) => {\n      return __jsx(Helper, {\n        key: i,\n        editor: editor,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 330,\n          columnNumber: 24\n        }\n      });\n    }), this.props.debug ? __jsx(\"ul\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 333,\n        columnNumber: 15\n      }\n    }, __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 334,\n        columnNumber: 17\n      }\n    }, selected ? 'selected' : 'no-selected'), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 335,\n        columnNumber: 17\n      }\n    }, \"savedSelection: \", JSON.stringify(editor.getSavedSelection())), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 338,\n        columnNumber: 17\n      }\n    }, \"live selection: \", JSON.stringify(editor.selection)), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 339,\n        columnNumber: 17\n      }\n    }, \"children: \", JSON.stringify(editor.children)), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 340,\n        columnNumber: 17\n      }\n    }, \" \", selected ? 'selected' : 'notselected'), __jsx(\"li\", {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 341,\n        columnNumber: 17\n      }\n    }, ReactEditor.isFocused(editor) ? 'focused' : 'unfocused')) : '', this.props.children)));\n  }\n}\nSlateEditor.defaultProps = {\n  extensions: [],\n  className: ''\n};\nexport default connect((state, props) => {\n  return {};\n})(__CLIENT__ && (_window = window) !== null && _window !== void 0 && _window.Cypress ? withTestingFeatures(SlateEditor) : SlateEditor);","map":{"version":3,"names":["ReactDOM","cx","Transforms","Editor","Slate","Editable","ReactEditor","React","Component","connect","v4","uuid","config","Element","Leaf","withTestingFeatures","makeEditor","toggleInlineFormat","toggleMark","parseDefaultSelection","InlineToolbar","EditorContext","isHotkey","Toolbar","handleHotKeys","editor","event","wasHotkey","hk","Object","entries","hotkeys","shortcut","format","type","preventDefault","SlateEditor","constructor","props","createEditor","bind","multiDecorator","handleChange","getSavedSelection","setSavedSelection","savedSelection","uid","slateSettings","settings","slate","state","showExpandedToolbar","internalValue","value","defaultValue","selectionTimeout","selection","extensions","unstable_batchedUpdates","setState","onChange","node","path","runtimeDecorators","reduce","acc","deco","componentDidMount","selected","focused","isFocused","setTimeout","focus","componentWillUnmount","isUnmounted","componentDidUpdate","prevProps","children","defaultSelection","select","window","getSelection","range","start","onUpdate","shouldComponentUpdate","nextProps","nextState","readOnly","res","render","placeholder","onKeyDown","testingEditorRef","className","renderExtensions","apply","length","text","anchor","offset","current","keys","elementToolbarButtons","map","t","i","Btn","b","tabIndex","onBlur","onClick","e","onFocus","clearTimeout","update","JSON","parse","stringify","handled","persistentHelpers","Helper","debug","defaultProps","__CLIENT__","Cypress"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-slate/src/editor/SlateEditor.jsx"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport cx from 'classnames';\nimport { isEqual } from 'lodash';\nimport { Transforms, Editor } from 'slate'; // , Transforms\nimport { Slate, Editable, ReactEditor } from 'slate-react';\nimport React, { Component } from 'react'; // , useState\nimport { connect } from 'react-redux';\nimport { v4 as uuid } from 'uuid';\n\nimport config from '@plone/volto/registry';\n\nimport { Element, Leaf } from './render';\n\nimport withTestingFeatures from './extensions/withTestingFeatures';\nimport {\n  makeEditor,\n  toggleInlineFormat,\n  toggleMark,\n  parseDefaultSelection,\n} from 'volto-slate/utils';\nimport { InlineToolbar } from './ui';\nimport EditorContext from './EditorContext';\n\nimport isHotkey from 'is-hotkey';\n\nimport './less/editor.less';\n\nimport Toolbar from './ui/Toolbar';\n\nconst handleHotKeys = (editor, event, config) => {\n  let wasHotkey = false;\n\n  for (const hk of Object.entries(config.hotkeys)) {\n    const [shortcut, { format, type }] = hk;\n    if (isHotkey(shortcut, event)) {\n      event.preventDefault();\n\n      if (type === 'inline') {\n        toggleInlineFormat(editor, format);\n      } else {\n        // type === 'mark'\n        toggleMark(editor, format);\n      }\n\n      wasHotkey = true;\n    }\n  }\n\n  return wasHotkey;\n};\n\n// TODO: implement onFocus\nclass SlateEditor extends Component {\n  constructor(props) {\n    super(props);\n\n    this.createEditor = this.createEditor.bind(this);\n    this.multiDecorator = this.multiDecorator.bind(this);\n    this.handleChange = this.handleChange.bind(this);\n    this.getSavedSelection = this.getSavedSelection.bind(this);\n    this.setSavedSelection = this.setSavedSelection.bind(this);\n\n    this.savedSelection = null;\n\n    const uid = uuid(); // used to namespace the editor's plugins\n\n    this.slateSettings = props.slateSettings || config.settings.slate;\n\n    this.state = {\n      editor: this.createEditor(uid),\n      showExpandedToolbar: this.slateSettings.showExpandedToolbar,\n      internalValue: this.props.value || this.slateSettings.defaultValue(),\n      uid,\n    };\n\n    this.editor = null;\n    this.selectionTimeout = null;\n  }\n\n  getSavedSelection() {\n    return this.savedSelection;\n  }\n  setSavedSelection(selection) {\n    this.savedSelection = selection;\n  }\n\n  createEditor(uid) {\n    // extensions are \"editor plugins\" or \"editor wrappers\". It's a similar\n    // similar to OOP inheritance, where a callable creates a new copy of the\n    // editor, while replacing or adding new capabilities to that editor.\n    // Extensions are purely JS, no React components.\n    const editor = makeEditor({ extensions: this.props.extensions });\n\n    // When the editor loses focus it no longer has a valid selections. This\n    // makes it impossible to have complex types of interactions (like filling\n    // in another text box, operating a select menu, etc). For this reason we\n    // save the active selection\n\n    editor.getSavedSelection = this.getSavedSelection;\n    editor.setSavedSelection = this.setSavedSelection;\n    editor.uid = uid || this.state.uid;\n\n    return editor;\n  }\n\n  handleChange(value) {\n    ReactDOM.unstable_batchedUpdates(() => {\n      this.setState({ internalValue: value });\n      if (this.props.onChange && !isEqual(value, this.props.value)) {\n        this.props.onChange(value, this.editor);\n      }\n    });\n  }\n\n  multiDecorator([node, path]) {\n    // Decorations (such as higlighting node types, selection, etc).\n    const { runtimeDecorators = [] } = this.slateSettings;\n    return runtimeDecorators.reduce(\n      (acc, deco) => deco(this.state.editor, [node, path], acc),\n      [],\n    );\n  }\n\n  componentDidMount() {\n    // watch the dom change\n\n    if (this.props.selected) {\n      let focused = true;\n      try {\n        focused = ReactEditor.isFocused(this.state.editor);\n      } catch {}\n      if (!focused) {\n        setTimeout(() => {\n          try {\n            ReactEditor.focus(this.state.editor);\n          } catch {}\n        }, 100); // flush\n      }\n    }\n  }\n\n  componentWillUnmount() {\n    this.isUnmounted = true;\n  }\n\n  componentDidUpdate(prevProps) {\n    if (!isEqual(prevProps.extensions, this.props.extensions)) {\n      this.setState({ editor: this.createEditor() });\n      return;\n    }\n\n    if (\n      this.props.value &&\n      !isEqual(this.props.value, this.state.internalValue)\n    ) {\n      const { editor } = this.state;\n      editor.children = this.props.value;\n\n      if (this.props.defaultSelection) {\n        const selection = parseDefaultSelection(\n          editor,\n          this.props.defaultSelection,\n        );\n\n        ReactEditor.focus(editor);\n        Transforms.select(editor, selection);\n      }\n\n      this.setState({\n        // editor,\n        internalValue: this.props.value,\n      });\n      return;\n    }\n\n    const { editor } = this.state;\n\n    if (!prevProps.selected && this.props.selected) {\n      // if the SlateEditor becomes selected from unselected\n\n      if (window.getSelection().type === 'None') {\n        // TODO: why is this condition checked?\n        Transforms.select(\n          this.state.editor,\n          Editor.range(this.state.editor, Editor.start(this.state.editor, [])),\n        );\n      }\n\n      ReactEditor.focus(this.state.editor);\n    }\n\n    if (this.props.selected && this.props.onUpdate) {\n      this.props.onUpdate(editor);\n    }\n  }\n\n  shouldComponentUpdate(nextProps, nextState) {\n    const { selected = true, value, readOnly } = nextProps;\n    const res =\n      selected ||\n      this.props.selected !== selected ||\n      this.props.readOnly !== readOnly ||\n      !isEqual(value, this.props.value);\n    return res;\n  }\n\n  render() {\n    const {\n      selected,\n      placeholder,\n      onKeyDown,\n      testingEditorRef,\n      readOnly,\n      className,\n      renderExtensions = [],\n    } = this.props;\n    const slateSettings = this.slateSettings;\n\n    // renderExtensions is needed because the editor is memoized, so if these\n    // extensions need an updated state (for example to insert updated\n    // blockProps) then we need to always wrap the editor with them\n    const editor = renderExtensions.reduce(\n      (acc, apply) => apply(acc),\n      this.state.editor,\n    );\n\n    // Reset selection if field is reset\n    if (\n      editor.selection &&\n      this.props.value?.length === 1 &&\n      this.props.value[0].children.length === 1 &&\n      this.props.value[0].children[0].text === ''\n    ) {\n      Transforms.select(editor, {\n        anchor: { path: [0, 0], offset: 0 },\n        focus: { path: [0, 0], offset: 0 },\n      });\n    }\n    this.editor = editor;\n\n    if (testingEditorRef) {\n      testingEditorRef.current = editor;\n    }\n\n    // debug-values are `data-` HTML attributes in withTestingFeatures HOC\n\n    return (\n      <div\n        {...this.props['debug-values']}\n        className={cx('slate-editor', {\n          'show-toolbar': this.state.showExpandedToolbar,\n          selected,\n        })}\n        tabIndex={-1}\n      >\n        <EditorContext.Provider value={editor}>\n          <Slate\n            editor={editor}\n            value={this.props.value || slateSettings.defaultValue()}\n            onChange={this.handleChange}\n          >\n            {selected ? (\n              <>\n                <InlineToolbar editor={editor} className={className} />\n                {Object.keys(slateSettings.elementToolbarButtons).map(\n                  (t, i) => {\n                    return (\n                      <Toolbar elementType={t} key={i}>\n                        {slateSettings.elementToolbarButtons[t].map(\n                          (Btn, b) => {\n                            return <Btn editor={editor} key={b} />;\n                          },\n                        )}\n                      </Toolbar>\n                    );\n                  },\n                )}\n              </>\n            ) : (\n              ''\n            )}\n            <Editable\n              tabIndex={this.props.tabIndex || 0}\n              readOnly={readOnly}\n              placeholder={placeholder}\n              renderElement={(props) => <Element {...props} />}\n              renderLeaf={(props) => <Leaf {...props} />}\n              decorate={this.multiDecorator}\n              spellCheck={false}\n              onBlur={() => {\n                this.props.onBlur && this.props.onBlur();\n                return null;\n              }}\n              onClick={this.props.onClick}\n              onSelect={(e) => {\n                if (!selected && this.props.onFocus) {\n                  // we can't overwrite the onFocus of Editable, as the onFocus\n                  // in Slate has too much builtin behaviour that's not\n                  // accessible otherwise. Instead we try to detect such an\n                  // event based on observing selected state\n                  if (!editor.selection) {\n                    setTimeout(() => {\n                      this.props.onFocus();\n                    }, 100); // TODO: why 100 is chosen here?\n                  }\n                }\n\n                if (this.selectionTimeout) clearTimeout(this.selectionTimeout);\n                this.selectionTimeout = setTimeout(() => {\n                  if (\n                    editor.selection &&\n                    !isEqual(editor.selection, this.savedSelection) &&\n                    !this.isUnmounted\n                  ) {\n                    this.setState((state) => ({ update: !this.state.update }));\n                    this.setSavedSelection(\n                      JSON.parse(JSON.stringify(editor.selection)),\n                    );\n                  }\n                }, 200);\n              }}\n              onKeyDown={(event) => {\n                const handled = handleHotKeys(editor, event, slateSettings);\n                if (handled) return;\n                onKeyDown && onKeyDown({ editor, event });\n              }}\n            />\n            {selected &&\n              slateSettings.persistentHelpers.map((Helper, i) => {\n                return <Helper key={i} editor={editor} />;\n              })}\n            {this.props.debug ? (\n              <ul>\n                <li>{selected ? 'selected' : 'no-selected'}</li>\n                <li>\n                  savedSelection: {JSON.stringify(editor.getSavedSelection())}\n                </li>\n                <li>live selection: {JSON.stringify(editor.selection)}</li>\n                <li>children: {JSON.stringify(editor.children)}</li>\n                <li> {selected ? 'selected' : 'notselected'}</li>\n                <li>\n                  {ReactEditor.isFocused(editor) ? 'focused' : 'unfocused'}\n                </li>\n              </ul>\n            ) : (\n              ''\n            )}\n            {this.props.children}\n          </Slate>\n        </EditorContext.Provider>\n      </div>\n    );\n  }\n}\n\nSlateEditor.defaultProps = {\n  extensions: [],\n  className: '',\n};\n\nexport default connect((state, props) => {\n  return {};\n})(\n  __CLIENT__ && window?.Cypress\n    ? withTestingFeatures(SlateEditor)\n    : SlateEditor,\n);\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}