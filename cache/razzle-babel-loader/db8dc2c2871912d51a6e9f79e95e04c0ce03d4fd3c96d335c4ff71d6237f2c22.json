{"ast":null,"code":"import _remove from \"lodash/remove\";\nimport _findIndex from \"lodash/findIndex\";\nimport _find from \"lodash/find\";\nvar _jsxFileName = \"/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/components/manage/Widgets/VocabularyTermsWidget.jsx\";\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n/**\n * VocabularyTermsWidget\n * @module components/manage/Widgets/VocabularyTermsWidget\n * Widget for plone.schema.JSONField field meant for a SimpleVocabulary source\n * \n\nVOCABULARY_SCHEMA = json.dumps(\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"items\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"token\": {\"type\": \"string\"},\n                        \"titles\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                                \"lang\": {\"type\": \"string\"},\n                                \"title\": {\"type\": \"string\"},\n                            }\n                        },\n                    }\n                }\n            }\n        },\n    }\n)\n\n\nclass IPloneconfSettings(Interface):\n\n    types_of_foo = schema.JSONField(\n        title=\"Types of Foo\",\n        description=\"Available types of a foo\",\n        required=False,\n        schema=VOCABULARY_SCHEMA,\n        widget=\"vocabularyterms\",\n        default={\"items\": [\n            {\n                \"token\": \"talk\",\n                \"titles\": {\n                    \"en\": \"Talk\",\n                    \"de\": \"Vortrag\",\n                }\n            },\n            {\n                \"token\": \"lightning-talk\",\n                \"titles\": {\n                    \"en\": \"Lightning-Talk\",\n                    \"de\": \"kÃ¼rzerer erleuchtender Vortrag\",\n                }\n            },\n        ]},\n        missing_value={\"items\": []},\n    )\n\n\n@provider(IVocabularyFactory)\ndef TalkTypesVocabulary(context):\n    name = \"ploneconf.types_of_talk\"\n    registry_record_value = api.portal.get_registry_record(name)\n    items = registry_record_value.get('items', [])\n    lang = api.portal.get_current_language()\n    return SimpleVocabulary.fromItems([[item['token'], item['token'], item['titles'][lang]] for item in items])\n\n\n * titles are editable\n * tokens are generated\n * \n * Purpose: Use this widget for a controlpanel field\n * that acts as a source of a vocabulary for a zope.schema.Choice field.\n * Vocabulary terms should change over time only in title, not value,\n * as vocabulary term values are stored on content type instances.\n *\n * Apply widget with `widget='vocabularyterms'`\n * Future widget directive coming: Apply widget with directive widget\n *\n * See storybook for a demo: Run\n * `yarn storybook`\n * or see https://docs.voltocms.com/storybook/\n */\n\nimport React from 'react';\nimport { useDispatch } from 'react-redux';\nimport { defineMessages, useIntl } from 'react-intl';\nimport { v4 as uuid } from 'uuid';\nimport { Button } from 'semantic-ui-react';\nimport { DragDropList, FormFieldWrapper, Icon, ObjectWidget } from '@plone/volto/components';\nimport { langmap } from '@plone/volto/helpers';\nimport deleteSVG from '@plone/volto/icons/delete.svg';\nimport addSVG from '@plone/volto/icons/add.svg';\nimport dragSVG from '@plone/volto/icons/drag.svg';\nconst messages = defineMessages({\n  title: {\n    \"id\": \"Vocabulary terms\",\n    \"defaultMessage\": \"Vocabulary terms\"\n  },\n  termtitle: {\n    \"id\": \"Vocabulary term\",\n    \"defaultMessage\": \"Vocabulary term\"\n  },\n  addTerm: {\n    \"id\": \"Add vocabulary term\",\n    \"defaultMessage\": \"Add term\"\n  },\n  removeTerm: {\n    \"id\": \"Remove term\",\n    \"defaultMessage\": \"Remove term\"\n  },\n  clearTermTitle: {\n    \"id\": \"Reset term title\",\n    \"defaultMessage\": \"Reset title\"\n  },\n  termtitlelabel: {\n    \"id\": \"Vocabulary term title\",\n    \"defaultMessage\": \"Title\"\n  }\n});\nconst VocabularyTermsWidget = props => {\n  var _vocabularyterms$map;\n  const {\n    id,\n    value = {},\n    onChange\n  } = props;\n  var widgetvalue = value;\n  const dispatch = useDispatch();\n  const [toFocusId, setToFocusId] = React.useState('');\n  const [editableToken, setEditableToken] = React.useState('');\n  const intl = useIntl();\n  React.useEffect(() => {\n    const element = document.getElementById(toFocusId);\n    element && element.focus();\n    setToFocusId('');\n  }, [dispatch, toFocusId]);\n\n  // LEGACY: value from unordered zope.schema.Dict instead of zope.schema.JSONField\n  if (widgetvalue.items === undefined) {\n    widgetvalue = {\n      items: Object.keys(widgetvalue).map(key => {\n        return {\n          token: key,\n          titles: {\n            en: widgetvalue[key]\n          }\n        };\n      })\n    };\n  }\n  let vocabularyterms = widgetvalue.items;\n  let supportedLanguages = Object.keys((vocabularyterms === null || vocabularyterms === void 0 ? void 0 : (_vocabularyterms$map = vocabularyterms.map(el => el.titles)) === null || _vocabularyterms$map === void 0 ? void 0 : _vocabularyterms$map.pop()) || {});\n  const TermSchema = {\n    title: 'Translation of term',\n    fieldsets: [{\n      id: 'default',\n      title: 'Email',\n      fields: supportedLanguages\n    }],\n    properties: Object.fromEntries(supportedLanguages.map(languageIdentifier => {\n      var _langmap$languageIden, _langmap$languageIden2;\n      return [languageIdentifier, {\n        title: (_langmap$languageIden = (_langmap$languageIden2 = langmap[languageIdentifier]) === null || _langmap$languageIden2 === void 0 ? void 0 : _langmap$languageIden2.nativeName) !== null && _langmap$languageIden !== void 0 ? _langmap$languageIden : languageIdentifier\n      }];\n    })),\n    required: []\n  };\n  function onChangeFieldHandler(token, fieldid, fieldvalue) {\n    let index = _findIndex(widgetvalue.items, {\n      token: token\n    });\n    let newitems = widgetvalue.items;\n    newitems.splice(index, 1, {\n      token: token,\n      titles: fieldvalue\n    });\n    onChange(id, {\n      items: newitems\n    });\n  }\n  function addTermHandler(e) {\n    e.preventDefault();\n    const newtoken = uuid();\n    let newitems = widgetvalue.items;\n    newitems.push({\n      token: newtoken,\n      titles: Object.fromEntries(supportedLanguages.map(el => [el, '']))\n    });\n    onChange(id, {\n      items: newitems\n    });\n    setToFocusId(`field-${supportedLanguages[0]}-0-${id}-${newtoken}`);\n    setEditableToken(newtoken);\n  }\n  function swap(arr, from, to) {\n    arr.splice(from, 1, arr.splice(to, 1, arr[from])[0]);\n  }\n  let enhancedvocabularyterms = vocabularyterms.map(el => {\n    return _objectSpread(_objectSpread({}, el), {}, {\n      '@id': el.token\n    });\n  });\n  return __jsx(FormFieldWrapper, _extends({}, props, {\n    className: \"vocabularytermswidget dictwidget\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 222,\n      columnNumber: 5\n    }\n  }), __jsx(\"div\", {\n    className: \"add-item-button-wrapper\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 223,\n      columnNumber: 7\n    }\n  }, __jsx(Button, {\n    \"aria-label\": intl.formatMessage(messages.termtitle),\n    onClick: e => {\n      addTermHandler(e);\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 224,\n      columnNumber: 9\n    }\n  }, __jsx(Icon, {\n    name: addSVG,\n    size: \"18px\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 230,\n      columnNumber: 11\n    }\n  }), intl.formatMessage(messages.addTerm))), __jsx(DragDropList, {\n    childList: enhancedvocabularyterms.map(o => [o['@id'], o]),\n    onMoveItem: result => {\n      const {\n        source,\n        destination\n      } = result;\n      if (!destination) {\n        return;\n      }\n      let newitems = widgetvalue.items;\n      swap(newitems, source.index, destination.index);\n      onChange(id, {\n        items: newitems\n      });\n      return true;\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 234,\n      columnNumber: 7\n    }\n  }, dragProps => {\n    const {\n      child,\n      childId,\n      index\n    } = dragProps;\n    let termProps = {\n      index: index,\n      id,\n      vocabularyterms,\n      vterm: child,\n      onChange\n    };\n    return termsWrapper(dragProps, __jsx(ObjectWidget, {\n      id: `${id}-${child.token}`,\n      key: childId,\n      onChange: (fieldid, fieldvalue) => {\n        onChangeFieldHandler(child.token, fieldid, fieldvalue);\n      },\n      value: child.titles,\n      schema: TermSchema,\n      title: \"Translation of term\",\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 260,\n        columnNumber: 13\n      }\n    }), _objectSpread({\n      editableToken,\n      setEditableToken\n    }, termProps));\n  }));\n};\nconst termsWrapper = ({\n  draginfo\n}, OW, termProps) => __jsx(TermsWrapper, {\n  draginfo: draginfo,\n  termProps: termProps,\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 279,\n    columnNumber: 3\n  }\n}, OW);\nconst TermsWrapper = props => {\n  const intl = useIntl();\n  const {\n    termProps,\n    draginfo,\n    children\n  } = props;\n  const {\n    id,\n    vocabularyterms,\n    vterm,\n    onChange\n  } = termProps;\n  const _updateTermsWithNewToken = (term, newtoken) => {\n    let newitems = termProps.vocabularyterms;\n    let index = _findIndex(newitems, {\n      token: term.token\n    });\n    newitems.splice(index, 1, {\n      token: newtoken,\n      titles: newitems[index].titles\n    });\n    onChange(id, {\n      items: newitems\n    });\n  };\n  function onChangeTokenHandler(event) {\n    let value = event.target.value;\n    // required token length: 3\n    if (value.length > 2) {\n      // check if value is different from already used tokens\n      if (_find(termProps.vocabularyterms, el => el.token === value)) {\n        // token already token. Stay with uuid.\n      } else {\n        // `token '${value}' is OK`\n        _updateTermsWithNewToken(vterm, value);\n        termProps.setEditableToken('');\n      }\n    }\n  }\n  return __jsx(\"div\", _extends({\n    ref: draginfo.innerRef\n  }, draginfo.draggableProps, {\n    className: \"vocabularyterm\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 317,\n      columnNumber: 5\n    }\n  }), __jsx(\"div\", {\n    style: {\n      alignItems: 'center',\n      display: 'flex'\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 322,\n      columnNumber: 7\n    }\n  }, __jsx(\"div\", _extends({}, draginfo.dragHandleProps, {\n    className: \"draghandlewrapper\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 323,\n      columnNumber: 9\n    }\n  }), __jsx(Icon, {\n    name: dragSVG,\n    size: \"18px\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 324,\n      columnNumber: 11\n    }\n  })), __jsx(\"div\", {\n    className: \"ui drag block inner\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 326,\n      columnNumber: 9\n    }\n  }, children), __jsx(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 327,\n      columnNumber: 9\n    }\n  }, vterm.token === termProps.editableToken ? __jsx(\"input\", {\n    id: `token-${vterm.token}`,\n    title: \"Token\",\n    placeholder: \"token\",\n    onBlur: onChangeTokenHandler,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 329,\n      columnNumber: 13\n    }\n  }) : null, __jsx(Button, {\n    icon: true,\n    basic: true,\n    className: \"delete-button\",\n    title: intl.formatMessage(messages.removeTerm),\n    \"aria-label\": `${intl.formatMessage(messages.removeTerm)} #${vterm.token}`,\n    onClick: e => {\n      e.preventDefault();\n      _remove(vocabularyterms, el => el.token === vterm.token);\n      onChange(id, {\n        items: vocabularyterms\n      });\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 336,\n      columnNumber: 11\n    }\n  }, __jsx(Icon, {\n    name: deleteSVG,\n    size: \"20px\",\n    color: \"#e40166\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 350,\n      columnNumber: 13\n    }\n  })))));\n};\nexport default VocabularyTermsWidget;","map":{"version":3,"names":["React","useDispatch","defineMessages","useIntl","v4","uuid","Button","DragDropList","FormFieldWrapper","Icon","ObjectWidget","langmap","deleteSVG","addSVG","dragSVG","messages","title","termtitle","addTerm","removeTerm","clearTermTitle","termtitlelabel","VocabularyTermsWidget","props","id","value","onChange","widgetvalue","dispatch","toFocusId","setToFocusId","useState","editableToken","setEditableToken","intl","useEffect","element","document","getElementById","focus","items","undefined","Object","keys","map","key","token","titles","en","vocabularyterms","supportedLanguages","el","pop","TermSchema","fieldsets","fields","properties","fromEntries","languageIdentifier","nativeName","required","onChangeFieldHandler","fieldid","fieldvalue","index","newitems","splice","addTermHandler","e","preventDefault","newtoken","push","swap","arr","from","to","enhancedvocabularyterms","formatMessage","o","result","source","destination","dragProps","child","childId","termProps","vterm","termsWrapper","draginfo","OW","TermsWrapper","children","_updateTermsWithNewToken","term","onChangeTokenHandler","event","target","length","innerRef","draggableProps","alignItems","display","dragHandleProps"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/components/manage/Widgets/VocabularyTermsWidget.jsx"],"sourcesContent":["/**\n * VocabularyTermsWidget\n * @module components/manage/Widgets/VocabularyTermsWidget\n * Widget for plone.schema.JSONField field meant for a SimpleVocabulary source\n * \n\nVOCABULARY_SCHEMA = json.dumps(\n    {\n        \"type\": \"object\",\n        \"properties\": {\n            \"items\": {\n                \"type\": \"array\",\n                \"items\": {\n                    \"type\": \"object\",\n                    \"properties\": {\n                        \"token\": {\"type\": \"string\"},\n                        \"titles\": {\n                            \"type\": \"object\",\n                            \"properties\": {\n                                \"lang\": {\"type\": \"string\"},\n                                \"title\": {\"type\": \"string\"},\n                            }\n                        },\n                    }\n                }\n            }\n        },\n    }\n)\n\n\nclass IPloneconfSettings(Interface):\n\n    types_of_foo = schema.JSONField(\n        title=\"Types of Foo\",\n        description=\"Available types of a foo\",\n        required=False,\n        schema=VOCABULARY_SCHEMA,\n        widget=\"vocabularyterms\",\n        default={\"items\": [\n            {\n                \"token\": \"talk\",\n                \"titles\": {\n                    \"en\": \"Talk\",\n                    \"de\": \"Vortrag\",\n                }\n            },\n            {\n                \"token\": \"lightning-talk\",\n                \"titles\": {\n                    \"en\": \"Lightning-Talk\",\n                    \"de\": \"kÃ¼rzerer erleuchtender Vortrag\",\n                }\n            },\n        ]},\n        missing_value={\"items\": []},\n    )\n\n\n@provider(IVocabularyFactory)\ndef TalkTypesVocabulary(context):\n    name = \"ploneconf.types_of_talk\"\n    registry_record_value = api.portal.get_registry_record(name)\n    items = registry_record_value.get('items', [])\n    lang = api.portal.get_current_language()\n    return SimpleVocabulary.fromItems([[item['token'], item['token'], item['titles'][lang]] for item in items])\n\n\n * titles are editable\n * tokens are generated\n * \n * Purpose: Use this widget for a controlpanel field\n * that acts as a source of a vocabulary for a zope.schema.Choice field.\n * Vocabulary terms should change over time only in title, not value,\n * as vocabulary term values are stored on content type instances.\n *\n * Apply widget with `widget='vocabularyterms'`\n * Future widget directive coming: Apply widget with directive widget\n *\n * See storybook for a demo: Run\n * `yarn storybook`\n * or see https://docs.voltocms.com/storybook/\n */\n\nimport React from 'react';\nimport { useDispatch } from 'react-redux';\nimport { find, findIndex, remove } from 'lodash';\nimport { defineMessages, useIntl } from 'react-intl';\nimport { v4 as uuid } from 'uuid';\n\nimport { Button } from 'semantic-ui-react';\n\nimport {\n  DragDropList,\n  FormFieldWrapper,\n  Icon,\n  ObjectWidget,\n} from '@plone/volto/components';\nimport { langmap } from '@plone/volto/helpers';\n\nimport deleteSVG from '@plone/volto/icons/delete.svg';\nimport addSVG from '@plone/volto/icons/add.svg';\nimport dragSVG from '@plone/volto/icons/drag.svg';\n\nconst messages = defineMessages({\n  title: {\n    id: 'Vocabulary terms',\n    defaultMessage: 'Vocabulary terms',\n  },\n  termtitle: {\n    id: 'Vocabulary term',\n    defaultMessage: 'Vocabulary term',\n  },\n  addTerm: {\n    id: 'Add vocabulary term',\n    defaultMessage: 'Add term',\n  },\n  removeTerm: {\n    id: 'Remove term',\n    defaultMessage: 'Remove term',\n  },\n  clearTermTitle: {\n    id: 'Reset term title',\n    defaultMessage: 'Reset title',\n  },\n  termtitlelabel: {\n    id: 'Vocabulary term title',\n    defaultMessage: 'Title',\n  },\n});\n\nconst VocabularyTermsWidget = (props) => {\n  const { id, value = {}, onChange } = props;\n  var widgetvalue = value;\n  const dispatch = useDispatch();\n  const [toFocusId, setToFocusId] = React.useState('');\n  const [editableToken, setEditableToken] = React.useState('');\n  const intl = useIntl();\n\n  React.useEffect(() => {\n    const element = document.getElementById(toFocusId);\n    element && element.focus();\n    setToFocusId('');\n  }, [dispatch, toFocusId]);\n\n  // LEGACY: value from unordered zope.schema.Dict instead of zope.schema.JSONField\n  if (widgetvalue.items === undefined) {\n    widgetvalue = {\n      items: Object.keys(widgetvalue).map((key) => {\n        return {\n          token: key,\n          titles: {\n            en: widgetvalue[key],\n          },\n        };\n      }),\n    };\n  }\n\n  let vocabularyterms = widgetvalue.items;\n\n  let supportedLanguages = Object.keys(\n    vocabularyterms?.map((el) => el.titles)?.pop() || {},\n  );\n\n  const TermSchema = {\n    title: 'Translation of term',\n    fieldsets: [\n      {\n        id: 'default',\n        title: 'Email',\n        fields: supportedLanguages,\n      },\n    ],\n    properties: Object.fromEntries(\n      supportedLanguages.map((languageIdentifier) => [\n        languageIdentifier,\n        {\n          title: langmap[languageIdentifier]?.nativeName ?? languageIdentifier,\n        },\n      ]),\n    ),\n    required: [],\n  };\n\n  function onChangeFieldHandler(token, fieldid, fieldvalue) {\n    let index = findIndex(widgetvalue.items, { token: token });\n    let newitems = widgetvalue.items;\n    newitems.splice(index, 1, {\n      token: token,\n      titles: fieldvalue,\n    });\n    onChange(id, {\n      items: newitems,\n    });\n  }\n\n  function addTermHandler(e) {\n    e.preventDefault();\n    const newtoken = uuid();\n    let newitems = widgetvalue.items;\n    newitems.push({\n      token: newtoken,\n      titles: Object.fromEntries(supportedLanguages.map((el) => [el, ''])),\n    });\n    onChange(id, {\n      items: newitems,\n    });\n    setToFocusId(`field-${supportedLanguages[0]}-0-${id}-${newtoken}`);\n    setEditableToken(newtoken);\n  }\n\n  function swap(arr, from, to) {\n    arr.splice(from, 1, arr.splice(to, 1, arr[from])[0]);\n  }\n\n  let enhancedvocabularyterms = vocabularyterms.map((el) => {\n    return { ...el, '@id': el.token };\n  });\n\n  return (\n    <FormFieldWrapper {...props} className=\"vocabularytermswidget dictwidget\">\n      <div className=\"add-item-button-wrapper\">\n        <Button\n          aria-label={intl.formatMessage(messages.termtitle)}\n          onClick={(e) => {\n            addTermHandler(e);\n          }}\n        >\n          <Icon name={addSVG} size=\"18px\" />\n          {intl.formatMessage(messages.addTerm)}\n        </Button>\n      </div>\n      <DragDropList\n        childList={enhancedvocabularyterms.map((o) => [o['@id'], o])}\n        onMoveItem={(result) => {\n          const { source, destination } = result;\n          if (!destination) {\n            return;\n          }\n          let newitems = widgetvalue.items;\n          swap(newitems, source.index, destination.index);\n          onChange(id, {\n            items: newitems,\n          });\n          return true;\n        }}\n      >\n        {(dragProps) => {\n          const { child, childId, index } = dragProps;\n          let termProps = {\n            index: index,\n            id,\n            vocabularyterms,\n            vterm: child,\n            onChange,\n          };\n          return termsWrapper(\n            dragProps,\n            <ObjectWidget\n              id={`${id}-${child.token}`}\n              key={childId}\n              onChange={(fieldid, fieldvalue) => {\n                onChangeFieldHandler(child.token, fieldid, fieldvalue);\n              }}\n              value={child.titles}\n              schema={TermSchema}\n              title=\"Translation of term\"\n            />,\n            { editableToken, setEditableToken, ...termProps },\n          );\n        }}\n      </DragDropList>\n    </FormFieldWrapper>\n  );\n};\n\nconst termsWrapper = ({ draginfo }, OW, termProps) => (\n  <TermsWrapper draginfo={draginfo} termProps={termProps}>\n    {OW}\n  </TermsWrapper>\n);\n\nconst TermsWrapper = (props) => {\n  const intl = useIntl();\n  const { termProps, draginfo, children } = props;\n  const { id, vocabularyterms, vterm, onChange } = termProps;\n\n  const _updateTermsWithNewToken = (term, newtoken) => {\n    let newitems = termProps.vocabularyterms;\n    let index = findIndex(newitems, { token: term.token });\n    newitems.splice(index, 1, {\n      token: newtoken,\n      titles: newitems[index].titles,\n    });\n    onChange(id, {\n      items: newitems,\n    });\n  };\n\n  function onChangeTokenHandler(event) {\n    let value = event.target.value;\n    // required token length: 3\n    if (value.length > 2) {\n      // check if value is different from already used tokens\n      if (find(termProps.vocabularyterms, (el) => el.token === value)) {\n        // token already token. Stay with uuid.\n      } else {\n        // `token '${value}' is OK`\n        _updateTermsWithNewToken(vterm, value);\n        termProps.setEditableToken('');\n      }\n    }\n  }\n\n  return (\n    <div\n      ref={draginfo.innerRef}\n      {...draginfo.draggableProps}\n      className=\"vocabularyterm\"\n    >\n      <div style={{ alignItems: 'center', display: 'flex' }}>\n        <div {...draginfo.dragHandleProps} className=\"draghandlewrapper\">\n          <Icon name={dragSVG} size=\"18px\" />\n        </div>\n        <div className=\"ui drag block inner\">{children}</div>\n        <div>\n          {vterm.token === termProps.editableToken ? (\n            <input\n              id={`token-${vterm.token}`}\n              title=\"Token\"\n              placeholder=\"token\"\n              onBlur={onChangeTokenHandler}\n            />\n          ) : null}\n          <Button\n            icon\n            basic\n            className=\"delete-button\"\n            title={intl.formatMessage(messages.removeTerm)}\n            aria-label={`${intl.formatMessage(messages.removeTerm)} #${\n              vterm.token\n            }`}\n            onClick={(e) => {\n              e.preventDefault();\n              remove(vocabularyterms, (el) => el.token === vterm.token);\n              onChange(id, { items: vocabularyterms });\n            }}\n          >\n            <Icon name={deleteSVG} size=\"20px\" color=\"#e40166\" />\n          </Button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default VocabularyTermsWidget;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[{"id":"Vocabulary terms","defaultMessage":"Vocabulary terms"},{"id":"Vocabulary term","defaultMessage":"Vocabulary term"},{"id":"Add vocabulary term","defaultMessage":"Add term"},{"id":"Remove term","defaultMessage":"Remove term"},{"id":"Reset term title","defaultMessage":"Reset title"},{"id":"Vocabulary term title","defaultMessage":"Title"}]}},"sourceType":"module","externalDependencies":[]}