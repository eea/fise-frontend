{"ast":null,"code":"import _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport { Editor, Range, Transforms, Text, Node } from 'slate';\nimport { getMaxRange, selectAll, getSelectionNodesArrayByType } from 'volto-slate/utils';\nimport { P, LI, UL, OL } from 'volto-slate/constants';\nexport function unwrapNodesByType(editor, types) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Transforms.unwrapNodes(editor, _objectSpread({\n    match: function match(n) {\n      return types.includes(n.type);\n    }\n  }, options));\n}\nexport function unwrapList(editor, willWrapAgain) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$typeUl = _ref.typeUl,\n    typeUl = _ref$typeUl === void 0 ? UL : _ref$typeUl,\n    _ref$typeOl = _ref.typeOl,\n    typeOl = _ref$typeOl === void 0 ? OL : _ref$typeOl,\n    _ref$typeLi = _ref.typeLi,\n    typeLi = _ref$typeLi === void 0 ? LI : _ref$typeLi,\n    _ref$unwrapFromList = _ref.unwrapFromList,\n    unwrapFromList = _ref$unwrapFromList === void 0 ? false : _ref$unwrapFromList;\n  // TODO: toggling from one list type to another should keep the structure untouched\n  if (editor.selection && Range.isExpanded(editor.selection) && unwrapFromList) {\n    if (unwrapFromList) {\n      // unwrapNodesByType(editor, [typeLi]);\n      // unwrapNodesByType(editor, [typeUl, typeOl], {\n      //   split: true,\n      // });\n      // else ...\n    }\n  } else {\n    unwrapNodesByType(editor, [typeLi], {\n      at: getMaxRange(editor)\n    });\n    unwrapNodesByType(editor, [typeUl, typeOl], {\n      at: getMaxRange(editor)\n    });\n  }\n  if (!willWrapAgain) {\n    convertAllToParagraph(editor);\n  }\n}\nexport function convertAllToParagraph(editor) {\n  // let count = Array.from(Node.children(editor, [])).length;\n  var result = recursive(editor);\n  compactAndNormalize(result);\n  Editor.withoutNormalizing(editor, function () {\n    Transforms.removeNodes(editor, {\n      at: [0 /* , i */]\n    });\n    Transforms.insertNodes(editor, {\n      type: P,\n      children: [{\n        text: ''\n      }]\n    }, {\n      at: [0]\n    });\n    Transforms.insertFragment(editor, _toConsumableArray(result), {\n      at: [0]\n    });\n  });\n}\nexport function recursive(myNode) {\n  if (Text.isText(myNode)) return [_objectSpread({}, myNode)];\n  var output = [];\n  var children = Node.children(myNode, []);\n  var _iterator = _createForOfIteratorHelper(children),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 1),\n        node = _step$value[0];\n      if (Text.isText(node)) {\n        output.push(_objectSpread({}, node));\n      } else {\n        var count = Array.from(node.children).length;\n        for (var i = 0; i < count; ++i) {\n          var o = recursive(node.children[i]);\n          for (var j = 0; j < o.length; ++j) {\n            output.push(o[j]);\n          }\n        }\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  return output;\n}\n\n// TODO: make this add a space between any two Text instances\nexport function compactAndNormalize(result) {\n  for (var i = 0; i < result.length - 1; ++i) {\n    var a = result[i];\n    var b = result[i + 1];\n    var m = textsMatch(a, b);\n    if (m) {\n      result[i].text += b.text;\n      result.splice(i + 1, 1);\n    }\n  }\n  if (result.length === 0) {\n    result.push({\n      text: ''\n    });\n  }\n  return;\n}\n\n// TODO: optimize this:\nexport function textsMatch(a, b) {\n  var aKeys = Object.keys(a);\n  var bKeys = Object.keys(b);\n  for (var x in a) {\n    if (x === 'text') continue;\n    if (aKeys.includes(x) && bKeys.includes(x)) {\n      if (a[x] !== b[x]) {\n        return false;\n      }\n    }\n  }\n  for (var _x in b) {\n    if (_x === 'text') continue;\n    if (aKeys.includes(_x) && bKeys.includes(_x)) {\n      if (a[_x] !== b[_x]) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n/**\n * @summary Toggles list type.\n * @todo need to redo this\n * @todo should preserve structure of list if going from a list type to another\n * @todo allow nested lists, currently the Markdown plugin uses this function but crashes when making a UL in an OL's LI\n * @param {Editor} editor\n * @param {object} options\n */\nexport function toggleList(editor, _ref2) {\n  var typeList = _ref2.typeList,\n    _ref2$typeUl = _ref2.typeUl,\n    typeUl = _ref2$typeUl === void 0 ? UL : _ref2$typeUl,\n    _ref2$typeOl = _ref2.typeOl,\n    typeOl = _ref2$typeOl === void 0 ? OL : _ref2$typeOl,\n    _ref2$typeLi = _ref2.typeLi,\n    typeLi = _ref2$typeLi === void 0 ? LI : _ref2$typeLi,\n    _ref2$typeP = _ref2.typeP,\n    typeP = _ref2$typeP === void 0 ? P : _ref2$typeP,\n    _ref2$isBulletedActiv = _ref2.isBulletedActive,\n    isBulletedActive = _ref2$isBulletedActiv === void 0 ? false : _ref2$isBulletedActiv,\n    _ref2$isNumberedActiv = _ref2.isNumberedActive,\n    isNumberedActive = _ref2$isNumberedActiv === void 0 ? false : _ref2$isNumberedActiv;\n  // TODO: set previous selection (not this 'select all' command) after toggling list (in all three cases: toggling to numbered, bulleted or none)\n  selectAll(editor);\n\n  // const isActive = isNodeInSelection(editor, [typeList]);\n\n  // if (the list type/s are unset) {\n\n  var B = typeList === UL;\n  var N = typeList === OL;\n  if (N && !isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor);\n    // go on with const willWrapAgain etc.\n  } else if (N && !isBulletedActive && isNumberedActive) {\n    convertAllToParagraph(editor);\n    return;\n  } else if (N && isBulletedActive && !isNumberedActive) {\n    // go on with const willWrapAgain etc.\n  } else if (B && !isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor);\n    // go on with const willWrapAgain etc.\n  } else if (B && !isBulletedActive && isNumberedActive) {\n    // go on with const willWrapAgain etc.\n  } else if (B && isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor);\n    return;\n  }\n  selectAll(editor);\n  var willWrapAgain = !isBulletedActive;\n  unwrapList(editor, willWrapAgain, {\n    unwrapFromList: isBulletedActive\n  });\n\n  // a new list is created and everything in the editor is put in it;\n  // `children` property is added automatically as an empty array then\n  // normalized\n  var list = {\n    type: typeList\n  };\n  Transforms.wrapNodes(editor, list);\n\n  // get all the selected paragraphs\n  var nodes = getSelectionNodesArrayByType(editor, typeP);\n\n  // for each paragraph\n  var _iterator2 = _createForOfIteratorHelper(nodes),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _step2$value = _slicedToArray(_step2.value, 2),\n        path = _step2$value[1];\n      // convert the paragraph to a list item\n      Transforms.setNodes(editor, {\n        type: LI\n      }, {\n        at: path\n      });\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}","map":{"version":3,"names":["Editor","Range","Transforms","Text","Node","getMaxRange","selectAll","getSelectionNodesArrayByType","P","LI","UL","OL","unwrapNodesByType","editor","types","options","unwrapNodes","match","n","includes","type","unwrapList","willWrapAgain","typeUl","typeOl","typeLi","unwrapFromList","selection","isExpanded","at","convertAllToParagraph","result","recursive","compactAndNormalize","withoutNormalizing","removeNodes","insertNodes","children","text","insertFragment","myNode","isText","output","node","push","count","Array","from","length","i","o","j","a","b","m","textsMatch","splice","aKeys","Object","keys","bKeys","x","toggleList","typeList","typeP","isBulletedActive","isNumberedActive","B","N","list","wrapNodes","nodes","path","setNodes"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-slate/src/editor/plugins/Markdown/utils.js"],"sourcesContent":["import { Editor, Range, Transforms, Text, Node } from 'slate';\nimport {\n  getMaxRange,\n  selectAll,\n  getSelectionNodesArrayByType,\n} from 'volto-slate/utils';\nimport { P, LI, UL, OL } from 'volto-slate/constants';\n\nexport function unwrapNodesByType(editor, types, options = {}) {\n  Transforms.unwrapNodes(editor, {\n    match: (n) => types.includes(n.type),\n    ...options,\n  });\n}\n\nexport function unwrapList(\n  editor,\n  willWrapAgain,\n  { typeUl = UL, typeOl = OL, typeLi = LI, unwrapFromList = false } = {},\n) {\n  // TODO: toggling from one list type to another should keep the structure untouched\n  if (\n    editor.selection &&\n    Range.isExpanded(editor.selection) &&\n    unwrapFromList\n  ) {\n    if (unwrapFromList) {\n      // unwrapNodesByType(editor, [typeLi]);\n      // unwrapNodesByType(editor, [typeUl, typeOl], {\n      //   split: true,\n      // });\n      // else ...\n    }\n  } else {\n    unwrapNodesByType(editor, [typeLi], { at: getMaxRange(editor) });\n    unwrapNodesByType(editor, [typeUl, typeOl], {\n      at: getMaxRange(editor),\n    });\n  }\n\n  if (!willWrapAgain) {\n    convertAllToParagraph(editor);\n  }\n}\n\nexport function convertAllToParagraph(editor) {\n  // let count = Array.from(Node.children(editor, [])).length;\n  let result = recursive(editor);\n  compactAndNormalize(result);\n\n  Editor.withoutNormalizing(editor, () => {\n    Transforms.removeNodes(editor, { at: [0 /* , i */] });\n    Transforms.insertNodes(\n      editor,\n      { type: P, children: [{ text: '' }] },\n      { at: [0] },\n    );\n    Transforms.insertFragment(editor, [...result], { at: [0] });\n  });\n}\n\nexport function recursive(myNode) {\n  if (Text.isText(myNode)) return [{ ...myNode }];\n\n  let output = [];\n  let children = Node.children(myNode, []);\n\n  for (const [node] of children) {\n    if (Text.isText(node)) {\n      output.push({ ...node });\n    } else {\n      let count = Array.from(node.children).length;\n      for (let i = 0; i < count; ++i) {\n        let o = recursive(node.children[i]);\n        for (let j = 0; j < o.length; ++j) {\n          output.push(o[j]);\n        }\n      }\n    }\n  }\n\n  return output;\n}\n\n// TODO: make this add a space between any two Text instances\nexport function compactAndNormalize(result) {\n  for (let i = 0; i < result.length - 1; ++i) {\n    let a = result[i];\n    let b = result[i + 1];\n\n    let m = textsMatch(a, b);\n    if (m) {\n      result[i].text += b.text;\n      result.splice(i + 1, 1);\n    }\n  }\n\n  if (result.length === 0) {\n    result.push({ text: '' });\n  }\n\n  return;\n}\n\n// TODO: optimize this:\nexport function textsMatch(a, b) {\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n\n  for (let x in a) {\n    if (x === 'text') continue;\n    if (aKeys.includes(x) && bKeys.includes(x)) {\n      if (a[x] !== b[x]) {\n        return false;\n      }\n    }\n  }\n\n  for (let x in b) {\n    if (x === 'text') continue;\n    if (aKeys.includes(x) && bKeys.includes(x)) {\n      if (a[x] !== b[x]) {\n        return false;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * @summary Toggles list type.\n * @todo need to redo this\n * @todo should preserve structure of list if going from a list type to another\n * @todo allow nested lists, currently the Markdown plugin uses this function but crashes when making a UL in an OL's LI\n * @param {Editor} editor\n * @param {object} options\n */\nexport function toggleList(\n  editor,\n  {\n    typeList,\n    typeUl = UL,\n    typeOl = OL,\n    typeLi = LI,\n    typeP = P,\n    isBulletedActive = false,\n    isNumberedActive = false,\n  },\n) {\n  // TODO: set previous selection (not this 'select all' command) after toggling list (in all three cases: toggling to numbered, bulleted or none)\n  selectAll(editor);\n\n  // const isActive = isNodeInSelection(editor, [typeList]);\n\n  // if (the list type/s are unset) {\n\n  const B = typeList === UL;\n  const N = typeList === OL;\n\n  if (N && !isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor);\n    // go on with const willWrapAgain etc.\n  } else if (N && !isBulletedActive && isNumberedActive) {\n    convertAllToParagraph(editor);\n    return;\n  } else if (N && isBulletedActive && !isNumberedActive) {\n    // go on with const willWrapAgain etc.\n  } else if (B && !isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor);\n    // go on with const willWrapAgain etc.\n  } else if (B && !isBulletedActive && isNumberedActive) {\n    // go on with const willWrapAgain etc.\n  } else if (B && isBulletedActive && !isNumberedActive) {\n    convertAllToParagraph(editor);\n    return;\n  }\n\n  selectAll(editor);\n\n  const willWrapAgain = !isBulletedActive;\n  unwrapList(editor, willWrapAgain, { unwrapFromList: isBulletedActive });\n\n  // a new list is created and everything in the editor is put in it;\n  // `children` property is added automatically as an empty array then\n  // normalized\n  const list = { type: typeList };\n  Transforms.wrapNodes(editor, list);\n\n  // get all the selected paragraphs\n  const nodes = getSelectionNodesArrayByType(editor, typeP);\n\n  // for each paragraph\n  for (const [, path] of nodes) {\n    // convert the paragraph to a list item\n    Transforms.setNodes(editor, { type: LI }, { at: path });\n  }\n}\n"],"mappings":";;;;AAAA,SAASA,MAAM,EAAEC,KAAK,EAAEC,UAAU,EAAEC,IAAI,EAAEC,IAAI,QAAQ,OAAO;AAC7D,SACEC,WAAW,EACXC,SAAS,EACTC,4BAA4B,QACvB,mBAAmB;AAC1B,SAASC,CAAC,EAAEC,EAAE,EAAEC,EAAE,EAAEC,EAAE,QAAQ,uBAAuB;AAErD,OAAO,SAASC,iBAAiB,CAACC,MAAM,EAAEC,KAAK,EAAgB;EAAA,IAAdC,OAAO,uEAAG,CAAC,CAAC;EAC3Db,UAAU,CAACc,WAAW,CAACH,MAAM;IAC3BI,KAAK,EAAE,eAACC,CAAC;MAAA,OAAKJ,KAAK,CAACK,QAAQ,CAACD,CAAC,CAACE,IAAI,CAAC;IAAA;EAAA,GACjCL,OAAO,EACV;AACJ;AAEA,OAAO,SAASM,UAAU,CACxBR,MAAM,EACNS,aAAa,EAEb;EAAA,+EADoE,CAAC,CAAC;IAAA,mBAApEC,MAAM;IAANA,MAAM,4BAAGb,EAAE;IAAA,mBAAEc,MAAM;IAANA,MAAM,4BAAGb,EAAE;IAAA,mBAAEc,MAAM;IAANA,MAAM,4BAAGhB,EAAE;IAAA,2BAAEiB,cAAc;IAAdA,cAAc,oCAAG,KAAK;EAE/D;EACA,IACEb,MAAM,CAACc,SAAS,IAChB1B,KAAK,CAAC2B,UAAU,CAACf,MAAM,CAACc,SAAS,CAAC,IAClCD,cAAc,EACd;IACA,IAAIA,cAAc,EAAE;MAClB;MACA;MACA;MACA;MACA;IAAA;EAEJ,CAAC,MAAM;IACLd,iBAAiB,CAACC,MAAM,EAAE,CAACY,MAAM,CAAC,EAAE;MAAEI,EAAE,EAAExB,WAAW,CAACQ,MAAM;IAAE,CAAC,CAAC;IAChED,iBAAiB,CAACC,MAAM,EAAE,CAACU,MAAM,EAAEC,MAAM,CAAC,EAAE;MAC1CK,EAAE,EAAExB,WAAW,CAACQ,MAAM;IACxB,CAAC,CAAC;EACJ;EAEA,IAAI,CAACS,aAAa,EAAE;IAClBQ,qBAAqB,CAACjB,MAAM,CAAC;EAC/B;AACF;AAEA,OAAO,SAASiB,qBAAqB,CAACjB,MAAM,EAAE;EAC5C;EACA,IAAIkB,MAAM,GAAGC,SAAS,CAACnB,MAAM,CAAC;EAC9BoB,mBAAmB,CAACF,MAAM,CAAC;EAE3B/B,MAAM,CAACkC,kBAAkB,CAACrB,MAAM,EAAE,YAAM;IACtCX,UAAU,CAACiC,WAAW,CAACtB,MAAM,EAAE;MAAEgB,EAAE,EAAE,CAAC,CAAC,CAAC;IAAW,CAAC,CAAC;IACrD3B,UAAU,CAACkC,WAAW,CACpBvB,MAAM,EACN;MAAEO,IAAI,EAAEZ,CAAC;MAAE6B,QAAQ,EAAE,CAAC;QAAEC,IAAI,EAAE;MAAG,CAAC;IAAE,CAAC,EACrC;MAAET,EAAE,EAAE,CAAC,CAAC;IAAE,CAAC,CACZ;IACD3B,UAAU,CAACqC,cAAc,CAAC1B,MAAM,qBAAMkB,MAAM,GAAG;MAAEF,EAAE,EAAE,CAAC,CAAC;IAAE,CAAC,CAAC;EAC7D,CAAC,CAAC;AACJ;AAEA,OAAO,SAASG,SAAS,CAACQ,MAAM,EAAE;EAChC,IAAIrC,IAAI,CAACsC,MAAM,CAACD,MAAM,CAAC,EAAE,OAAO,mBAAMA,MAAM,EAAG;EAE/C,IAAIE,MAAM,GAAG,EAAE;EACf,IAAIL,QAAQ,GAAGjC,IAAI,CAACiC,QAAQ,CAACG,MAAM,EAAE,EAAE,CAAC;EAAC,2CAEpBH,QAAQ;IAAA;EAAA;IAA7B,oDAA+B;MAAA;QAAnBM,IAAI;MACd,IAAIxC,IAAI,CAACsC,MAAM,CAACE,IAAI,CAAC,EAAE;QACrBD,MAAM,CAACE,IAAI,mBAAMD,IAAI,EAAG;MAC1B,CAAC,MAAM;QACL,IAAIE,KAAK,GAAGC,KAAK,CAACC,IAAI,CAACJ,IAAI,CAACN,QAAQ,CAAC,CAACW,MAAM;QAC5C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,KAAK,EAAE,EAAEI,CAAC,EAAE;UAC9B,IAAIC,CAAC,GAAGlB,SAAS,CAACW,IAAI,CAACN,QAAQ,CAACY,CAAC,CAAC,CAAC;UACnC,KAAK,IAAIE,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,CAAC,CAACF,MAAM,EAAE,EAAEG,CAAC,EAAE;YACjCT,MAAM,CAACE,IAAI,CAACM,CAAC,CAACC,CAAC,CAAC,CAAC;UACnB;QACF;MACF;IACF;EAAC;IAAA;EAAA;IAAA;EAAA;EAED,OAAOT,MAAM;AACf;;AAEA;AACA,OAAO,SAAST,mBAAmB,CAACF,MAAM,EAAE;EAC1C,KAAK,IAAIkB,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGlB,MAAM,CAACiB,MAAM,GAAG,CAAC,EAAE,EAAEC,CAAC,EAAE;IAC1C,IAAIG,CAAC,GAAGrB,MAAM,CAACkB,CAAC,CAAC;IACjB,IAAII,CAAC,GAAGtB,MAAM,CAACkB,CAAC,GAAG,CAAC,CAAC;IAErB,IAAIK,CAAC,GAAGC,UAAU,CAACH,CAAC,EAAEC,CAAC,CAAC;IACxB,IAAIC,CAAC,EAAE;MACLvB,MAAM,CAACkB,CAAC,CAAC,CAACX,IAAI,IAAIe,CAAC,CAACf,IAAI;MACxBP,MAAM,CAACyB,MAAM,CAACP,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;IACzB;EACF;EAEA,IAAIlB,MAAM,CAACiB,MAAM,KAAK,CAAC,EAAE;IACvBjB,MAAM,CAACa,IAAI,CAAC;MAAEN,IAAI,EAAE;IAAG,CAAC,CAAC;EAC3B;EAEA;AACF;;AAEA;AACA,OAAO,SAASiB,UAAU,CAACH,CAAC,EAAEC,CAAC,EAAE;EAC/B,IAAMI,KAAK,GAAGC,MAAM,CAACC,IAAI,CAACP,CAAC,CAAC;EAC5B,IAAMQ,KAAK,GAAGF,MAAM,CAACC,IAAI,CAACN,CAAC,CAAC;EAE5B,KAAK,IAAIQ,CAAC,IAAIT,CAAC,EAAE;IACf,IAAIS,CAAC,KAAK,MAAM,EAAE;IAClB,IAAIJ,KAAK,CAACtC,QAAQ,CAAC0C,CAAC,CAAC,IAAID,KAAK,CAACzC,QAAQ,CAAC0C,CAAC,CAAC,EAAE;MAC1C,IAAIT,CAAC,CAACS,CAAC,CAAC,KAAKR,CAAC,CAACQ,CAAC,CAAC,EAAE;QACjB,OAAO,KAAK;MACd;IACF;EACF;EAEA,KAAK,IAAIA,EAAC,IAAIR,CAAC,EAAE;IACf,IAAIQ,EAAC,KAAK,MAAM,EAAE;IAClB,IAAIJ,KAAK,CAACtC,QAAQ,CAAC0C,EAAC,CAAC,IAAID,KAAK,CAACzC,QAAQ,CAAC0C,EAAC,CAAC,EAAE;MAC1C,IAAIT,CAAC,CAACS,EAAC,CAAC,KAAKR,CAAC,CAACQ,EAAC,CAAC,EAAE;QACjB,OAAO,KAAK;MACd;IACF;EACF;EAEA,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,UAAU,CACxBjD,MAAM,SAUN;EAAA,IAREkD,QAAQ,SAARA,QAAQ;IAAA,qBACRxC,MAAM;IAANA,MAAM,6BAAGb,EAAE;IAAA,qBACXc,MAAM;IAANA,MAAM,6BAAGb,EAAE;IAAA,qBACXc,MAAM;IAANA,MAAM,6BAAGhB,EAAE;IAAA,oBACXuD,KAAK;IAALA,KAAK,4BAAGxD,CAAC;IAAA,8BACTyD,gBAAgB;IAAhBA,gBAAgB,sCAAG,KAAK;IAAA,8BACxBC,gBAAgB;IAAhBA,gBAAgB,sCAAG,KAAK;EAG1B;EACA5D,SAAS,CAACO,MAAM,CAAC;;EAEjB;;EAEA;;EAEA,IAAMsD,CAAC,GAAGJ,QAAQ,KAAKrD,EAAE;EACzB,IAAM0D,CAAC,GAAGL,QAAQ,KAAKpD,EAAE;EAEzB,IAAIyD,CAAC,IAAI,CAACH,gBAAgB,IAAI,CAACC,gBAAgB,EAAE;IAC/CpC,qBAAqB,CAACjB,MAAM,CAAC;IAC7B;EACF,CAAC,MAAM,IAAIuD,CAAC,IAAI,CAACH,gBAAgB,IAAIC,gBAAgB,EAAE;IACrDpC,qBAAqB,CAACjB,MAAM,CAAC;IAC7B;EACF,CAAC,MAAM,IAAIuD,CAAC,IAAIH,gBAAgB,IAAI,CAACC,gBAAgB,EAAE;IACrD;EAAA,CACD,MAAM,IAAIC,CAAC,IAAI,CAACF,gBAAgB,IAAI,CAACC,gBAAgB,EAAE;IACtDpC,qBAAqB,CAACjB,MAAM,CAAC;IAC7B;EACF,CAAC,MAAM,IAAIsD,CAAC,IAAI,CAACF,gBAAgB,IAAIC,gBAAgB,EAAE;IACrD;EAAA,CACD,MAAM,IAAIC,CAAC,IAAIF,gBAAgB,IAAI,CAACC,gBAAgB,EAAE;IACrDpC,qBAAqB,CAACjB,MAAM,CAAC;IAC7B;EACF;EAEAP,SAAS,CAACO,MAAM,CAAC;EAEjB,IAAMS,aAAa,GAAG,CAAC2C,gBAAgB;EACvC5C,UAAU,CAACR,MAAM,EAAES,aAAa,EAAE;IAAEI,cAAc,EAAEuC;EAAiB,CAAC,CAAC;;EAEvE;EACA;EACA;EACA,IAAMI,IAAI,GAAG;IAAEjD,IAAI,EAAE2C;EAAS,CAAC;EAC/B7D,UAAU,CAACoE,SAAS,CAACzD,MAAM,EAAEwD,IAAI,CAAC;;EAElC;EACA,IAAME,KAAK,GAAGhE,4BAA4B,CAACM,MAAM,EAAEmD,KAAK,CAAC;;EAEzD;EAAA,4CACuBO,KAAK;IAAA;EAAA;IAA5B,uDAA8B;MAAA;QAAhBC,IAAI;MAChB;MACAtE,UAAU,CAACuE,QAAQ,CAAC5D,MAAM,EAAE;QAAEO,IAAI,EAAEX;MAAG,CAAC,EAAE;QAAEoB,EAAE,EAAE2C;MAAK,CAAC,CAAC;IACzD;EAAC;IAAA;EAAA;IAAA;EAAA;AACH"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}