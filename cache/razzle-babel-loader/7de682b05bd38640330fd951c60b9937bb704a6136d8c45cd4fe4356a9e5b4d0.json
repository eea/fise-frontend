{"ast":null,"code":"import _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport ReactDOM from 'react-dom';\nimport { serializeNodesToText } from 'volto-slate/editor/render';\nimport { Editor } from 'slate';\nimport { getPreviousVoltoBlock, getNextVoltoBlock, isCursorAtBlockStart, isCursorAtBlockEnd, mergeSlateWithBlockBackward, mergeSlateWithBlockForward } from 'volto-slate/utils';\nimport { changeBlock, deleteBlock, getBlocksFieldname, getBlocksLayoutFieldname } from '@plone/volto/helpers';\n\n/**\n * Joins the current block (which has an active Slate Editor)\n * with the previous block, to make a single block.\n *\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithPreviousBlock(_ref) {\n  var editor = _ref.editor,\n    event = _ref.event;\n  if (!isCursorAtBlockStart(editor)) return;\n  var blockProps = editor.getBlockProps();\n  var block = blockProps.block,\n    index = blockProps.index,\n    saveSlateBlockSelection = blockProps.saveSlateBlockSelection,\n    onSelectBlock = blockProps.onSelectBlock,\n    data = blockProps.data,\n    properties = blockProps.properties,\n    onChangeField = blockProps.onChangeField;\n  var blocksFieldname = getBlocksFieldname(properties);\n  var blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  var prev = getPreviousVoltoBlock(index, properties);\n  if (!prev) return;\n  var _prev = _slicedToArray(prev, 2),\n    _prev$ = _prev[0],\n    otherBlock = _prev$ === void 0 ? {} : _prev$,\n    otherBlockId = _prev[1];\n\n  // Don't join with required blocks\n  if (data !== null && data !== void 0 && data.required || otherBlock !== null && otherBlock !== void 0 && otherBlock.required || otherBlock['@type'] !== 'slate') return;\n  event.stopPropagation();\n  event.preventDefault();\n\n  // If the Editor contains no characters TODO: clarify if this special case\n  // really needs to be handled or not. In `joinWithNextBlock` it is not\n  // handled.\n  var text = Editor.string(editor, []);\n  if (!text) {\n    var _cursor = getBlockEndAsRange(otherBlock);\n    var _newFormData = deleteBlock(properties, block);\n    ReactDOM.unstable_batchedUpdates(function () {\n      saveSlateBlockSelection(otherBlockId, _cursor);\n      onChangeField(blocksFieldname, _newFormData[blocksFieldname]);\n      onChangeField(blocksLayoutFieldname, _newFormData[blocksLayoutFieldname]);\n      onSelectBlock(otherBlockId);\n    });\n    return true;\n  }\n\n  // Else the editor contains characters, so we merge the current block's\n  // `editor` with the block before, `otherBlock`.\n  var cursor = mergeSlateWithBlockBackward(editor, otherBlock);\n  var combined = JSON.parse(JSON.stringify(editor.children));\n\n  // // TODO: don't remove undo history, etc Should probably save both undo\n  // // histories, so that the blocks are split, the undos can be restored??\n\n  // const cursor = getBlockEndAsRange(otherBlock);\n  var formData = changeBlock(properties, otherBlockId, {\n    '@type': 'slate',\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    value: combined,\n    plaintext: serializeNodesToText(combined || [])\n  });\n  var newFormData = deleteBlock(formData, block);\n  ReactDOM.unstable_batchedUpdates(function () {\n    saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n\n/**\n * Joins the current block (which has the cursor) with the next block to make a\n * single block.\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithNextBlock(_ref2) {\n  var editor = _ref2.editor,\n    event = _ref2.event;\n  if (!isCursorAtBlockEnd(editor)) return;\n  var blockProps = editor.getBlockProps();\n  var block = blockProps.block,\n    index = blockProps.index,\n    onSelectBlock = blockProps.onSelectBlock,\n    data = blockProps.data;\n  var _editor$getBlockProps = editor.getBlockProps(),\n    properties = _editor$getBlockProps.properties,\n    onChangeField = _editor$getBlockProps.onChangeField;\n  var _getNextVoltoBlock = getNextVoltoBlock(index, properties),\n    _getNextVoltoBlock2 = _slicedToArray(_getNextVoltoBlock, 2),\n    _getNextVoltoBlock2$ = _getNextVoltoBlock2[0],\n    otherBlock = _getNextVoltoBlock2$ === void 0 ? {} : _getNextVoltoBlock2$,\n    otherBlockId = _getNextVoltoBlock2[1];\n\n  // Don't join with required blocks\n  if (data !== null && data !== void 0 && data.required || otherBlock !== null && otherBlock !== void 0 && otherBlock.required || otherBlock['@type'] !== 'slate') return;\n  event.stopPropagation();\n  event.preventDefault();\n  mergeSlateWithBlockForward(editor, otherBlock);\n\n  // const cursor = JSON.parse(JSON.stringify(editor.selection));\n  var combined = JSON.parse(JSON.stringify(editor.children));\n\n  // TODO: don't remove undo history, etc Should probably save both undo\n  // histories, so that the blocks are split, the undos can be restored??\n\n  var blocksFieldname = getBlocksFieldname(properties);\n  var blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  var formData = changeBlock(properties, otherBlockId, {\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    '@type': 'slate',\n    value: combined,\n    plaintext: serializeNodesToText(combined || [])\n  });\n  var newFormData = deleteBlock(formData, block);\n  ReactDOM.unstable_batchedUpdates(function () {\n    // saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n\n/**\n * @param {object} block The Volto object representing the configuration and\n * contents of a Volto Block of type Slate Text.\n * @returns {Range} The collapsed Slate Range that represents the last position\n * the text cursor can take inside the given block.\n */\nfunction getBlockEndAsRange(block) {\n  var value = block.value;\n  var location = [value.length - 1]; // adress of root node\n  var editor = {\n    children: value\n  };\n  var path = Editor.last(editor, location)[1]; // last Node in the block\n  // The last Text node (leaf node) entry inside the path computed just above.\n  var _Editor$leaf = Editor.leaf(editor, path),\n    _Editor$leaf2 = _slicedToArray(_Editor$leaf, 2),\n    leaf = _Editor$leaf2[0],\n    leafpath = _Editor$leaf2[1];\n  // The offset of the Points in the collapsed Range computed below:\n  var offset = (leaf.text || '').length;\n  return {\n    anchor: {\n      path: leafpath,\n      offset: offset\n    },\n    focus: {\n      path: leafpath,\n      offset: offset\n    }\n  };\n}","map":{"version":3,"names":["ReactDOM","serializeNodesToText","Editor","getPreviousVoltoBlock","getNextVoltoBlock","isCursorAtBlockStart","isCursorAtBlockEnd","mergeSlateWithBlockBackward","mergeSlateWithBlockForward","changeBlock","deleteBlock","getBlocksFieldname","getBlocksLayoutFieldname","joinWithPreviousBlock","editor","event","blockProps","getBlockProps","block","index","saveSlateBlockSelection","onSelectBlock","data","properties","onChangeField","blocksFieldname","blocksLayoutFieldname","prev","otherBlock","otherBlockId","required","stopPropagation","preventDefault","text","string","cursor","getBlockEndAsRange","newFormData","unstable_batchedUpdates","combined","JSON","parse","stringify","children","formData","value","plaintext","joinWithNextBlock","location","length","path","last","leaf","leafpath","offset","anchor","focus"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/blocks/Text/keyboard/joinBlocks.js"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport { serializeNodesToText } from 'volto-slate/editor/render';\nimport { Editor } from 'slate';\nimport {\n  getPreviousVoltoBlock,\n  getNextVoltoBlock,\n  isCursorAtBlockStart,\n  isCursorAtBlockEnd,\n  mergeSlateWithBlockBackward,\n  mergeSlateWithBlockForward,\n} from 'volto-slate/utils';\nimport {\n  changeBlock,\n  deleteBlock,\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers';\n\n/**\n * Joins the current block (which has an active Slate Editor)\n * with the previous block, to make a single block.\n *\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithPreviousBlock({ editor, event }) {\n  if (!isCursorAtBlockStart(editor)) return;\n\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n    properties,\n    onChangeField,\n  } = blockProps;\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const prev = getPreviousVoltoBlock(index, properties);\n  if (!prev) return;\n  const [otherBlock = {}, otherBlockId] = prev;\n\n  // Don't join with required blocks\n  if (data?.required || otherBlock?.required || otherBlock['@type'] !== 'slate')\n    return;\n\n  event.stopPropagation();\n  event.preventDefault();\n\n  // If the Editor contains no characters TODO: clarify if this special case\n  // really needs to be handled or not. In `joinWithNextBlock` it is not\n  // handled.\n  const text = Editor.string(editor, []);\n  if (!text) {\n    const cursor = getBlockEndAsRange(otherBlock);\n    const newFormData = deleteBlock(properties, block);\n\n    ReactDOM.unstable_batchedUpdates(() => {\n      saveSlateBlockSelection(otherBlockId, cursor);\n\n      onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n      onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n\n      onSelectBlock(otherBlockId);\n    });\n\n    return true;\n  }\n\n  // Else the editor contains characters, so we merge the current block's\n  // `editor` with the block before, `otherBlock`.\n  const cursor = mergeSlateWithBlockBackward(editor, otherBlock);\n\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // // TODO: don't remove undo history, etc Should probably save both undo\n  // // histories, so that the blocks are split, the undos can be restored??\n\n  // const cursor = getBlockEndAsRange(otherBlock);\n  const formData = changeBlock(properties, otherBlockId, {\n    '@type': 'slate', // TODO: use a constant specified in src/constants.js instead of 'slate'\n    value: combined,\n    plaintext: serializeNodesToText(combined || []),\n  });\n  const newFormData = deleteBlock(formData, block);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n\n  return true;\n}\n\n/**\n * Joins the current block (which has the cursor) with the next block to make a\n * single block.\n * @param {Editor} editor\n * @param {KeyboardEvent} event\n */\nexport function joinWithNextBlock({ editor, event }) {\n  if (!isCursorAtBlockEnd(editor)) return;\n\n  const blockProps = editor.getBlockProps();\n  const {\n    block,\n    index,\n    // saveSlateBlockSelection,\n    onSelectBlock,\n    data,\n  } = blockProps;\n\n  const { properties, onChangeField } = editor.getBlockProps();\n  const [otherBlock = {}, otherBlockId] = getNextVoltoBlock(index, properties);\n\n  // Don't join with required blocks\n  if (data?.required || otherBlock?.required || otherBlock['@type'] !== 'slate')\n    return;\n\n  event.stopPropagation();\n  event.preventDefault();\n\n  mergeSlateWithBlockForward(editor, otherBlock);\n\n  // const cursor = JSON.parse(JSON.stringify(editor.selection));\n  const combined = JSON.parse(JSON.stringify(editor.children));\n\n  // TODO: don't remove undo history, etc Should probably save both undo\n  // histories, so that the blocks are split, the undos can be restored??\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const formData = changeBlock(properties, otherBlockId, {\n    // TODO: use a constant specified in src/constants.js instead of 'slate'\n    '@type': 'slate',\n    value: combined,\n    plaintext: serializeNodesToText(combined || []),\n  });\n  const newFormData = deleteBlock(formData, block);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    // saveSlateBlockSelection(otherBlockId, cursor);\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(otherBlockId);\n  });\n  return true;\n}\n\n/**\n * @param {object} block The Volto object representing the configuration and\n * contents of a Volto Block of type Slate Text.\n * @returns {Range} The collapsed Slate Range that represents the last position\n * the text cursor can take inside the given block.\n */\nfunction getBlockEndAsRange(block) {\n  const { value } = block;\n  const location = [value.length - 1]; // adress of root node\n  const editor = { children: value };\n  const path = Editor.last(editor, location)[1]; // last Node in the block\n  // The last Text node (leaf node) entry inside the path computed just above.\n  const [leaf, leafpath] = Editor.leaf(editor, path);\n  // The offset of the Points in the collapsed Range computed below:\n  const offset = (leaf.text || '').length;\n\n  return {\n    anchor: { path: leafpath, offset },\n    focus: { path: leafpath, offset },\n  };\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}