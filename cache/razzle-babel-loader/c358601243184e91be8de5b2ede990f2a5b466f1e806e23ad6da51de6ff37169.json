{"ast":null,"code":"import _cloneDeep from \"lodash/cloneDeep\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport config from '@plone/volto/registry';\nexport const addTypeSelect = ({\n  intl,\n  schema,\n  extensionName,\n  messages\n}) => {\n  schema = _cloneDeep(schema);\n  const field = '@type';\n  const extensions = config.blocks.blocksConfig.listing.extensions;\n  const variations = extensions[extensionName];\n  schema.properties[field] = {\n    title: intl.formatMessage(messages.title),\n    choices: variations.map(({\n      id,\n      title\n    }) => [id, title]),\n    defaultValue: variations.find(({\n      isDefault\n    }) => isDefault).id\n  };\n  schema.fieldsets[0].fields.unshift(field);\n  return schema;\n};\n\n// Creates a factory that can trigger schemaEnhancer for a given extension\nexport const schemaEnhancerFactory = ({\n  extensionName,\n  messages,\n  blockType = 'listing',\n  extensionField = '@type'\n}) => ({\n  schema: originalSchema,\n  formData,\n  intl\n}) => {\n  var _formData$itemModel, _activeItem;\n  //\n  // the attribute name that's stored in the block data\n  // it identifies the type of extension that's\n  // applied. Similar in scope, for example, with the block @type\n\n  const blockConfig = config.blocks.blocksConfig[blockType];\n  const extensions = blockConfig.extensions;\n  const templates = extensions[extensionName];\n  const activeItemName = formData === null || formData === void 0 ? void 0 : (_formData$itemModel = formData.itemModel) === null || _formData$itemModel === void 0 ? void 0 : _formData$itemModel[extensionField]; // TODO: don't hardcode itemModel\n  let activeItem = templates === null || templates === void 0 ? void 0 : templates.find(item => item.id === activeItemName);\n  if (!activeItem) activeItem = templates === null || templates === void 0 ? void 0 : templates.find(item => item.isDefault);\n  const schemaEnhancer = (_activeItem = activeItem) === null || _activeItem === void 0 ? void 0 : _activeItem['schemaEnhancer'];\n  let schema = schemaEnhancer ? schemaEnhancer({\n    schema: _cloneDeep(originalSchema),\n    formData,\n    intl\n  }) : _cloneDeep(originalSchema);\n  return schema;\n};\nexport const DefaultCardModelSchema = {\n  title: 'Card Model',\n  fieldsets: [{\n    id: 'default',\n    title: 'Default',\n    fields: []\n  }],\n  properties: {},\n  required: []\n};\nexport const getVoltoStyles = props => {\n  const styles = props ? props : {};\n  const output = {};\n  for (const [key, value] of Object.entries(styles)) {\n    if (styles[key] === true) {\n      output[key] = key;\n    } else {\n      output[value] = value;\n    }\n  }\n  return output;\n};\nexport function composeSchema() {\n  const enhancers = Array.from(arguments);\n  const composer = args => {\n    const props = enhancers.reduce((acc, enhancer) => enhancer ? _objectSpread(_objectSpread({}, acc), {}, {\n      schema: enhancer(acc)\n    }) : acc, _objectSpread({}, args));\n    return props.schema;\n  };\n  return composer;\n}","map":{"version":3,"names":["config","addTypeSelect","intl","schema","extensionName","messages","field","extensions","blocks","blocksConfig","listing","variations","properties","title","formatMessage","choices","map","id","defaultValue","find","isDefault","fieldsets","fields","unshift","schemaEnhancerFactory","blockType","extensionField","originalSchema","formData","blockConfig","templates","activeItemName","itemModel","activeItem","item","schemaEnhancer","DefaultCardModelSchema","required","getVoltoStyles","props","styles","output","key","value","Object","entries","composeSchema","enhancers","Array","from","arguments","composer","args","reduce","acc","enhancer"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-listing-block/src/schema-utils.js"],"sourcesContent":["import { cloneDeep } from 'lodash';\nimport config from '@plone/volto/registry';\n\nexport const addTypeSelect = ({ intl, schema, extensionName, messages }) => {\n  schema = cloneDeep(schema);\n  const field = '@type';\n  const extensions = config.blocks.blocksConfig.listing.extensions;\n  const variations = extensions[extensionName];\n  schema.properties[field] = {\n    title: intl.formatMessage(messages.title),\n    choices: variations.map(({ id, title }) => [id, title]),\n    defaultValue: variations.find(({ isDefault }) => isDefault).id,\n  };\n  schema.fieldsets[0].fields.unshift(field);\n\n  return schema;\n};\n\n// Creates a factory that can trigger schemaEnhancer for a given extension\nexport const schemaEnhancerFactory = ({\n  extensionName,\n  messages,\n  blockType = 'listing',\n  extensionField = '@type',\n}) => ({ schema: originalSchema, formData, intl }) => {\n  //\n  // the attribute name that's stored in the block data\n  // it identifies the type of extension that's\n  // applied. Similar in scope, for example, with the block @type\n\n  const blockConfig = config.blocks.blocksConfig[blockType];\n  const extensions = blockConfig.extensions;\n  const templates = extensions[extensionName];\n\n  const activeItemName = formData?.itemModel?.[extensionField]; // TODO: don't hardcode itemModel\n  let activeItem = templates?.find((item) => item.id === activeItemName);\n  if (!activeItem) activeItem = templates?.find((item) => item.isDefault);\n\n  const schemaEnhancer = activeItem?.['schemaEnhancer'];\n\n  let schema = schemaEnhancer\n    ? schemaEnhancer({ schema: cloneDeep(originalSchema), formData, intl })\n    : cloneDeep(originalSchema);\n\n  return schema;\n};\n\nexport const DefaultCardModelSchema = {\n  title: 'Card Model',\n  fieldsets: [\n    {\n      id: 'default',\n      title: 'Default',\n      fields: [],\n    },\n  ],\n  properties: {},\n  required: [],\n};\n\nexport const getVoltoStyles = (props) => {\n  const styles = props ? props : {};\n  const output = {};\n  for (const [key, value] of Object.entries(styles)) {\n    if (styles[key] === true) {\n      output[key] = key;\n    } else {\n      output[value] = value;\n    }\n  }\n  return output;\n};\n\nexport function composeSchema() {\n  const enhancers = Array.from(arguments);\n  const composer = (args) => {\n    const props = enhancers.reduce(\n      (acc, enhancer) => (enhancer ? { ...acc, schema: enhancer(acc) } : acc),\n      { ...args },\n    );\n    return props.schema;\n  };\n  return composer;\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}