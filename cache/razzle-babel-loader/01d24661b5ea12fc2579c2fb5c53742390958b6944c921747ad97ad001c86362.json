{"ast":null,"code":"import _extends from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/extends.js\";\nimport _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar _jsxFileName = \"/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/components/manage/Blocks/Search/hocs/withSearch.jsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nvar __jsx = React.createElement;\nimport React from 'react';\nimport { useSelector } from 'react-redux';\nimport qs from 'query-string';\nimport { useLocation, useHistory } from 'react-router-dom';\nimport { resolveExtension } from '@plone/volto/helpers/Extensions/withBlockExtensions';\nimport config from '@plone/volto/registry';\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\nvar SEARCH_ENDPOINT_FIELDS = ['SearchableText', 'b_size', 'limit', 'sort_on', 'sort_order'];\nvar PAQO = 'plone.app.querystring.operation';\n\n/**\n * Based on URL state, gets an initial internal state for the search\n *\n * @function getInitialState\n *\n */\nfunction getInitialState(data, facets, urlSearchText, id) {\n  var _data$query, _data$query2, _data$query3, _data$query4, _data$query5;\n  var facetWidgetTypes = config.blocks.blocksConfig.search.extensions.facetWidgets.types;\n  var facetSettings = (data === null || data === void 0 ? void 0 : data.facets) || [];\n  return {\n    query: [].concat(_toConsumableArray(((_data$query = data.query) === null || _data$query === void 0 ? void 0 : _data$query.query) || []), _toConsumableArray((facetSettings || []).map(function (facet) {\n      if (!(facet !== null && facet !== void 0 && facet.field)) return null;\n      var _resolveExtension = resolveExtension('type', facetWidgetTypes, facet),\n        valueToQuery = _resolveExtension.valueToQuery;\n      var name = facet.field.value;\n      var value = facets[name];\n      return valueToQuery({\n        value: value,\n        facet: facet\n      });\n    }).filter(function (f) {\n      return !!f;\n    })), _toConsumableArray(urlSearchText ? [{\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: urlSearchText\n    }] : [])),\n    sort_on: (_data$query2 = data.query) === null || _data$query2 === void 0 ? void 0 : _data$query2.sort_on,\n    sort_order: (_data$query3 = data.query) === null || _data$query3 === void 0 ? void 0 : _data$query3.sort_order,\n    b_size: (_data$query4 = data.query) === null || _data$query4 === void 0 ? void 0 : _data$query4.b_size,\n    limit: (_data$query5 = data.query) === null || _data$query5 === void 0 ? void 0 : _data$query5.limit,\n    block: id\n  };\n}\n\n/**\n * \"Normalizes\" the search state to something that's serializable\n * (for querying) and used to compute data for the ListingBody\n *\n * @function normalizeState\n *\n */\nfunction normalizeState(_ref) {\n  var query = _ref.query,\n    facets = _ref.facets,\n    id = _ref.id,\n    searchText = _ref.searchText,\n    sortOn = _ref.sortOn,\n    sortOrder = _ref.sortOrder,\n    facetSettings = _ref.facetSettings;\n  var facetWidgetTypes = config.blocks.blocksConfig.search.extensions.facetWidgets.types;\n  var params = {\n    query: [].concat(_toConsumableArray(query.query || []), _toConsumableArray((facetSettings || []).map(function (facet) {\n      if (!(facet !== null && facet !== void 0 && facet.field)) return null;\n      var _resolveExtension2 = resolveExtension('type', facetWidgetTypes, facet),\n        valueToQuery = _resolveExtension2.valueToQuery;\n      var name = facet.field.value;\n      var value = facets[name];\n      return valueToQuery({\n        value: value,\n        facet: facet\n      });\n    }))).filter(function (o) {\n      return !!o;\n    }),\n    sort_on: sortOn || query.sort_on,\n    sort_order: sortOrder || query.sort_order,\n    b_size: query.b_size,\n    limit: query.limit,\n    block: id\n  };\n\n  // TODO: need to check if SearchableText facet is not already in the query\n  // Ideally the searchtext functionality should be restructured as being just\n  // another facet\n  params.query = params.query.reduce(\n  // Remove SearchableText from query\n  function (acc, kvp) {\n    return kvp.i === 'SearchableText' ? acc : [].concat(_toConsumableArray(acc), [kvp]);\n  }, []);\n  if (searchText) {\n    params.query.push({\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: searchText\n    });\n  }\n  return params;\n}\nvar getSearchFields = function getSearchFields(searchData) {\n  return Object.assign.apply(Object, [{}].concat(_toConsumableArray(SEARCH_ENDPOINT_FIELDS.map(function (k) {\n    return searchData[k] ? _defineProperty({}, k, searchData[k]) : {};\n  })), [searchData.query ? {\n    query: serializeQuery(searchData['query'])\n  } : {}]));\n};\n\n/**\n * A HOC that will mirror the search block state to a hash location\n */\nvar useHashState = function useHashState() {\n  _s();\n  var location = useLocation();\n  var history = useHistory();\n  var oldState = React.useMemo(function () {\n    return _objectSpread(_objectSpread({}, qs.parse(location.search)), qs.parse(location.hash));\n  }, [location.hash, location.search]);\n\n  // This creates a shallow copy. Why is this needed?\n  var current = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Array.from(Object.keys(oldState)).map(function (k) {\n    return _defineProperty({}, k, oldState[k]);\n  }))));\n  var setSearchData = React.useCallback(function (searchData) {\n    var newParams = qs.parse(location.hash);\n    var changed = false;\n    Object.keys(searchData).sort().forEach(function (k) {\n      if (searchData[k]) {\n        newParams[k] = searchData[k];\n        if (oldState[k] !== searchData[k]) {\n          changed = true;\n        }\n      }\n    });\n    if (changed) {\n      history.push({\n        hash: qs.stringify(newParams)\n      });\n    }\n  }, [history, oldState, location.hash]);\n  return [current, setSearchData];\n};\n\n/**\n * A hook to make it possible to switch disable mirroring the search block\n * state to the window location. When using the internal state we \"start from\n * scratch\", as it's intended to be used in the edit page.\n */\n_s(useHashState, \"RKebonFl10519tdQ2E8Tb9qO30c=\", false, function () {\n  return [useLocation, useHistory];\n});\nvar useSearchBlockState = function useSearchBlockState(uniqueId, isEditMode) {\n  _s2();\n  var _useHashState = useHashState(),\n    _useHashState2 = _slicedToArray(_useHashState, 2),\n    hashState = _useHashState2[0],\n    setHashState = _useHashState2[1];\n  var _React$useState = React.useState({}),\n    _React$useState2 = _slicedToArray(_React$useState, 2),\n    internalState = _React$useState2[0],\n    setInternalState = _React$useState2[1];\n  return isEditMode ? [internalState, setInternalState] : [hashState, setHashState];\n};\n\n// Simple compress/decompress the state in URL by replacing the lengthy string\n_s2(useSearchBlockState, \"64MUY7jQ4c8NOtDIu0I8w22Ik4A=\", false, function () {\n  return [useHashState];\n});\nvar deserializeQuery = function deserializeQuery(q) {\n  var _JSON$parse;\n  return (_JSON$parse = JSON.parse(q)) === null || _JSON$parse === void 0 ? void 0 : _JSON$parse.map(function (kvp) {\n    return _objectSpread(_objectSpread({}, kvp), {}, {\n      o: kvp.o.replace(/^paqo/, PAQO)\n    });\n  });\n};\nvar serializeQuery = function serializeQuery(q) {\n  return JSON.stringify(q === null || q === void 0 ? void 0 : q.map(function (kvp) {\n    return _objectSpread(_objectSpread({}, kvp), {}, {\n      o: kvp.o.replace(PAQO, 'paqo')\n    });\n  }));\n};\nvar withSearch = function withSearch(options) {\n  return function (WrappedComponent) {\n    var _s3 = $RefreshSig$();\n    var _ref4 = options || {},\n      _ref4$inputDelay = _ref4.inputDelay,\n      inputDelay = _ref4$inputDelay === void 0 ? 1000 : _ref4$inputDelay;\n    function WithSearch(props) {\n      _s3();\n      var _urlQuery$find, _data$facets, _data$facets2, _data$query6, _data$query7, _querystringResults$i, _querystringResults$i2, _querystringResults$i3;\n      var data = props.data,\n        id = props.id,\n        _props$editable = props.editable,\n        editable = _props$editable === void 0 ? false : _props$editable;\n      var _useSearchBlockState = useSearchBlockState(id, editable),\n        _useSearchBlockState2 = _slicedToArray(_useSearchBlockState, 2),\n        locationSearchData = _useSearchBlockState2[0],\n        setLocationSearchData = _useSearchBlockState2[1];\n      var urlQuery = locationSearchData.query ? deserializeQuery(locationSearchData.query) : [];\n      var urlSearchText = locationSearchData.SearchableText || ((_urlQuery$find = urlQuery.find(function (_ref5) {\n        var i = _ref5.i;\n        return i === 'SearchableText';\n      })) === null || _urlQuery$find === void 0 ? void 0 : _urlQuery$find.v) || '';\n\n      // TODO: refactor, should use only useLocationStateManager()!!!\n      var _React$useState3 = React.useState(urlSearchText),\n        _React$useState4 = _slicedToArray(_React$useState3, 2),\n        searchText = _React$useState4[0],\n        setSearchText = _React$useState4[1];\n      var configuredFacets = ((_data$facets = data.facets) === null || _data$facets === void 0 ? void 0 : _data$facets.map(function (facet) {\n        var _facet$field;\n        return facet === null || facet === void 0 ? void 0 : (_facet$field = facet.field) === null || _facet$field === void 0 ? void 0 : _facet$field.value;\n      })) || [];\n      var multiFacets = (_data$facets2 = data.facets) === null || _data$facets2 === void 0 ? void 0 : _data$facets2.filter(function (facet) {\n        return facet === null || facet === void 0 ? void 0 : facet.multiple;\n      }).map(function (facet) {\n        var _facet$field2;\n        return facet === null || facet === void 0 ? void 0 : (_facet$field2 = facet.field) === null || _facet$field2 === void 0 ? void 0 : _facet$field2.value;\n      });\n      var _React$useState5 = React.useState(Object.assign.apply(Object, [{}].concat(_toConsumableArray(urlQuery.map(function (_ref6) {\n          var i = _ref6.i,\n            v = _ref6.v;\n          return _defineProperty({}, i, v);\n        })), _toConsumableArray(configuredFacets.map(function (f) {\n          return locationSearchData[f] ? _defineProperty({}, f, multiFacets.indexOf(f) > -1 ? [locationSearchData[f]] : locationSearchData[f]) : {};\n        }))))),\n        _React$useState6 = _slicedToArray(_React$useState5, 2),\n        facets = _React$useState6[0],\n        setFacets = _React$useState6[1];\n      var _React$useState7 = React.useState(data === null || data === void 0 ? void 0 : (_data$query6 = data.query) === null || _data$query6 === void 0 ? void 0 : _data$query6.sort_on),\n        _React$useState8 = _slicedToArray(_React$useState7, 2),\n        sortOn = _React$useState8[0],\n        setSortOn = _React$useState8[1];\n      var _React$useState9 = React.useState(data === null || data === void 0 ? void 0 : (_data$query7 = data.query) === null || _data$query7 === void 0 ? void 0 : _data$query7.sort_order),\n        _React$useState10 = _slicedToArray(_React$useState9, 2),\n        sortOrder = _React$useState10[0],\n        setSortOrder = _React$useState10[1];\n      var _React$useState11 = React.useState(getInitialState(data, facets, urlSearchText, id)),\n        _React$useState12 = _slicedToArray(_React$useState11, 2),\n        searchData = _React$useState12[0],\n        setSearchData = _React$useState12[1];\n      var timeoutRef = React.useRef();\n      var facetSettings = data === null || data === void 0 ? void 0 : data.facets;\n      var onTriggerSearch = React.useCallback(function (toSearchText, toSearchFacets, toSortOn, toSortOrder) {\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(function () {\n          var searchData = normalizeState({\n            id: id,\n            query: data.query || {},\n            facets: toSearchFacets || facets,\n            searchText: toSearchText,\n            sortOn: toSortOn || sortOn,\n            sortOrder: toSortOrder || sortOrder,\n            facetSettings: facetSettings\n          });\n          if (toSearchFacets) setFacets(toSearchFacets);\n          if (toSortOn) setSortOn(toSortOn);\n          if (toSortOrder) setSortOrder(toSortOrder);\n          setSearchData(searchData);\n          setLocationSearchData(getSearchFields(searchData));\n        }, toSearchFacets ? inputDelay / 3 : inputDelay);\n      }, [data.query, facets, id, setLocationSearchData, sortOn, sortOrder, facetSettings]);\n      var querystringResults = useSelector(function (state) {\n        return state.querystringsearch.subrequests;\n      });\n      var totalItems = ((_querystringResults$i = querystringResults[id]) === null || _querystringResults$i === void 0 ? void 0 : _querystringResults$i.total) || ((_querystringResults$i2 = querystringResults[id]) === null || _querystringResults$i2 === void 0 ? void 0 : (_querystringResults$i3 = _querystringResults$i2.items) === null || _querystringResults$i3 === void 0 ? void 0 : _querystringResults$i3.length);\n      return __jsx(WrappedComponent, _extends({}, props, {\n        searchData: searchData,\n        facets: facets,\n        setFacets: setFacets,\n        setSortOn: setSortOn,\n        setSortOrder: setSortOrder,\n        sortOn: sortOn,\n        sortOrder: sortOrder,\n        searchedText: urlSearchText,\n        searchText: searchText,\n        setSearchText: setSearchText,\n        onTriggerSearch: onTriggerSearch,\n        totalItems: totalItems,\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 322,\n          columnNumber: 7\n        }\n      }));\n    }\n    _s3(WithSearch, \"y8DFvzZLYHl9LkRn1Yg9rEwVsjY=\", false, function () {\n      return [useSearchBlockState, useSelector];\n    });\n    WithSearch.displayName = \"WithSearch(\".concat(getDisplayName(WrappedComponent), \")\");\n    return WithSearch;\n  };\n};\nexport default withSearch;","map":{"version":3,"names":["React","useSelector","qs","useLocation","useHistory","resolveExtension","config","getDisplayName","WrappedComponent","displayName","name","SEARCH_ENDPOINT_FIELDS","PAQO","getInitialState","data","facets","urlSearchText","id","facetWidgetTypes","blocks","blocksConfig","search","extensions","facetWidgets","types","facetSettings","query","map","facet","field","valueToQuery","value","filter","f","i","o","v","sort_on","sort_order","b_size","limit","block","normalizeState","searchText","sortOn","sortOrder","params","reduce","acc","kvp","push","getSearchFields","searchData","Object","assign","k","serializeQuery","useHashState","location","history","oldState","useMemo","parse","hash","current","Array","from","keys","setSearchData","useCallback","newParams","changed","sort","forEach","stringify","useSearchBlockState","uniqueId","isEditMode","hashState","setHashState","useState","internalState","setInternalState","deserializeQuery","q","JSON","replace","withSearch","options","inputDelay","WithSearch","props","editable","locationSearchData","setLocationSearchData","urlQuery","SearchableText","find","setSearchText","configuredFacets","multiFacets","multiple","indexOf","setFacets","setSortOn","setSortOrder","timeoutRef","useRef","onTriggerSearch","toSearchText","toSearchFacets","toSortOn","toSortOrder","clearTimeout","setTimeout","querystringResults","state","querystringsearch","subrequests","totalItems","total","items","length"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/components/manage/Blocks/Search/hocs/withSearch.jsx"],"sourcesContent":["import React from 'react';\nimport { useSelector } from 'react-redux';\nimport qs from 'query-string';\nimport { useLocation, useHistory } from 'react-router-dom';\n\nimport { resolveExtension } from '@plone/volto/helpers/Extensions/withBlockExtensions';\nimport config from '@plone/volto/registry';\n\nfunction getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nconst SEARCH_ENDPOINT_FIELDS = [\n  'SearchableText',\n  'b_size',\n  'limit',\n  'sort_on',\n  'sort_order',\n];\n\nconst PAQO = 'plone.app.querystring.operation';\n\n/**\n * Based on URL state, gets an initial internal state for the search\n *\n * @function getInitialState\n *\n */\nfunction getInitialState(data, facets, urlSearchText, id) {\n  const {\n    types: facetWidgetTypes,\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n  const facetSettings = data?.facets || [];\n\n  return {\n    query: [\n      ...(data.query?.query || []),\n      ...(facetSettings || [])\n        .map((facet) => {\n          if (!facet?.field) return null;\n\n          const { valueToQuery } = resolveExtension(\n            'type',\n            facetWidgetTypes,\n            facet,\n          );\n\n          const name = facet.field.value;\n          const value = facets[name];\n\n          return valueToQuery({ value, facet });\n        })\n        .filter((f) => !!f),\n      ...(urlSearchText\n        ? [\n            {\n              i: 'SearchableText',\n              o: 'plone.app.querystring.operation.string.contains',\n              v: urlSearchText,\n            },\n          ]\n        : []),\n    ],\n    sort_on: data.query?.sort_on,\n    sort_order: data.query?.sort_order,\n    b_size: data.query?.b_size,\n    limit: data.query?.limit,\n    block: id,\n  };\n}\n\n/**\n * \"Normalizes\" the search state to something that's serializable\n * (for querying) and used to compute data for the ListingBody\n *\n * @function normalizeState\n *\n */\nfunction normalizeState({\n  query, // base query\n  facets, // facet values\n  id, // block id\n  searchText, // SearchableText\n  sortOn,\n  sortOrder,\n  facetSettings, // data.facets extracted from block data\n}) {\n  const {\n    types: facetWidgetTypes,\n  } = config.blocks.blocksConfig.search.extensions.facetWidgets;\n\n  const params = {\n    query: [\n      ...(query.query || []),\n      ...(facetSettings || []).map((facet) => {\n        if (!facet?.field) return null;\n\n        const { valueToQuery } = resolveExtension(\n          'type',\n          facetWidgetTypes,\n          facet,\n        );\n\n        const name = facet.field.value;\n        const value = facets[name];\n\n        return valueToQuery({ value, facet });\n      }),\n    ].filter((o) => !!o),\n    sort_on: sortOn || query.sort_on,\n    sort_order: sortOrder || query.sort_order,\n    b_size: query.b_size,\n    limit: query.limit,\n    block: id,\n  };\n\n  // TODO: need to check if SearchableText facet is not already in the query\n  // Ideally the searchtext functionality should be restructured as being just\n  // another facet\n  params.query = params.query.reduce(\n    // Remove SearchableText from query\n    (acc, kvp) => (kvp.i === 'SearchableText' ? acc : [...acc, kvp]),\n    [],\n  );\n  if (searchText) {\n    params.query.push({\n      i: 'SearchableText',\n      o: 'plone.app.querystring.operation.string.contains',\n      v: searchText,\n    });\n  }\n\n  return params;\n}\n\nconst getSearchFields = (searchData) => {\n  return Object.assign(\n    {},\n    ...SEARCH_ENDPOINT_FIELDS.map((k) => {\n      return searchData[k] ? { [k]: searchData[k] } : {};\n    }),\n    searchData.query ? { query: serializeQuery(searchData['query']) } : {},\n  );\n};\n\n/**\n * A HOC that will mirror the search block state to a hash location\n */\nconst useHashState = () => {\n  const location = useLocation();\n  const history = useHistory();\n\n  const oldState = React.useMemo(() => {\n    return {\n      ...qs.parse(location.search),\n      ...qs.parse(location.hash),\n    };\n  }, [location.hash, location.search]);\n\n  // This creates a shallow copy. Why is this needed?\n  const current = Object.assign(\n    {},\n    ...Array.from(Object.keys(oldState)).map((k) => ({ [k]: oldState[k] })),\n  );\n\n  const setSearchData = React.useCallback(\n    (searchData) => {\n      const newParams = qs.parse(location.hash);\n\n      let changed = false;\n\n      Object.keys(searchData)\n        .sort()\n        .forEach((k) => {\n          if (searchData[k]) {\n            newParams[k] = searchData[k];\n            if (oldState[k] !== searchData[k]) {\n              changed = true;\n            }\n          }\n        });\n\n      if (changed) {\n        history.push({\n          hash: qs.stringify(newParams),\n        });\n      }\n    },\n    [history, oldState, location.hash],\n  );\n\n  return [current, setSearchData];\n};\n\n/**\n * A hook to make it possible to switch disable mirroring the search block\n * state to the window location. When using the internal state we \"start from\n * scratch\", as it's intended to be used in the edit page.\n */\nconst useSearchBlockState = (uniqueId, isEditMode) => {\n  const [hashState, setHashState] = useHashState();\n  const [internalState, setInternalState] = React.useState({});\n\n  return isEditMode\n    ? [internalState, setInternalState]\n    : [hashState, setHashState];\n};\n\n// Simple compress/decompress the state in URL by replacing the lengthy string\nconst deserializeQuery = (q) => {\n  return JSON.parse(q)?.map((kvp) => ({\n    ...kvp,\n    o: kvp.o.replace(/^paqo/, PAQO),\n  }));\n};\nconst serializeQuery = (q) => {\n  return JSON.stringify(\n    q?.map((kvp) => ({ ...kvp, o: kvp.o.replace(PAQO, 'paqo') })),\n  );\n};\n\nconst withSearch = (options) => (WrappedComponent) => {\n  const { inputDelay = 1000 } = options || {};\n\n  function WithSearch(props) {\n    const { data, id, editable = false } = props;\n\n    const [locationSearchData, setLocationSearchData] = useSearchBlockState(\n      id,\n      editable,\n    );\n\n    const urlQuery = locationSearchData.query\n      ? deserializeQuery(locationSearchData.query)\n      : [];\n    const urlSearchText =\n      locationSearchData.SearchableText ||\n      urlQuery.find(({ i }) => i === 'SearchableText')?.v ||\n      '';\n\n    // TODO: refactor, should use only useLocationStateManager()!!!\n    const [searchText, setSearchText] = React.useState(urlSearchText);\n    const configuredFacets =\n      data.facets?.map((facet) => facet?.field?.value) || [];\n    const multiFacets = data.facets\n      ?.filter((facet) => facet?.multiple)\n      .map((facet) => facet?.field?.value);\n    const [facets, setFacets] = React.useState(\n      Object.assign(\n        {},\n        ...urlQuery.map(({ i, v }) => ({ [i]: v })), // TODO: the 'o' should be kept. This would be a major refactoring of the facets\n\n        // support for simple filters like ?Subject=something\n        // TODO: since the move to hash params this is no longer working.\n        // We'd have to treat the location.search and manage it just like the\n        // hash, to support it. We can read it, but we'd have to reset it as\n        // well, so at that point what's the difference to the hash?\n        ...configuredFacets.map((f) =>\n          locationSearchData[f]\n            ? {\n                [f]:\n                  multiFacets.indexOf(f) > -1\n                    ? [locationSearchData[f]]\n                    : locationSearchData[f],\n              }\n            : {},\n        ),\n      ),\n    );\n\n    const [sortOn, setSortOn] = React.useState(data?.query?.sort_on);\n    const [sortOrder, setSortOrder] = React.useState(data?.query?.sort_order);\n\n    const [searchData, setSearchData] = React.useState(\n      getInitialState(data, facets, urlSearchText, id),\n    );\n\n    const timeoutRef = React.useRef();\n    const facetSettings = data?.facets;\n\n    const onTriggerSearch = React.useCallback(\n      (toSearchText, toSearchFacets, toSortOn, toSortOrder) => {\n        if (timeoutRef.current) clearTimeout(timeoutRef.current);\n        timeoutRef.current = setTimeout(\n          () => {\n            const searchData = normalizeState({\n              id,\n              query: data.query || {},\n              facets: toSearchFacets || facets,\n              searchText: toSearchText,\n              sortOn: toSortOn || sortOn,\n              sortOrder: toSortOrder || sortOrder,\n              facetSettings,\n            });\n            if (toSearchFacets) setFacets(toSearchFacets);\n            if (toSortOn) setSortOn(toSortOn);\n            if (toSortOrder) setSortOrder(toSortOrder);\n            setSearchData(searchData);\n            setLocationSearchData(getSearchFields(searchData));\n          },\n          toSearchFacets ? inputDelay / 3 : inputDelay,\n        );\n      },\n      [\n        data.query,\n        facets,\n        id,\n        setLocationSearchData,\n        sortOn,\n        sortOrder,\n        facetSettings,\n      ],\n    );\n\n    const querystringResults = useSelector(\n      (state) => state.querystringsearch.subrequests,\n    );\n    const totalItems =\n      querystringResults[id]?.total || querystringResults[id]?.items?.length;\n\n    return (\n      <WrappedComponent\n        {...props}\n        searchData={searchData}\n        facets={facets}\n        setFacets={setFacets}\n        setSortOn={setSortOn}\n        setSortOrder={setSortOrder}\n        sortOn={sortOn}\n        sortOrder={sortOrder}\n        searchedText={urlSearchText}\n        searchText={searchText}\n        setSearchText={setSearchText}\n        onTriggerSearch={onTriggerSearch}\n        totalItems={totalItems}\n      />\n    );\n  }\n  WithSearch.displayName = `WithSearch(${getDisplayName(WrappedComponent)})`;\n\n  return WithSearch;\n};\n\nexport default withSearch;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}