{"ast":null,"code":"import _omit from \"lodash/omit\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport ReactDOM from 'react-dom';\nimport { v4 as uuid } from 'uuid';\nimport { addBlock, changeBlock, getBlocksFieldname, getBlocksLayoutFieldname } from '@plone/volto/helpers';\nimport { Transforms, Editor, Node, Text, Path } from 'slate';\nimport { serializeNodesToText } from '@plone/volto-slate/editor/render';\nimport config from '@plone/volto/registry';\nfunction fromEntries(pairs) {\n  const res = {};\n  pairs.forEach(p => {\n    res[p[0]] = p[1];\n  });\n  return res;\n}\n\n// TODO: should be made generic, no need for \"prevBlock.value\"\nexport function mergeSlateWithBlockBackward(editor, prevBlock, event) {\n  // To work around current architecture limitations, read the value from\n  // previous block. Replace it in the current editor (over which we have\n  // control), join with current block value, then use this result for previous\n  // block, delete current block\n\n  const prev = prevBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, {\n    edge: 'start'\n  });\n  let rangeRef;\n  let end;\n  Editor.withoutNormalizing(editor, () => {\n    // insert block #0 contents in block #1 contents, at the beginning\n    Transforms.insertNodes(editor, prev, {\n      at: Editor.start(editor, [])\n    });\n\n    // the contents that should be moved into the `ul`, as the last `li`\n    rangeRef = Editor.rangeRef(editor, {\n      anchor: Editor.start(editor, [1]),\n      focus: Editor.end(editor, [1])\n    });\n    const source = rangeRef.current;\n    end = Editor.end(editor, [0]);\n    let endPoint;\n    Transforms.insertNodes(editor, {\n      text: ''\n    }, {\n      at: end\n    });\n    end = Editor.end(editor, [0]);\n    Transforms.splitNodes(editor, {\n      at: end,\n      always: true,\n      height: 1,\n      mode: 'highest',\n      match: n => n.type === 'li' || Text.isText(n)\n    });\n    endPoint = Editor.end(editor, [0]);\n    Transforms.moveNodes(editor, {\n      at: source,\n      to: endPoint.path,\n      mode: 'all',\n      match: (n, p) => p.length === 2\n    });\n  });\n  const [n] = Editor.node(editor, [1]);\n  if (Editor.isEmpty(editor, n)) {\n    Transforms.removeNodes(editor, {\n      at: [1]\n    });\n  }\n  rangeRef.unref();\n  const [, lastPath] = Editor.last(editor, [0]);\n  end = Editor.start(editor, Path.parent(lastPath));\n  return end;\n}\nexport function mergeSlateWithBlockForward(editor, nextBlock, event) {\n  // To work around current architecture limitations, read the value from next\n  // block. Replace it in the current editor (over which we have control), join\n  // with current block value, then use this result for next block, delete\n  // current block\n\n  const next = nextBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, {\n    edge: 'end'\n  });\n  Transforms.insertNodes(editor, next, {\n    at: Editor.end(editor, [])\n  });\n  Editor.deleteForward(editor, {\n    unit: 'character'\n  });\n}\nexport function syncCreateSlateBlock(value) {\n  const id = uuid();\n  const block = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(value)),\n    plaintext: serializeNodesToText(value)\n  };\n  return [id, block];\n}\nexport function createImageBlock(url, index, props) {\n  const {\n    properties,\n    onChangeField,\n    onSelectBlock\n  } = props;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const [id, formData] = addBlock(properties, 'image', index + 1);\n  const newFormData = changeBlock(formData, id, {\n    '@type': 'image',\n    url\n  });\n  ReactDOM.unstable_batchedUpdates(() => {\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(id);\n  });\n}\nexport const createAndSelectNewBlockAfter = (editor, blockValue) => {\n  const blockProps = editor.getBlockProps();\n  const {\n    onSelectBlock,\n    properties,\n    index,\n    onChangeField\n  } = blockProps;\n  const [blockId, formData] = addBlock(properties, 'slate', index + 1);\n  const options = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(blockValue)),\n    plaintext: serializeNodesToText(blockValue)\n  };\n  const newFormData = changeBlock(formData, blockId, options);\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  // console.log('layout', blocksLayoutFieldname, newFormData);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    blockProps.saveSlateBlockSelection(blockId, 'start');\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(blockId);\n  });\n};\nexport function getNextVoltoBlock(index, properties) {\n  // TODO: look for any next slate block\n  // join this block with previous block, if previous block is slate\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const blocks_layout = properties[blocksLayoutFieldname];\n  if (index === blocks_layout.items.length) return;\n  const nextBlockId = blocks_layout.items[index + 1];\n  const nextBlock = properties[blocksFieldname][nextBlockId];\n  return [nextBlock, nextBlockId];\n}\nexport function getPreviousVoltoBlock(index, properties) {\n  // TODO: look for any prev slate block\n  if (index === 0) return;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  const blocks_layout = properties[blocksLayoutFieldname];\n  const prevBlockId = blocks_layout.items[index - 1];\n  const prevBlock = properties[blocksFieldname][prevBlockId];\n  return [prevBlock, prevBlockId];\n}\n\n// //check for existing img children\n// const checkContainImg = (elements) => {\n//   var check = false;\n//   elements.forEach((e) =>\n//     e.children.forEach((c) => {\n//       if (c && c.type && c.type === 'img') {\n//         check = true;\n//       }\n//     }),\n//   );\n//   return check;\n// };\n\n// //check for existing table children\n// const checkContainTable = (elements) => {\n//   var check = false;\n//   elements.forEach((e) => {\n//     if (e && e.type && e.type === 'table') {\n//       check = true;\n//     }\n//   });\n//   return check;\n// };\n\n/**\n * The editor has the properties `dataTransferHandlers` (object) and\n * `dataTransferFormatsOrder` and in `dataTransferHandlers` are functions which\n * sometimes must call this function. Some types of data storeable in Slate\n * documents can be and should be put into separate Volto blocks. The\n * `deconstructToVoltoBlocks` function scans the contents of the Slate document\n * and, through configured Volto block emitters, it outputs separate Volto\n * blocks into the same Volto page form. The `deconstructToVoltoBlocks` function\n * should be called only in key places where it is necessary.\n *\n * @example See the `src/editor/extensions/insertData.js` file.\n *\n * @param {Editor} editor The Slate editor object which should be deconstructed\n * if possible.\n *\n * @returns {Promise}\n */\nexport function deconstructToVoltoBlocks(editor) {\n  // Explodes editor content into separate blocks\n  // If the editor has multiple top-level children, split the current block\n  // into multiple slate blocks. This will delete and replace the current\n  // block.\n  //\n  // It returns a promise that, when resolved, will pass a list of Volto block\n  // ids that were affected\n  //\n  // For the Volto blocks manipulation we do low-level changes to the context\n  // form state, as that ensures a better performance (no un-needed UI updates)\n\n  if (!editor.getBlockProps) return;\n  const blockProps = editor.getBlockProps();\n  const {\n    slate\n  } = config.settings;\n  const {\n    voltoBlockEmiters\n  } = slate;\n  return new Promise((resolve, reject) => {\n    if (!(editor !== null && editor !== void 0 && editor.children)) return;\n    if (editor.children.length === 1) {\n      return resolve([blockProps.block]);\n    }\n    const {\n      properties,\n      onChangeField,\n      onSelectBlock\n    } = editor.getBlockProps();\n    const blocksFieldname = getBlocksFieldname(properties);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n    const {\n      index\n    } = blockProps;\n    let blocks = [];\n\n    // TODO: should use Editor.levels() instead of Node.children\n    const pathRefs = Array.from(Node.children(editor, [])).map(([, path]) => Editor.pathRef(editor, path));\n    for (const pathRef of pathRefs) {\n      // extra nodes are always extracted after the text node\n      let extras = voltoBlockEmiters.map(emit => emit(editor, pathRef)).flat(1);\n\n      // The node might have been replaced with a Volto block\n      if (pathRef.current) {\n        const [childNode] = Editor.node(editor, pathRef.current);\n        if (childNode && !Editor.isEmpty(editor, childNode)) blocks.push(syncCreateSlateBlock([childNode]));\n      }\n      blocks = [...blocks, ...extras];\n    }\n    const blockids = blocks.map(b => b[0]);\n\n    // TODO: add the placeholder block, because we remove it\n    // (when we remove the current block)\n\n    const blocksData = _omit(_objectSpread(_objectSpread({}, properties[blocksFieldname]), fromEntries(blocks)), blockProps.block);\n    const layoutData = _objectSpread(_objectSpread({}, properties[blocksLayoutFieldname]), {}, {\n      items: [...properties[blocksLayoutFieldname].items.slice(0, index), ...blockids, ...properties[blocksLayoutFieldname].items.slice(index)].filter(id => id !== blockProps.block)\n    });\n\n    // TODO: use onChangeFormData instead of this API style\n    ReactDOM.unstable_batchedUpdates(() => {\n      onChangeField(blocksFieldname, blocksData);\n      onChangeField(blocksLayoutFieldname, layoutData);\n      onSelectBlock(blockids[blockids.length - 1]);\n      // resolve(blockids);\n      // or rather this?\n      Promise.resolve().then(resolve(blockids));\n    });\n  });\n}","map":{"version":3,"names":["ReactDOM","v4","uuid","addBlock","changeBlock","getBlocksFieldname","getBlocksLayoutFieldname","Transforms","Editor","Node","Text","Path","serializeNodesToText","config","fromEntries","pairs","res","forEach","p","mergeSlateWithBlockBackward","editor","prevBlock","event","prev","value","collapse","edge","rangeRef","end","withoutNormalizing","insertNodes","at","start","anchor","focus","source","current","endPoint","text","splitNodes","always","height","mode","match","n","type","isText","moveNodes","to","path","length","node","isEmpty","removeNodes","unref","lastPath","last","parent","mergeSlateWithBlockForward","nextBlock","next","deleteForward","unit","syncCreateSlateBlock","id","block","JSON","parse","stringify","plaintext","createImageBlock","url","index","props","properties","onChangeField","onSelectBlock","blocksFieldname","blocksLayoutFieldname","formData","newFormData","unstable_batchedUpdates","createAndSelectNewBlockAfter","blockValue","blockProps","getBlockProps","blockId","options","saveSlateBlockSelection","getNextVoltoBlock","blocks_layout","items","nextBlockId","getPreviousVoltoBlock","prevBlockId","deconstructToVoltoBlocks","slate","settings","voltoBlockEmiters","Promise","resolve","reject","children","blocks","pathRefs","Array","from","map","pathRef","extras","emit","flat","childNode","push","blockids","b","blocksData","layoutData","slice","filter","then"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/packages/volto-slate/src/utils/volto-blocks.js"],"sourcesContent":["import ReactDOM from 'react-dom';\nimport { v4 as uuid } from 'uuid';\nimport {\n  addBlock,\n  changeBlock,\n  getBlocksFieldname,\n  getBlocksLayoutFieldname,\n} from '@plone/volto/helpers';\nimport { Transforms, Editor, Node, Text, Path } from 'slate';\nimport { serializeNodesToText } from '@plone/volto-slate/editor/render';\nimport { omit } from 'lodash';\nimport config from '@plone/volto/registry';\n\nfunction fromEntries(pairs) {\n  const res = {};\n  pairs.forEach((p) => {\n    res[p[0]] = p[1];\n  });\n  return res;\n}\n\n// TODO: should be made generic, no need for \"prevBlock.value\"\nexport function mergeSlateWithBlockBackward(editor, prevBlock, event) {\n  // To work around current architecture limitations, read the value from\n  // previous block. Replace it in the current editor (over which we have\n  // control), join with current block value, then use this result for previous\n  // block, delete current block\n\n  const prev = prevBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, { edge: 'start' });\n\n  let rangeRef;\n  let end;\n\n  Editor.withoutNormalizing(editor, () => {\n    // insert block #0 contents in block #1 contents, at the beginning\n    Transforms.insertNodes(editor, prev, {\n      at: Editor.start(editor, []),\n    });\n\n    // the contents that should be moved into the `ul`, as the last `li`\n    rangeRef = Editor.rangeRef(editor, {\n      anchor: Editor.start(editor, [1]),\n      focus: Editor.end(editor, [1]),\n    });\n\n    const source = rangeRef.current;\n\n    end = Editor.end(editor, [0]);\n\n    let endPoint;\n\n    Transforms.insertNodes(editor, { text: '' }, { at: end });\n\n    end = Editor.end(editor, [0]);\n\n    Transforms.splitNodes(editor, {\n      at: end,\n      always: true,\n      height: 1,\n      mode: 'highest',\n      match: (n) => n.type === 'li' || Text.isText(n),\n    });\n\n    endPoint = Editor.end(editor, [0]);\n\n    Transforms.moveNodes(editor, {\n      at: source,\n      to: endPoint.path,\n      mode: 'all',\n      match: (n, p) => p.length === 2,\n    });\n  });\n\n  const [n] = Editor.node(editor, [1]);\n\n  if (Editor.isEmpty(editor, n)) {\n    Transforms.removeNodes(editor, { at: [1] });\n  }\n\n  rangeRef.unref();\n\n  const [, lastPath] = Editor.last(editor, [0]);\n\n  end = Editor.start(editor, Path.parent(lastPath));\n\n  return end;\n}\n\nexport function mergeSlateWithBlockForward(editor, nextBlock, event) {\n  // To work around current architecture limitations, read the value from next\n  // block. Replace it in the current editor (over which we have control), join\n  // with current block value, then use this result for next block, delete\n  // current block\n\n  const next = nextBlock.value;\n\n  // collapse the selection to its start point\n  Transforms.collapse(editor, { edge: 'end' });\n  Transforms.insertNodes(editor, next, {\n    at: Editor.end(editor, []),\n  });\n\n  Editor.deleteForward(editor, { unit: 'character' });\n}\n\nexport function syncCreateSlateBlock(value) {\n  const id = uuid();\n  const block = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(value)),\n    plaintext: serializeNodesToText(value),\n  };\n  return [id, block];\n}\n\nexport function createImageBlock(url, index, props) {\n  const { properties, onChangeField, onSelectBlock } = props;\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const [id, formData] = addBlock(properties, 'image', index + 1);\n  const newFormData = changeBlock(formData, id, { '@type': 'image', url });\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(id);\n  });\n}\n\nexport const createAndSelectNewBlockAfter = (editor, blockValue) => {\n  const blockProps = editor.getBlockProps();\n\n  const { onSelectBlock, properties, index, onChangeField } = blockProps;\n\n  const [blockId, formData] = addBlock(properties, 'slate', index + 1);\n\n  const options = {\n    '@type': 'slate',\n    value: JSON.parse(JSON.stringify(blockValue)),\n    plaintext: serializeNodesToText(blockValue),\n  };\n\n  const newFormData = changeBlock(formData, blockId, options);\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n  // console.log('layout', blocksLayoutFieldname, newFormData);\n\n  ReactDOM.unstable_batchedUpdates(() => {\n    blockProps.saveSlateBlockSelection(blockId, 'start');\n    onChangeField(blocksFieldname, newFormData[blocksFieldname]);\n    onChangeField(blocksLayoutFieldname, newFormData[blocksLayoutFieldname]);\n    onSelectBlock(blockId);\n  });\n};\n\nexport function getNextVoltoBlock(index, properties) {\n  // TODO: look for any next slate block\n  // join this block with previous block, if previous block is slate\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const blocks_layout = properties[blocksLayoutFieldname];\n\n  if (index === blocks_layout.items.length) return;\n\n  const nextBlockId = blocks_layout.items[index + 1];\n  const nextBlock = properties[blocksFieldname][nextBlockId];\n\n  return [nextBlock, nextBlockId];\n}\n\nexport function getPreviousVoltoBlock(index, properties) {\n  // TODO: look for any prev slate block\n  if (index === 0) return;\n\n  const blocksFieldname = getBlocksFieldname(properties);\n  const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n  const blocks_layout = properties[blocksLayoutFieldname];\n  const prevBlockId = blocks_layout.items[index - 1];\n  const prevBlock = properties[blocksFieldname][prevBlockId];\n\n  return [prevBlock, prevBlockId];\n}\n\n// //check for existing img children\n// const checkContainImg = (elements) => {\n//   var check = false;\n//   elements.forEach((e) =>\n//     e.children.forEach((c) => {\n//       if (c && c.type && c.type === 'img') {\n//         check = true;\n//       }\n//     }),\n//   );\n//   return check;\n// };\n\n// //check for existing table children\n// const checkContainTable = (elements) => {\n//   var check = false;\n//   elements.forEach((e) => {\n//     if (e && e.type && e.type === 'table') {\n//       check = true;\n//     }\n//   });\n//   return check;\n// };\n\n/**\n * The editor has the properties `dataTransferHandlers` (object) and\n * `dataTransferFormatsOrder` and in `dataTransferHandlers` are functions which\n * sometimes must call this function. Some types of data storeable in Slate\n * documents can be and should be put into separate Volto blocks. The\n * `deconstructToVoltoBlocks` function scans the contents of the Slate document\n * and, through configured Volto block emitters, it outputs separate Volto\n * blocks into the same Volto page form. The `deconstructToVoltoBlocks` function\n * should be called only in key places where it is necessary.\n *\n * @example See the `src/editor/extensions/insertData.js` file.\n *\n * @param {Editor} editor The Slate editor object which should be deconstructed\n * if possible.\n *\n * @returns {Promise}\n */\nexport function deconstructToVoltoBlocks(editor) {\n  // Explodes editor content into separate blocks\n  // If the editor has multiple top-level children, split the current block\n  // into multiple slate blocks. This will delete and replace the current\n  // block.\n  //\n  // It returns a promise that, when resolved, will pass a list of Volto block\n  // ids that were affected\n  //\n  // For the Volto blocks manipulation we do low-level changes to the context\n  // form state, as that ensures a better performance (no un-needed UI updates)\n\n  if (!editor.getBlockProps) return;\n\n  const blockProps = editor.getBlockProps();\n  const { slate } = config.settings;\n  const { voltoBlockEmiters } = slate;\n\n  return new Promise((resolve, reject) => {\n    if (!editor?.children) return;\n\n    if (editor.children.length === 1) {\n      return resolve([blockProps.block]);\n    }\n    const { properties, onChangeField, onSelectBlock } = editor.getBlockProps();\n    const blocksFieldname = getBlocksFieldname(properties);\n    const blocksLayoutFieldname = getBlocksLayoutFieldname(properties);\n\n    const { index } = blockProps;\n    let blocks = [];\n\n    // TODO: should use Editor.levels() instead of Node.children\n    const pathRefs = Array.from(Node.children(editor, [])).map(([, path]) =>\n      Editor.pathRef(editor, path),\n    );\n\n    for (const pathRef of pathRefs) {\n      // extra nodes are always extracted after the text node\n      let extras = voltoBlockEmiters\n        .map((emit) => emit(editor, pathRef))\n        .flat(1);\n\n      // The node might have been replaced with a Volto block\n      if (pathRef.current) {\n        const [childNode] = Editor.node(editor, pathRef.current);\n        if (childNode && !Editor.isEmpty(editor, childNode))\n          blocks.push(syncCreateSlateBlock([childNode]));\n      }\n      blocks = [...blocks, ...extras];\n    }\n\n    const blockids = blocks.map((b) => b[0]);\n\n    // TODO: add the placeholder block, because we remove it\n    // (when we remove the current block)\n\n    const blocksData = omit(\n      {\n        ...properties[blocksFieldname],\n        ...fromEntries(blocks),\n      },\n      blockProps.block,\n    );\n    const layoutData = {\n      ...properties[blocksLayoutFieldname],\n      items: [\n        ...properties[blocksLayoutFieldname].items.slice(0, index),\n        ...blockids,\n        ...properties[blocksLayoutFieldname].items.slice(index),\n      ].filter((id) => id !== blockProps.block),\n    };\n\n    // TODO: use onChangeFormData instead of this API style\n    ReactDOM.unstable_batchedUpdates(() => {\n      onChangeField(blocksFieldname, blocksData);\n      onChangeField(blocksLayoutFieldname, layoutData);\n      onSelectBlock(blockids[blockids.length - 1]);\n      // resolve(blockids);\n      // or rather this?\n      Promise.resolve().then(resolve(blockids));\n    });\n  });\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}