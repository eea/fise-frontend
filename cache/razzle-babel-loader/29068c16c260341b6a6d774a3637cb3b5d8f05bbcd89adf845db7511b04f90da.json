{"ast":null,"code":"import _createForOfIteratorHelper from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _toConsumableArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { Text, Transforms, Element, Node } from 'slate'; // Editor,\nimport config from '@plone/volto/registry';\nexport var normalizeNode = function normalizeNode(editor) {\n  // enforce list rules (no block elements, only ol/ul/li as possible children\n  var normalizeNode = editor.normalizeNode;\n  var slate = config.settings.slate;\n  var validListElements = [].concat(_toConsumableArray(slate.listTypes), [slate.listItemType]);\n  editor.normalizeNode = function (entry) {\n    var _entry = _slicedToArray(entry, 2),\n      node = _entry[0],\n      path = _entry[1];\n    var isTextNode = Text.isText(node);\n    var isInlineNode = editor.isInline(node);\n    var isElementNode = Element.isElement(node);\n    var isListTypeNode = slate.listTypes.includes(node.type);\n\n    // delete childless ul/ol nodes\n    if (!isTextNode && isElementNode && !isInlineNode && isListTypeNode) {\n      if ((node.children || []).length === 0) {\n        Transforms.removeNodes(editor, {\n          at: path\n        });\n        return;\n      }\n    }\n    if (isElementNode && isListTypeNode) {\n      // lift all child nodes of ul/ol that are not ul/ol/li\n      var _iterator = _createForOfIteratorHelper(Node.children(editor, path)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var _step$value = _slicedToArray(_step.value, 2),\n            child = _step$value[0],\n            childPath = _step$value[1];\n          if (!validListElements.includes(child.type) && !validListElements.includes(node.type)) {\n            Transforms.liftNodes(editor, {\n              at: childPath,\n              split: true\n            });\n\n            // Alternate strategy, need to investigate\n            // const newParent = { type: slate.defaultBlockType, children: [] };\n            // Transforms.wrapNodes(editor, newParent, { at: childPath });\n            return;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    normalizeNode(entry);\n  };\n  return editor;\n};","map":{"version":3,"names":["Text","Transforms","Element","Node","config","normalizeNode","editor","slate","settings","validListElements","listTypes","listItemType","entry","node","path","isTextNode","isText","isInlineNode","isInline","isElementNode","isElement","isListTypeNode","includes","type","children","length","removeNodes","at","child","childPath","liftNodes","split"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/packages/volto-slate/src/editor/extensions/normalizeNode.js"],"sourcesContent":["import { Text, Transforms, Element, Node } from 'slate'; // Editor,\nimport config from '@plone/volto/registry';\n\nexport const normalizeNode = (editor) => {\n  // enforce list rules (no block elements, only ol/ul/li as possible children\n  const { normalizeNode } = editor;\n  const { slate } = config.settings;\n\n  const validListElements = [...slate.listTypes, slate.listItemType];\n\n  editor.normalizeNode = (entry) => {\n    const [node, path] = entry;\n\n    const isTextNode = Text.isText(node);\n    const isInlineNode = editor.isInline(node);\n    const isElementNode = Element.isElement(node);\n    const isListTypeNode = slate.listTypes.includes(node.type);\n\n    // delete childless ul/ol nodes\n    if (!isTextNode && isElementNode && !isInlineNode && isListTypeNode) {\n      if ((node.children || []).length === 0) {\n        Transforms.removeNodes(editor, { at: path });\n        return;\n      }\n    }\n\n    if (isElementNode && isListTypeNode) {\n      // lift all child nodes of ul/ol that are not ul/ol/li\n      for (const [child, childPath] of Node.children(editor, path)) {\n        if (\n          !validListElements.includes(child.type) &&\n          !validListElements.includes(node.type)\n        ) {\n          Transforms.liftNodes(editor, { at: childPath, split: true });\n\n          // Alternate strategy, need to investigate\n          // const newParent = { type: slate.defaultBlockType, children: [] };\n          // Transforms.wrapNodes(editor, newParent, { at: childPath });\n          return;\n        }\n      }\n    }\n\n    normalizeNode(entry);\n  };\n\n  return editor;\n};\n"],"mappings":";;;AAAA,SAASA,IAAI,EAAEC,UAAU,EAAEC,OAAO,EAAEC,IAAI,QAAQ,OAAO,CAAC,CAAC;AACzD,OAAOC,MAAM,MAAM,uBAAuB;AAE1C,OAAO,IAAMC,aAAa,GAAG,uBAACC,MAAM,EAAK;EACvC;EACA,IAAQD,aAAa,GAAKC,MAAM,CAAxBD,aAAa;EACrB,IAAQE,KAAK,GAAKH,MAAM,CAACI,QAAQ,CAAzBD,KAAK;EAEb,IAAME,iBAAiB,gCAAOF,KAAK,CAACG,SAAS,IAAEH,KAAK,CAACI,YAAY,EAAC;EAElEL,MAAM,CAACD,aAAa,GAAG,UAACO,KAAK,EAAK;IAChC,4BAAqBA,KAAK;MAAnBC,IAAI;MAAEC,IAAI;IAEjB,IAAMC,UAAU,GAAGf,IAAI,CAACgB,MAAM,CAACH,IAAI,CAAC;IACpC,IAAMI,YAAY,GAAGX,MAAM,CAACY,QAAQ,CAACL,IAAI,CAAC;IAC1C,IAAMM,aAAa,GAAGjB,OAAO,CAACkB,SAAS,CAACP,IAAI,CAAC;IAC7C,IAAMQ,cAAc,GAAGd,KAAK,CAACG,SAAS,CAACY,QAAQ,CAACT,IAAI,CAACU,IAAI,CAAC;;IAE1D;IACA,IAAI,CAACR,UAAU,IAAII,aAAa,IAAI,CAACF,YAAY,IAAII,cAAc,EAAE;MACnE,IAAI,CAACR,IAAI,CAACW,QAAQ,IAAI,EAAE,EAAEC,MAAM,KAAK,CAAC,EAAE;QACtCxB,UAAU,CAACyB,WAAW,CAACpB,MAAM,EAAE;UAAEqB,EAAE,EAAEb;QAAK,CAAC,CAAC;QAC5C;MACF;IACF;IAEA,IAAIK,aAAa,IAAIE,cAAc,EAAE;MACnC;MAAA,2CACiClB,IAAI,CAACqB,QAAQ,CAAClB,MAAM,EAAEQ,IAAI,CAAC;QAAA;MAAA;QAA5D,oDAA8D;UAAA;YAAlDc,KAAK;YAAEC,SAAS;UAC1B,IACE,CAACpB,iBAAiB,CAACa,QAAQ,CAACM,KAAK,CAACL,IAAI,CAAC,IACvC,CAACd,iBAAiB,CAACa,QAAQ,CAACT,IAAI,CAACU,IAAI,CAAC,EACtC;YACAtB,UAAU,CAAC6B,SAAS,CAACxB,MAAM,EAAE;cAAEqB,EAAE,EAAEE,SAAS;cAAEE,KAAK,EAAE;YAAK,CAAC,CAAC;;YAE5D;YACA;YACA;YACA;UACF;QACF;MAAC;QAAA;MAAA;QAAA;MAAA;IACH;IAEA1B,aAAa,CAACO,KAAK,CAAC;EACtB,CAAC;EAED,OAAON,MAAM;AACf,CAAC"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}