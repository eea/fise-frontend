{"ast":null,"code":"import _find from \"lodash/find\";\nimport _endsWith from \"lodash/endsWith\";\nimport _keys from \"lodash/keys\";\nimport _map from \"lodash/map\";\nimport _pickBy from \"lodash/pickBy\";\nimport _mapKeys from \"lodash/mapKeys\";\nimport _omitBy from \"lodash/omitBy\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport config from '@plone/volto/registry';\n\n/**\n * Nest content.\n * @function nestContent\n * @param {Object} props Properties.\n * @return {string} Field name of the block\n */\nexport function nestContent(props) {\n  if (!props['@static_behaviors']) {\n    return props;\n  }\n  let nestedProps = props;\n  _map(props['@static_behaviors'], behavior => {\n    const values = _mapKeys(_pickBy(nestedProps, (value, key) => key.indexOf(behavior) !== -1), (value, key) => key.replace(`${behavior}.`, ''));\n    nestedProps = _omitBy(nestedProps, (value, key) => key.indexOf(behavior) !== -1);\n    nestedProps = _objectSpread(_objectSpread({}, nestedProps), {}, {\n      [behavior]: values\n    });\n  });\n  return nestedProps;\n}\n\n/**\n * Get layout field.\n * @function getLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the layout\n */\nexport function getLayoutFieldname(props) {\n  return _find(_keys(props), key => _endsWith(key, 'content_layout')) || 'layout';\n}\n\n/**\n * Get content icon.\n * @description Configurable in config\n * @function getContentIcon\n * @param {string} type Content type\n * @param {boolean} isFolderish\n * @returns {Object} Icon component\n */\nexport function getContentIcon(type, isFolderish) {\n  const {\n    settings\n  } = config;\n  const {\n    contentIcons\n  } = settings;\n  if (type in contentIcons) return contentIcons[type];\n  return isFolderish ? contentIcons.Folder : contentIcons.File;\n}\n\n/**\n * Get the language independent fields presents in a schema.\n * @description Configurable in config\n * @function getLanguageIndependentFields\n * @param {string} schema content type JSON Schema serialization\n * @returns {array} List of language independent fields\n */\nexport function getLanguageIndependentFields(schema) {\n  const {\n    properties\n  } = schema;\n  return Object.keys(properties).filter(field => {\n    var _properties$field$mul;\n    return Object.keys(properties[field]).includes('multilingual_options') && ((_properties$field$mul = properties[field]['multilingual_options']) === null || _properties$field$mul === void 0 ? void 0 : _properties$field$mul['language_independent']);\n  });\n}","map":{"version":3,"names":["config","nestContent","props","nestedProps","behavior","values","value","key","indexOf","replace","getLayoutFieldname","getContentIcon","type","isFolderish","settings","contentIcons","Folder","File","getLanguageIndependentFields","schema","properties","Object","keys","filter","field","includes"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/Content/Content.js"],"sourcesContent":["/**\n * Content helper.\n * @module helpers/Content\n */\n\nimport { omitBy, mapKeys, pickBy, map, keys, endsWith, find } from 'lodash';\nimport config from '@plone/volto/registry';\n\n/**\n * Nest content.\n * @function nestContent\n * @param {Object} props Properties.\n * @return {string} Field name of the block\n */\nexport function nestContent(props) {\n  if (!props['@static_behaviors']) {\n    return props;\n  }\n\n  let nestedProps = props;\n\n  map(props['@static_behaviors'], (behavior) => {\n    const values = mapKeys(\n      pickBy(nestedProps, (value, key) => key.indexOf(behavior) !== -1),\n      (value, key) => key.replace(`${behavior}.`, ''),\n    );\n    nestedProps = omitBy(\n      nestedProps,\n      (value, key) => key.indexOf(behavior) !== -1,\n    );\n    nestedProps = {\n      ...nestedProps,\n      [behavior]: values,\n    };\n  });\n  return nestedProps;\n}\n\n/**\n * Get layout field.\n * @function getLayoutFieldname\n * @param {Object} props Properties.\n * @return {string} Field name of the layout\n */\nexport function getLayoutFieldname(props) {\n  return (\n    find(keys(props), (key) => endsWith(key, 'content_layout')) || 'layout'\n  );\n}\n\n/**\n * Get content icon.\n * @description Configurable in config\n * @function getContentIcon\n * @param {string} type Content type\n * @param {boolean} isFolderish\n * @returns {Object} Icon component\n */\nexport function getContentIcon(type, isFolderish) {\n  const { settings } = config;\n  const { contentIcons } = settings;\n\n  if (type in contentIcons) return contentIcons[type];\n  return isFolderish ? contentIcons.Folder : contentIcons.File;\n}\n\n/**\n * Get the language independent fields presents in a schema.\n * @description Configurable in config\n * @function getLanguageIndependentFields\n * @param {string} schema content type JSON Schema serialization\n * @returns {array} List of language independent fields\n */\nexport function getLanguageIndependentFields(schema) {\n  const { properties } = schema;\n  return Object.keys(properties).filter(\n    (field) =>\n      Object.keys(properties[field]).includes('multilingual_options') &&\n      properties[field]['multilingual_options']?.['language_independent'],\n  );\n}\n"],"mappings":";;;;;;;;;;AAMA,OAAOA,MAAM,MAAM,uBAAuB;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,WAAW,CAACC,KAAK,EAAE;EACjC,IAAI,CAACA,KAAK,CAAC,mBAAmB,CAAC,EAAE;IAC/B,OAAOA,KAAK;EACd;EAEA,IAAIC,WAAW,GAAGD,KAAK;EAEvB,KAAIA,KAAK,CAAC,mBAAmB,CAAC,EAAGE,QAAQ,IAAK;IAC5C,MAAMC,MAAM,GAAG,SACb,QAAOF,WAAW,EAAE,CAACG,KAAK,EAAEC,GAAG,KAAKA,GAAG,CAACC,OAAO,CAACJ,QAAQ,CAAC,KAAK,CAAC,CAAC,CAAC,EACjE,CAACE,KAAK,EAAEC,GAAG,KAAKA,GAAG,CAACE,OAAO,CAAE,GAAEL,QAAS,GAAE,EAAE,EAAE,CAAC,CAChD;IACDD,WAAW,GAAG,QACZA,WAAW,EACX,CAACG,KAAK,EAAEC,GAAG,KAAKA,GAAG,CAACC,OAAO,CAACJ,QAAQ,CAAC,KAAK,CAAC,CAAC,CAC7C;IACDD,WAAW,mCACNA,WAAW;MACd,CAACC,QAAQ,GAAGC;IAAM,EACnB;EACH,CAAC,CAAC;EACF,OAAOF,WAAW;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASO,kBAAkB,CAACR,KAAK,EAAE;EACxC,OACE,MAAK,MAAKA,KAAK,CAAC,EAAGK,GAAG,IAAK,UAASA,GAAG,EAAE,gBAAgB,CAAC,CAAC,IAAI,QAAQ;AAE3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASI,cAAc,CAACC,IAAI,EAAEC,WAAW,EAAE;EAChD,MAAM;IAAEC;EAAS,CAAC,GAAGd,MAAM;EAC3B,MAAM;IAAEe;EAAa,CAAC,GAAGD,QAAQ;EAEjC,IAAIF,IAAI,IAAIG,YAAY,EAAE,OAAOA,YAAY,CAACH,IAAI,CAAC;EACnD,OAAOC,WAAW,GAAGE,YAAY,CAACC,MAAM,GAAGD,YAAY,CAACE,IAAI;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,4BAA4B,CAACC,MAAM,EAAE;EACnD,MAAM;IAAEC;EAAW,CAAC,GAAGD,MAAM;EAC7B,OAAOE,MAAM,CAACC,IAAI,CAACF,UAAU,CAAC,CAACG,MAAM,CAClCC,KAAK;IAAA;IAAA,OACJH,MAAM,CAACC,IAAI,CAACF,UAAU,CAACI,KAAK,CAAC,CAAC,CAACC,QAAQ,CAAC,sBAAsB,CAAC,8BAC/DL,UAAU,CAACI,KAAK,CAAC,CAAC,sBAAsB,CAAC,0DAAzC,sBAA4C,sBAAsB,CAAC;EAAA,EACtE;AACH"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}