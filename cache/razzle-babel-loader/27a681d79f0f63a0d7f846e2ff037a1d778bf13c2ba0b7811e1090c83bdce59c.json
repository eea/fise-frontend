{"ast":null,"code":"const _excluded = [\"reduxConnectStore\"],\n  _excluded2 = [\"context\"];\nvar _jsxFileName = \"/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/AsyncConnect/AsyncConnect.jsx\";\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* eslint-disable react/forbid-prop-types,react/no-unused-prop-types,react/require-default-props */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Route } from 'react-router';\nimport { renderRoutes } from 'react-router-config';\nimport { ReactReduxContext } from 'react-redux';\nimport { loadAsyncConnect } from './ssr';\nimport { getMutableState } from './utils';\nexport class AsyncConnect extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      previousLocation: this.isLoaded() ? null : props.location\n    };\n    this.mounted = false;\n    this.loadDataCounter = 0;\n  }\n  componentDidMount() {\n    this.mounted = true;\n    const dataLoaded = this.isLoaded();\n\n    // we dont need it if we already made it on server-side\n    if (!dataLoaded) {\n      this.loadAsyncData(this.props);\n    }\n  }\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    // eslint-disable-line camelcase\n    const {\n      location,\n      reloadOnPropsChange\n    } = this.props;\n    const navigated = location !== nextProps.location;\n\n    // Allow a user supplied function to determine if an async reload is necessary\n    if (navigated && reloadOnPropsChange(this.props, nextProps)) {\n      this.loadAsyncData(nextProps);\n    }\n  }\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n  isLoaded() {\n    const {\n      reduxConnectStore\n    } = this.props;\n    return getMutableState(reduxConnectStore.getState()).reduxAsyncConnect.loaded;\n  }\n  loadAsyncData(_ref) {\n    let {\n        reduxConnectStore\n      } = _ref,\n      otherProps = _objectWithoutProperties(_ref, _excluded);\n    const {\n      location,\n      beginGlobalLoad,\n      endGlobalLoad\n    } = this.props;\n    const loadResult = loadAsyncConnect(_objectSpread(_objectSpread({}, otherProps), {}, {\n      store: reduxConnectStore\n    }));\n    this.setState({\n      previousLocation: location\n    });\n\n    // TODO: think of a better solution to a problem?\n    this.loadDataCounter += 1;\n    beginGlobalLoad();\n    return (loadDataCounterOriginal => loadResult.then(() => {\n      // We need to change propsToShow only if loadAsyncData that called this promise\n      // is the last invocation of loadAsyncData method. Otherwise we can face a situation\n      // when user is changing route several times and we finally show him route that has\n      // loaded props last time and not the last called route\n      if (this.loadDataCounter === loadDataCounterOriginal && this.mounted !== false) {\n        this.setState({\n          previousLocation: null\n        });\n      }\n\n      // TODO: investigate race conditions\n      // do we need to call this if it's not last invocation?\n      endGlobalLoad();\n    }))(this.loadDataCounter);\n  }\n  render() {\n    const {\n      previousLocation\n    } = this.state;\n    const {\n      location,\n      render\n    } = this.props;\n    return __jsx(Route, {\n      location: previousLocation || location,\n      render: () => render(this.props),\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 89,\n        columnNumber: 7\n      }\n    });\n  }\n}\nAsyncConnect.propTypes = {\n  render: PropTypes.func,\n  beginGlobalLoad: PropTypes.func.isRequired,\n  endGlobalLoad: PropTypes.func.isRequired,\n  reloadOnPropsChange: PropTypes.func,\n  routes: PropTypes.array.isRequired,\n  location: PropTypes.object.isRequired,\n  match: PropTypes.object.isRequired,\n  helpers: PropTypes.any,\n  reduxConnectStore: PropTypes.object.isRequired\n};\nAsyncConnect.defaultProps = {\n  helpers: {},\n  reloadOnPropsChange() {\n    return true;\n  },\n  render({\n    routes\n  }) {\n    return renderRoutes(routes);\n  }\n};\nexport const AsyncConnectWithContext = _ref2 => {\n  let {\n      context\n    } = _ref2,\n    otherProps = _objectWithoutProperties(_ref2, _excluded2);\n  const Context = context || ReactReduxContext;\n  if (Context == null) {\n    throw new Error('Please upgrade to react-redux v6');\n  }\n  return __jsx(Context.Consumer, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 5\n    }\n  }, ({\n    store: reduxConnectStore\n  }) => __jsx(AsyncConnect, _extends({\n    reduxConnectStore: reduxConnectStore\n  }, otherProps, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 9\n    }\n  })));\n};\nAsyncConnectWithContext.propTypes = {\n  context: PropTypes.object\n};","map":{"version":3,"names":["React","Component","PropTypes","Route","renderRoutes","ReactReduxContext","loadAsyncConnect","getMutableState","AsyncConnect","constructor","props","state","previousLocation","isLoaded","location","mounted","loadDataCounter","componentDidMount","dataLoaded","loadAsyncData","UNSAFE_componentWillReceiveProps","nextProps","reloadOnPropsChange","navigated","componentWillUnmount","reduxConnectStore","getState","reduxAsyncConnect","loaded","otherProps","beginGlobalLoad","endGlobalLoad","loadResult","store","setState","loadDataCounterOriginal","then","render","propTypes","func","isRequired","routes","array","object","match","helpers","any","defaultProps","AsyncConnectWithContext","context","Context","Error"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/AsyncConnect/AsyncConnect.jsx"],"sourcesContent":["/* eslint-disable react/forbid-prop-types,react/no-unused-prop-types,react/require-default-props */\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Route } from 'react-router';\nimport { renderRoutes } from 'react-router-config';\nimport { ReactReduxContext } from 'react-redux';\nimport { loadAsyncConnect } from './ssr';\nimport { getMutableState } from './utils';\n\nexport class AsyncConnect extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      previousLocation: this.isLoaded() ? null : props.location,\n    };\n\n    this.mounted = false;\n    this.loadDataCounter = 0;\n  }\n\n  componentDidMount() {\n    this.mounted = true;\n    const dataLoaded = this.isLoaded();\n\n    // we dont need it if we already made it on server-side\n    if (!dataLoaded) {\n      this.loadAsyncData(this.props);\n    }\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    // eslint-disable-line camelcase\n    const { location, reloadOnPropsChange } = this.props;\n    const navigated = location !== nextProps.location;\n\n    // Allow a user supplied function to determine if an async reload is necessary\n    if (navigated && reloadOnPropsChange(this.props, nextProps)) {\n      this.loadAsyncData(nextProps);\n    }\n  }\n\n  componentWillUnmount() {\n    this.mounted = false;\n  }\n\n  isLoaded() {\n    const { reduxConnectStore } = this.props;\n    return getMutableState(reduxConnectStore.getState()).reduxAsyncConnect\n      .loaded;\n  }\n\n  loadAsyncData({ reduxConnectStore, ...otherProps }) {\n    const { location, beginGlobalLoad, endGlobalLoad } = this.props;\n    const loadResult = loadAsyncConnect({\n      ...otherProps,\n      store: reduxConnectStore,\n    });\n\n    this.setState({ previousLocation: location });\n\n    // TODO: think of a better solution to a problem?\n    this.loadDataCounter += 1;\n    beginGlobalLoad();\n    return ((loadDataCounterOriginal) =>\n      loadResult.then(() => {\n        // We need to change propsToShow only if loadAsyncData that called this promise\n        // is the last invocation of loadAsyncData method. Otherwise we can face a situation\n        // when user is changing route several times and we finally show him route that has\n        // loaded props last time and not the last called route\n        if (\n          this.loadDataCounter === loadDataCounterOriginal &&\n          this.mounted !== false\n        ) {\n          this.setState({ previousLocation: null });\n        }\n\n        // TODO: investigate race conditions\n        // do we need to call this if it's not last invocation?\n        endGlobalLoad();\n      }))(this.loadDataCounter);\n  }\n\n  render() {\n    const { previousLocation } = this.state;\n    const { location, render } = this.props;\n\n    return (\n      <Route\n        location={previousLocation || location}\n        render={() => render(this.props)}\n      />\n    );\n  }\n}\n\nAsyncConnect.propTypes = {\n  render: PropTypes.func,\n  beginGlobalLoad: PropTypes.func.isRequired,\n  endGlobalLoad: PropTypes.func.isRequired,\n  reloadOnPropsChange: PropTypes.func,\n  routes: PropTypes.array.isRequired,\n  location: PropTypes.object.isRequired,\n  match: PropTypes.object.isRequired,\n  helpers: PropTypes.any,\n  reduxConnectStore: PropTypes.object.isRequired,\n};\n\nAsyncConnect.defaultProps = {\n  helpers: {},\n  reloadOnPropsChange() {\n    return true;\n  },\n  render({ routes }) {\n    return renderRoutes(routes);\n  },\n};\n\nexport const AsyncConnectWithContext = ({ context, ...otherProps }) => {\n  const Context = context || ReactReduxContext;\n\n  if (Context == null) {\n    throw new Error('Please upgrade to react-redux v6');\n  }\n\n  return (\n    <Context.Consumer>\n      {({ store: reduxConnectStore }) => (\n        <AsyncConnect reduxConnectStore={reduxConnectStore} {...otherProps} />\n      )}\n    </Context.Consumer>\n  );\n};\n\nAsyncConnectWithContext.propTypes = {\n  context: PropTypes.object,\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}