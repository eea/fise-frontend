{"ast":null,"code":"import _isEmpty from \"lodash/isEmpty\";\nimport _intersection from \"lodash/intersection\";\nimport _keys from \"lodash/keys\";\nimport _uniq from \"lodash/uniq\";\nimport _map from \"lodash/map\";\nimport { messages } from '../MessageLabels/MessageLabels';\n\n/**\n * Will return the intl message if invalid\n * @param {boolean} isValid\n * @param {string} maxCriterion\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {Function} intlFunc\n */\nconst validationMessage = (isValid, maxCriterion, valueToCompare, intlFunc) => !isValid ? intlFunc(messages[maxCriterion], {\n  len: valueToCompare\n}) : null;\n/**\n * Returns if based on the criterion the value is lower or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\nconst isMaxPropertyValid = (value, valueToCompare, minCriterion, intlFunc) => {\n  const isValid = valueToCompare !== undefined ? value <= valueToCompare : true;\n  return validationMessage(isValid, minCriterion, valueToCompare, intlFunc);\n};\n/**\n * Returns if based on the criterion the value is higher or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\nconst isMinPropertyValid = (value, valueToCompare, maxCriterion, intlFunc) => {\n  const isValid = valueToCompare !== undefined ? value >= valueToCompare : true;\n  return validationMessage(isValid, maxCriterion, valueToCompare, intlFunc);\n};\nconst widgetValidation = {\n  email: {\n    isValidEmail: (emailValue, emailObj, intlFunc) => {\n      // Email Regex taken from from WHATWG living standard:\n      // https://html.spec.whatwg.org/multipage/input.html#e-mail-state-(type=email)\n      const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n      const isValid = emailRegex.test(emailValue);\n      return !isValid ? intlFunc(messages.isValidEmail) : null;\n    },\n    minLength: (emailValue, emailObj, intlFunc) => isMinPropertyValid(emailValue.length, emailObj.minLength, 'minLength', intlFunc),\n    maxLength: (emailValue, emailObj, intlFunc) => isMaxPropertyValid(emailValue.length, emailObj.maxLength, 'maxLength', intlFunc)\n  },\n  url: {\n    isValidURL: (urlValue, urlObj, intlFunc) => {\n      const urlRegex = /^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([-.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([_.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^((http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/gm;\n      const isValid = urlRegex.test(urlValue);\n      return !isValid ? intlFunc(messages.isValidURL) : null;\n    },\n    minLength: (urlValue, urlObj, intlFunc) => isMinPropertyValid(urlValue.length, urlObj.minLength, 'minLength', intlFunc),\n    maxLength: (urlValue, urlObj, intlFunc) => isMaxPropertyValid(urlValue.length, urlObj.maxLength, 'maxLength', intlFunc)\n  },\n  password: {\n    minLength: (passwordValue, passwordObj, intlFunc) => isMinPropertyValid(passwordValue.length, passwordObj.minLength, 'minLength', intlFunc),\n    maxLength: (passwordValue, passwordObj, intlFunc) => isMaxPropertyValid(passwordValue.length, passwordObj.maxLength, 'maxLength', intlFunc)\n  },\n  string: {\n    minLength: (value, itemObj, intlFunc) => isMinPropertyValid(value.length, itemObj.minLength, 'minLength', intlFunc),\n    maxLength: (value, itemObj, intlFunc) => isMaxPropertyValid(value.length, itemObj.maxLengthj, 'maxLength', intlFunc)\n  },\n  number: {\n    isNumber: (value, itemObj, intlFunc) => {\n      const floatRegex = /^[+-]?\\d+(\\.\\d+)?$/;\n      const isValid = !isNaN(value) && floatRegex.test(value);\n      return !isValid ? intlFunc(messages.isNumber) : null;\n    },\n    minimum: (value, itemObj, intlFunc) => isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc),\n    maximum: (value, itemObj, intlFunc) => isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc)\n  },\n  integer: {\n    isInteger: (value, itemObj, intlFunc) => {\n      const intRegex = /^-?[0-9]+$/;\n      const isValid = !isNaN(value) && intRegex.test(value);\n      return !isValid ? intlFunc(messages.isInteger) : null;\n    },\n    minimum: (value, itemObj, intlFunc) => isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc),\n    maximum: (value, itemObj, intlFunc) => isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc)\n  }\n};\n\n/**\n * The string that comes my not be a valid JSON\n * @param {string} requestItem\n */\nconst tryParseJSON = requestItem => {\n  let resultObj = null;\n  try {\n    resultObj = JSON.parse(requestItem);\n  } catch (e) {\n    try {\n      resultObj = JSON.parse(requestItem.replace(/'/g, '\"'));\n    } catch (e) {\n      resultObj = null;\n    }\n  }\n  return resultObj;\n};\n\n/**\n * Returns errors if obj has unique Items\n * @param {Object} field\n * @param {*} fieldData\n * @returns {Object[string]} - list of errors\n */\nconst hasUniqueItems = (field, fieldData, formatMessage) => {\n  const errors = [];\n  if (field.uniqueItems && fieldData && _uniq(fieldData).length !== fieldData.length) {\n    errors.push(formatMessage(messages.uniqueItems));\n  }\n  return errors;\n};\n\n/**\n * If required fields are undefined, return list of errors\n * @returns {Object[string]} - list of errors\n */\nconst validateRequiredFields = (schema, formData, formatMessage, touchedField) => {\n  const errors = {};\n  const fields = _isEmpty(touchedField) ? schema.required : _intersection(schema.required, _keys(touchedField));\n  _map(fields, requiredField => {\n    var _schema$properties$re, _schema$properties$re2;\n    const type = (_schema$properties$re = schema.properties[requiredField]) === null || _schema$properties$re === void 0 ? void 0 : _schema$properties$re.type;\n    const widget = (_schema$properties$re2 = schema.properties[requiredField]) === null || _schema$properties$re2 === void 0 ? void 0 : _schema$properties$re2.widget;\n    let isEmpty = !formData[requiredField];\n    if (!isEmpty) {\n      if (type === 'array') {\n        isEmpty = formData[requiredField] ? formData[requiredField].length === 0 : true;\n      } else if (type === 'string' && widget === 'richtext') {\n        var _formData$requiredFie, _formData$requiredFie2;\n        isEmpty = !(((_formData$requiredFie = formData[requiredField]) === null || _formData$requiredFie === void 0 ? void 0 : (_formData$requiredFie2 = _formData$requiredFie.data) === null || _formData$requiredFie2 === void 0 ? void 0 : _formData$requiredFie2.replace(/(<([^>]+)>)/g, '').length) > 0);\n      }\n    }\n    if (schema.properties[requiredField] && schema.properties[requiredField].type !== 'boolean' && !schema.properties[requiredField].readonly && isEmpty) {\n      const requiredFieldName = schema.properties[requiredField].title || requiredField;\n      errors[requiredFieldName] = [];\n      errors[requiredFieldName].push(formatMessage(messages.required));\n    }\n  });\n  return errors;\n};\n/**\n * Return list of errors if field constraints are not respected\n * (ex min, max, maxLength, email format, url format etc)\n * each potential criterion has a validation process in widgetValidation\n * !!ONLY fields with data will be tested (those undefined are ignored here)\n * @returns {Object[string]} - list of errors\n */\nconst validateFieldsPerFieldset = (schema, formData, formatMessage, touchedField) => {\n  const errors = validateRequiredFields(schema, formData, formatMessage, touchedField);\n  _map(schema.properties, (field, fieldId) => {\n    const fieldWidgetType = field.widget || field.type;\n    const widgetValidationCriteria = widgetValidation[fieldWidgetType] ? Object.keys(widgetValidation[fieldWidgetType]) : [];\n    let fieldData = formData[fieldId];\n    // test each criterion ex maximum, isEmail, isUrl, maxLength etc\n    const fieldErrors = widgetValidationCriteria.map(widgetCriterion => {\n      const errorMessage = fieldData === undefined || fieldData === null ? null : widgetValidation[fieldWidgetType][widgetCriterion](fieldData, field, formatMessage);\n      return errorMessage;\n    }).filter(item => !!item);\n    const uniqueErrors = hasUniqueItems(field, fieldData, formatMessage);\n    const mergedErrors = [...fieldErrors, ...uniqueErrors];\n    if (mergedErrors.length > 0) {\n      errors[fieldId] = [...(errors[fieldId] || []), ...fieldErrors, ...uniqueErrors];\n    }\n  });\n  return errors;\n};\n\n/**\n * Create the errors object from backend the same way it is done on Frontend validation\n * @param {string} requestError form the server\n * @returns {Object}\n */\nconst giveServerErrorsToCorrespondingFields = requestError => {\n  let errorsList = tryParseJSON(requestError);\n  const errors = {};\n  if (Array.isArray(errorsList) && errorsList.length > 0) {\n    errorsList.forEach(errorItem => {\n      errors[errorItem.field] = errors[errorItem.field] ? errors[errorItem.field].push(errorItem.message) : [errorItem.message];\n    });\n  }\n  return errors;\n};\n\n/**\n * The first Fieldset (Tab) that has any errors\n * will be selected\n * @param {Object[]} errors\n * @param {string} errors[].field\n * @param {Object} schema\n * @returns {number} activeIndex\n */\nconst getIndexOfFirstTabWithErrors = (errors, schema) => {\n  let activeIndex = 0;\n  schema.fieldsets.some((fieldSet, index) => {\n    let foundfield = fieldSet.fields.some(fieldId => errors[fieldId]);\n    activeIndex = foundfield ? index : activeIndex;\n    return foundfield;\n  });\n  return activeIndex;\n};\nclass FormValidation {\n  /**\n   * The first Fieldset (Tab) that has any errors\n   * will be selected\n   * @param {Object} errors\n   * @param {Object} schema\n   * @returns {number} activeIndex\n   */\n  static showFirstTabWithErrors({\n    errors = {},\n    schema = {\n      properties: {},\n      fieldsets: [],\n      required: []\n    }\n  } = {}) {\n    return getIndexOfFirstTabWithErrors(errors, schema);\n  }\n  /**\n   * Create the errors object from backend the same way it is done on Frontend validation\n   * @param {string} requestError form the server\n   * @returns {Object}\n   */\n  static giveServerErrorsToCorrespondingFields(requestError = '') {\n    return giveServerErrorsToCorrespondingFields(requestError);\n  }\n  /**\n   * Return validation result\n   * @param {Object} schema\n   * @param {Object} formData\n   * @param {function} formatMessage\n   * @returns {Object} errors\n   */\n  static validateFieldsPerFieldset({\n    schema = {\n      properties: {},\n      fieldsets: [],\n      required: []\n    },\n    formData = {},\n    formatMessage = () => {},\n    touchedField = {}\n  } = {}) {\n    return validateFieldsPerFieldset(schema, formData, formatMessage, touchedField);\n  }\n}\nexport default FormValidation;","map":{"version":3,"names":["messages","validationMessage","isValid","maxCriterion","valueToCompare","intlFunc","len","isMaxPropertyValid","value","minCriterion","undefined","isMinPropertyValid","widgetValidation","email","isValidEmail","emailValue","emailObj","emailRegex","test","minLength","length","maxLength","url","isValidURL","urlValue","urlObj","urlRegex","password","passwordValue","passwordObj","string","itemObj","maxLengthj","number","isNumber","floatRegex","isNaN","minimum","maximum","integer","isInteger","intRegex","tryParseJSON","requestItem","resultObj","JSON","parse","e","replace","hasUniqueItems","field","fieldData","formatMessage","errors","uniqueItems","push","validateRequiredFields","schema","formData","touchedField","fields","required","requiredField","type","properties","widget","isEmpty","data","readonly","requiredFieldName","title","validateFieldsPerFieldset","fieldId","fieldWidgetType","widgetValidationCriteria","Object","keys","fieldErrors","map","widgetCriterion","errorMessage","filter","item","uniqueErrors","mergedErrors","giveServerErrorsToCorrespondingFields","requestError","errorsList","Array","isArray","forEach","errorItem","message","getIndexOfFirstTabWithErrors","activeIndex","fieldsets","some","fieldSet","index","foundfield","FormValidation","showFirstTabWithErrors"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/FormValidation/FormValidation.js"],"sourcesContent":["import { map, uniq, keys, intersection, isEmpty } from 'lodash';\nimport { messages } from '../MessageLabels/MessageLabels';\n\n/**\n * Will return the intl message if invalid\n * @param {boolean} isValid\n * @param {string} maxCriterion\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {Function} intlFunc\n */\nconst validationMessage = (isValid, maxCriterion, valueToCompare, intlFunc) =>\n  !isValid\n    ? intlFunc(messages[maxCriterion], {\n        len: valueToCompare,\n      })\n    : null;\n/**\n * Returns if based on the criterion the value is lower or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\nconst isMaxPropertyValid = (value, valueToCompare, minCriterion, intlFunc) => {\n  const isValid = valueToCompare !== undefined ? value <= valueToCompare : true;\n  return validationMessage(isValid, minCriterion, valueToCompare, intlFunc);\n};\n/**\n * Returns if based on the criterion the value is higher or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\nconst isMinPropertyValid = (value, valueToCompare, maxCriterion, intlFunc) => {\n  const isValid = valueToCompare !== undefined ? value >= valueToCompare : true;\n  return validationMessage(isValid, maxCriterion, valueToCompare, intlFunc);\n};\n\nconst widgetValidation = {\n  email: {\n    isValidEmail: (emailValue, emailObj, intlFunc) => {\n      // Email Regex taken from from WHATWG living standard:\n      // https://html.spec.whatwg.org/multipage/input.html#e-mail-state-(type=email)\n      const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n      const isValid = emailRegex.test(emailValue);\n      return !isValid ? intlFunc(messages.isValidEmail) : null;\n    },\n    minLength: (emailValue, emailObj, intlFunc) =>\n      isMinPropertyValid(\n        emailValue.length,\n        emailObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (emailValue, emailObj, intlFunc) =>\n      isMaxPropertyValid(\n        emailValue.length,\n        emailObj.maxLength,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  url: {\n    isValidURL: (urlValue, urlObj, intlFunc) => {\n      const urlRegex = /^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([-.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([_.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^((http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/gm;\n      const isValid = urlRegex.test(urlValue);\n      return !isValid ? intlFunc(messages.isValidURL) : null;\n    },\n    minLength: (urlValue, urlObj, intlFunc) =>\n      isMinPropertyValid(\n        urlValue.length,\n        urlObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (urlValue, urlObj, intlFunc) =>\n      isMaxPropertyValid(\n        urlValue.length,\n        urlObj.maxLength,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  password: {\n    minLength: (passwordValue, passwordObj, intlFunc) =>\n      isMinPropertyValid(\n        passwordValue.length,\n        passwordObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (passwordValue, passwordObj, intlFunc) =>\n      isMaxPropertyValid(\n        passwordValue.length,\n        passwordObj.maxLength,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  string: {\n    minLength: (value, itemObj, intlFunc) =>\n      isMinPropertyValid(\n        value.length,\n        itemObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (value, itemObj, intlFunc) =>\n      isMaxPropertyValid(\n        value.length,\n        itemObj.maxLengthj,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  number: {\n    isNumber: (value, itemObj, intlFunc) => {\n      const floatRegex = /^[+-]?\\d+(\\.\\d+)?$/;\n      const isValid = !isNaN(value) && floatRegex.test(value);\n      return !isValid ? intlFunc(messages.isNumber) : null;\n    },\n    minimum: (value, itemObj, intlFunc) =>\n      isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc),\n    maximum: (value, itemObj, intlFunc) =>\n      isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc),\n  },\n  integer: {\n    isInteger: (value, itemObj, intlFunc) => {\n      const intRegex = /^-?[0-9]+$/;\n      const isValid = !isNaN(value) && intRegex.test(value);\n      return !isValid ? intlFunc(messages.isInteger) : null;\n    },\n    minimum: (value, itemObj, intlFunc) =>\n      isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc),\n    maximum: (value, itemObj, intlFunc) =>\n      isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc),\n  },\n};\n\n/**\n * The string that comes my not be a valid JSON\n * @param {string} requestItem\n */\nconst tryParseJSON = (requestItem) => {\n  let resultObj = null;\n  try {\n    resultObj = JSON.parse(requestItem);\n  } catch (e) {\n    try {\n      resultObj = JSON.parse(requestItem.replace(/'/g, '\"'));\n    } catch (e) {\n      resultObj = null;\n    }\n  }\n  return resultObj;\n};\n\n/**\n * Returns errors if obj has unique Items\n * @param {Object} field\n * @param {*} fieldData\n * @returns {Object[string]} - list of errors\n */\nconst hasUniqueItems = (field, fieldData, formatMessage) => {\n  const errors = [];\n  if (\n    field.uniqueItems &&\n    fieldData &&\n    uniq(fieldData).length !== fieldData.length\n  ) {\n    errors.push(formatMessage(messages.uniqueItems));\n  }\n  return errors;\n};\n\n/**\n * If required fields are undefined, return list of errors\n * @returns {Object[string]} - list of errors\n */\nconst validateRequiredFields = (\n  schema,\n  formData,\n  formatMessage,\n  touchedField,\n) => {\n  const errors = {};\n  const fields = isEmpty(touchedField)\n    ? schema.required\n    : intersection(schema.required, keys(touchedField));\n  map(fields, (requiredField) => {\n    const type = schema.properties[requiredField]?.type;\n    const widget = schema.properties[requiredField]?.widget;\n\n    let isEmpty = !formData[requiredField];\n    if (!isEmpty) {\n      if (type === 'array') {\n        isEmpty = formData[requiredField]\n          ? formData[requiredField].length === 0\n          : true;\n      } else if (type === 'string' && widget === 'richtext') {\n        isEmpty = !(\n          formData[requiredField]?.data?.replace(/(<([^>]+)>)/g, '').length > 0\n        );\n      }\n    }\n    if (\n      schema.properties[requiredField] &&\n      schema.properties[requiredField].type !== 'boolean' &&\n      !schema.properties[requiredField].readonly &&\n      isEmpty\n    ) {\n      const requiredFieldName =\n        schema.properties[requiredField].title || requiredField;\n      errors[requiredFieldName] = [];\n      errors[requiredFieldName].push(formatMessage(messages.required));\n    }\n  });\n\n  return errors;\n};\n/**\n * Return list of errors if field constraints are not respected\n * (ex min, max, maxLength, email format, url format etc)\n * each potential criterion has a validation process in widgetValidation\n * !!ONLY fields with data will be tested (those undefined are ignored here)\n * @returns {Object[string]} - list of errors\n */\nconst validateFieldsPerFieldset = (\n  schema,\n  formData,\n  formatMessage,\n  touchedField,\n) => {\n  const errors = validateRequiredFields(\n    schema,\n    formData,\n    formatMessage,\n    touchedField,\n  );\n\n  map(schema.properties, (field, fieldId) => {\n    const fieldWidgetType = field.widget || field.type;\n    const widgetValidationCriteria = widgetValidation[fieldWidgetType]\n      ? Object.keys(widgetValidation[fieldWidgetType])\n      : [];\n    let fieldData = formData[fieldId];\n    // test each criterion ex maximum, isEmail, isUrl, maxLength etc\n    const fieldErrors = widgetValidationCriteria\n      .map((widgetCriterion) => {\n        const errorMessage =\n          fieldData === undefined || fieldData === null\n            ? null\n            : widgetValidation[fieldWidgetType][widgetCriterion](\n                fieldData,\n                field,\n                formatMessage,\n              );\n        return errorMessage;\n      })\n      .filter((item) => !!item);\n\n    const uniqueErrors = hasUniqueItems(field, fieldData, formatMessage);\n    const mergedErrors = [...fieldErrors, ...uniqueErrors];\n\n    if (mergedErrors.length > 0) {\n      errors[fieldId] = [\n        ...(errors[fieldId] || []),\n        ...fieldErrors,\n        ...uniqueErrors,\n      ];\n    }\n  });\n\n  return errors;\n};\n\n/**\n * Create the errors object from backend the same way it is done on Frontend validation\n * @param {string} requestError form the server\n * @returns {Object}\n */\nconst giveServerErrorsToCorrespondingFields = (requestError) => {\n  let errorsList = tryParseJSON(requestError);\n  const errors = {};\n\n  if (Array.isArray(errorsList) && errorsList.length > 0) {\n    errorsList.forEach((errorItem) => {\n      errors[errorItem.field] = errors[errorItem.field]\n        ? errors[errorItem.field].push(errorItem.message)\n        : [errorItem.message];\n    });\n  }\n  return errors;\n};\n\n/**\n * The first Fieldset (Tab) that has any errors\n * will be selected\n * @param {Object[]} errors\n * @param {string} errors[].field\n * @param {Object} schema\n * @returns {number} activeIndex\n */\nconst getIndexOfFirstTabWithErrors = (errors, schema) => {\n  let activeIndex = 0;\n\n  schema.fieldsets.some((fieldSet, index) => {\n    let foundfield = fieldSet.fields.some((fieldId) => errors[fieldId]);\n\n    activeIndex = foundfield ? index : activeIndex;\n    return foundfield;\n  });\n\n  return activeIndex;\n};\n\nclass FormValidation {\n  /**\n   * The first Fieldset (Tab) that has any errors\n   * will be selected\n   * @param {Object} errors\n   * @param {Object} schema\n   * @returns {number} activeIndex\n   */\n  static showFirstTabWithErrors({\n    errors = {},\n    schema = { properties: {}, fieldsets: [], required: [] },\n  } = {}) {\n    return getIndexOfFirstTabWithErrors(errors, schema);\n  }\n  /**\n   * Create the errors object from backend the same way it is done on Frontend validation\n   * @param {string} requestError form the server\n   * @returns {Object}\n   */\n  static giveServerErrorsToCorrespondingFields(requestError = '') {\n    return giveServerErrorsToCorrespondingFields(requestError);\n  }\n  /**\n   * Return validation result\n   * @param {Object} schema\n   * @param {Object} formData\n   * @param {function} formatMessage\n   * @returns {Object} errors\n   */\n  static validateFieldsPerFieldset({\n    schema = { properties: {}, fieldsets: [], required: [] },\n    formData = {},\n    formatMessage = () => {},\n    touchedField = {},\n  } = {}) {\n    return validateFieldsPerFieldset(\n      schema,\n      formData,\n      formatMessage,\n      touchedField,\n    );\n  }\n}\n\nexport default FormValidation;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}