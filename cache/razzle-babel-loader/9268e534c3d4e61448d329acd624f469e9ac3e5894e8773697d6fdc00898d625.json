{"ast":null,"code":"import { Editor, Path, Transforms, Node } from 'slate';\nimport { isCursorInList, getCurrentListItem } from 'volto-slate/utils';\nimport config from '@plone/volto/registry';\n\n/**\n * Move up a list with with `Ctrl+Up`. (The Up key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\nexport function moveListItemUp({\n  editor,\n  event\n}) {\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!(event.ctrlKey && isCursorInList(editor))) return;\n\n  // Else prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n  const {\n    anchor\n  } = editor.selection;\n  const {\n    slate\n  } = config.settings;\n  event.preventDefault();\n  event.stopPropagation();\n\n  // Store the current list item's path.\n  const [, listItemPath] = getCurrentListItem(editor);\n\n  // Don't allow in first line list item Check if the current list item is first\n  // in its parent\n  if (\n  // If the selection starts at the beginning of a root-level block node\n  anchor.path.slice(1).reduce((acc, n) => acc + n, 0) === 0 ||\n  // or the current list item is the first in the list that contains it\n  listItemPath[listItemPath.length - 1] === 0) {\n    // Mark the event as handled and do nothing.\n    return true;\n  }\n\n  // Take the Node in the selection that is LI and is farthest-from-root.\n  const [match] = Editor.nodes(editor, {\n    match: n => n.type === slate.listItemType,\n    // Explanation of the three modes:\n    // * 'all' - take all the nodes from the root Editor node to the selected\n    //   leaf Text node\n    // * 'highest' - take the root Editor node (if there is a selection, in case\n    //   no `at` option is given)\n    // * 'lowest' - take the farthest-from-root selected leaf Text node\n    // (Replace the \"leaf Text node\" expressions in the above list with\n    // whatever matching function you use.)\n    mode: 'lowest'\n  });\n\n  // Get the Path of the above-found Node.\n  const [, at] = match;\n\n  // Get the Path that represents the previous sibling node of the Path above.\n  // TODO: handle the exception that this can throw, when `at` has the last\n  // number in it a `0`. This case is possible because the condition above that\n  // uses the Array.prototype.reduce method checks only the sum but the last 2\n  // items can be [2, 0], their sum is 2 but the last item is 0, so the\n  // exception is thrown.\n  const to = Path.previous(at);\n\n  // If the Path does not exist, mark the event as handled and do nothing.\n  if (!Node.has(editor, to)) return true;\n\n  // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just before its current location.\n  Transforms.moveNodes(editor, {\n    at,\n    to\n  });\n\n  // Mark the event as handled.\n  return true;\n}\n\n/**\n * Move down a list with with `Ctrl+Down`. (The Down key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\nexport function moveListItemDown({\n  editor,\n  event\n}) {\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!event.ctrlKey) return;\n  if (!isCursorInList(editor)) return false;\n\n  // Else\n  const {\n    slate\n  } = config.settings;\n\n  // Take the Node in the selection that is LI and is farthest-from-root.\n  const [match] = Editor.nodes(editor, {\n    // Explanation of the three modes:\n    // * 'all' - take all the nodes from the root Editor node to the selected\n    //   leaf Text node\n    // * 'highest' - take the root Editor node (if there is a selection, in case\n    //   no `at` option is given)\n    // * 'lowest' - take the farthest-from-root selected leaf Text node\n    // (Replace the \"leaf Text node\" expressions in the above list with\n    // whatever matching function you use.)\n    match: n => n.type === slate.listItemType,\n    reverse: true,\n    mode: 'lowest'\n  });\n\n  // Get the Path of the above-found Node.\n  const [, at] = match;\n\n  // Get the Path that represents the next sibling node of the Path above.\n  const to = Path.next(at);\n\n  // Prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n  event.preventDefault();\n  event.stopPropagation();\n\n  // If the Path does not exist, mark the event as handled and do nothing.\n  if (!Node.has(editor, to)) return true;\n\n  // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just after its current location, if there is a place for it\n  // at the same depth.\n  Transforms.moveNodes(editor, {\n    at,\n    to\n  });\n\n  // Mark the event as handled.\n  return true;\n}","map":{"version":3,"names":["Editor","Path","Transforms","Node","isCursorInList","getCurrentListItem","config","moveListItemUp","editor","event","ctrlKey","anchor","selection","slate","settings","preventDefault","stopPropagation","listItemPath","path","slice","reduce","acc","n","length","match","nodes","type","listItemType","mode","at","to","previous","has","moveNodes","moveListItemDown","reverse","next"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/blocks/Text/keyboard/moveListItems.js"],"sourcesContent":["import { Editor, Path, Transforms, Node } from 'slate';\nimport { isCursorInList, getCurrentListItem } from 'volto-slate/utils';\nimport config from '@plone/volto/registry';\n\n/**\n * Move up a list with with `Ctrl+Up`. (The Up key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\nexport function moveListItemUp({ editor, event }) {\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!(event.ctrlKey && isCursorInList(editor))) return;\n\n  // Else prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n  const { anchor } = editor.selection;\n  const { slate } = config.settings;\n\n  event.preventDefault();\n  event.stopPropagation();\n\n  // Store the current list item's path.\n  const [, listItemPath] = getCurrentListItem(editor);\n\n  // Don't allow in first line list item Check if the current list item is first\n  // in its parent\n  if (\n    // If the selection starts at the beginning of a root-level block node\n    anchor.path.slice(1).reduce((acc, n) => acc + n, 0) === 0 ||\n    // or the current list item is the first in the list that contains it\n    listItemPath[listItemPath.length - 1] === 0\n  ) {\n    // Mark the event as handled and do nothing.\n    return true;\n  }\n\n  // Take the Node in the selection that is LI and is farthest-from-root.\n  const [match] = Editor.nodes(editor, {\n    match: (n) => n.type === slate.listItemType,\n    // Explanation of the three modes:\n    // * 'all' - take all the nodes from the root Editor node to the selected\n    //   leaf Text node\n    // * 'highest' - take the root Editor node (if there is a selection, in case\n    //   no `at` option is given)\n    // * 'lowest' - take the farthest-from-root selected leaf Text node\n    // (Replace the \"leaf Text node\" expressions in the above list with\n    // whatever matching function you use.)\n    mode: 'lowest',\n  });\n\n  // Get the Path of the above-found Node.\n  const [, at] = match;\n\n  // Get the Path that represents the previous sibling node of the Path above.\n  // TODO: handle the exception that this can throw, when `at` has the last\n  // number in it a `0`. This case is possible because the condition above that\n  // uses the Array.prototype.reduce method checks only the sum but the last 2\n  // items can be [2, 0], their sum is 2 but the last item is 0, so the\n  // exception is thrown.\n  const to = Path.previous(at);\n\n  // If the Path does not exist, mark the event as handled and do nothing.\n  if (!Node.has(editor, to)) return true;\n\n  // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just before its current location.\n  Transforms.moveNodes(editor, { at, to });\n\n  // Mark the event as handled.\n  return true;\n}\n\n/**\n * Move down a list with with `Ctrl+Down`. (The Down key is supposed here to be\n * pressed.)\n * @param {Editor} Editor\n * @param {KeyboardEvent} event\n */\nexport function moveListItemDown({ editor, event }) {\n  // If Ctrl is not pressed or the cursor is not in a list, do nothing.\n  if (!event.ctrlKey) return;\n  if (!isCursorInList(editor)) return false;\n\n  // Else\n  const { slate } = config.settings;\n\n  // Take the Node in the selection that is LI and is farthest-from-root.\n  const [match] = Editor.nodes(editor, {\n    // Explanation of the three modes:\n    // * 'all' - take all the nodes from the root Editor node to the selected\n    //   leaf Text node\n    // * 'highest' - take the root Editor node (if there is a selection, in case\n    //   no `at` option is given)\n    // * 'lowest' - take the farthest-from-root selected leaf Text node\n    // (Replace the \"leaf Text node\" expressions in the above list with\n    // whatever matching function you use.)\n    match: (n) => n.type === slate.listItemType,\n    reverse: true,\n    mode: 'lowest',\n  });\n\n  // Get the Path of the above-found Node.\n  const [, at] = match;\n\n  // Get the Path that represents the next sibling node of the Path above.\n  const to = Path.next(at);\n\n  // Prevent the default behavior of Slate, React and DOM and stop the\n  // propagation of this event.\n  event.preventDefault();\n  event.stopPropagation();\n\n  // If the Path does not exist, mark the event as handled and do nothing.\n  if (!Node.has(editor, to)) return true;\n\n  // Move the Node in the selection that is LI and is farthest-from-root to the\n  // existing Path just after its current location, if there is a place for it\n  // at the same depth.\n  Transforms.moveNodes(editor, { at, to });\n\n  // Mark the event as handled.\n  return true;\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}