{"ast":null,"code":"import _classCallCheck from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _toConsumableArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _intersection from \"lodash/intersection\";\nimport _keys from \"lodash/keys\";\nimport _uniq from \"lodash/uniq\";\nimport _map from \"lodash/map\";\nimport { messages } from '../MessageLabels/MessageLabels';\n\n/**\n * Will return the intl message if invalid\n * @param {boolean} isValid\n * @param {string} maxCriterion\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {Function} intlFunc\n */\nvar validationMessage = function validationMessage(isValid, maxCriterion, valueToCompare, intlFunc) {\n  return !isValid ? intlFunc(messages[maxCriterion], {\n    len: valueToCompare\n  }) : null;\n};\n/**\n * Returns if based on the criterion the value is lower or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\nvar isMaxPropertyValid = function isMaxPropertyValid(value, valueToCompare, minCriterion, intlFunc) {\n  var isValid = valueToCompare !== undefined ? value <= valueToCompare : true;\n  return validationMessage(isValid, minCriterion, valueToCompare, intlFunc);\n};\n/**\n * Returns if based on the criterion the value is higher or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\nvar isMinPropertyValid = function isMinPropertyValid(value, valueToCompare, maxCriterion, intlFunc) {\n  var isValid = valueToCompare !== undefined ? value >= valueToCompare : true;\n  return validationMessage(isValid, maxCriterion, valueToCompare, intlFunc);\n};\nvar widgetValidation = {\n  email: {\n    isValidEmail: function isValidEmail(emailValue, emailObj, intlFunc) {\n      // Email Regex taken from from WHATWG living standard:\n      // https://html.spec.whatwg.org/multipage/input.html#e-mail-state-(type=email)\n      var emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n      var isValid = emailRegex.test(emailValue);\n      return !isValid ? intlFunc(messages.isValidEmail) : null;\n    },\n    minLength: function minLength(emailValue, emailObj, intlFunc) {\n      return isMinPropertyValid(emailValue.length, emailObj.minLength, 'minLength', intlFunc);\n    },\n    maxLength: function maxLength(emailValue, emailObj, intlFunc) {\n      return isMaxPropertyValid(emailValue.length, emailObj.maxLength, 'maxLength', intlFunc);\n    }\n  },\n  url: {\n    isValidURL: function isValidURL(urlValue, urlObj, intlFunc) {\n      var urlRegex = /^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([-.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([_.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^((http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/gm;\n      var isValid = urlRegex.test(urlValue);\n      return !isValid ? intlFunc(messages.isValidURL) : null;\n    },\n    minLength: function minLength(urlValue, urlObj, intlFunc) {\n      return isMinPropertyValid(urlValue.length, urlObj.minLength, 'minLength', intlFunc);\n    },\n    maxLength: function maxLength(urlValue, urlObj, intlFunc) {\n      return isMaxPropertyValid(urlValue.length, urlObj.maxLength, 'maxLength', intlFunc);\n    }\n  },\n  password: {\n    minLength: function minLength(passwordValue, passwordObj, intlFunc) {\n      return isMinPropertyValid(passwordValue.length, passwordObj.minLength, 'minLength', intlFunc);\n    },\n    maxLength: function maxLength(passwordValue, passwordObj, intlFunc) {\n      return isMaxPropertyValid(passwordValue.length, passwordObj.maxLength, 'maxLength', intlFunc);\n    }\n  },\n  string: {\n    minLength: function minLength(value, itemObj, intlFunc) {\n      return isMinPropertyValid(value.length, itemObj.minLength, 'minLength', intlFunc);\n    },\n    maxLength: function maxLength(value, itemObj, intlFunc) {\n      return isMaxPropertyValid(value.length, itemObj.maxLengthj, 'maxLength', intlFunc);\n    }\n  },\n  number: {\n    isNumber: function isNumber(value, itemObj, intlFunc) {\n      var floatRegex = /^[+-]?\\d+(\\.\\d+)?$/;\n      var isValid = !isNaN(value) && floatRegex.test(value);\n      return !isValid ? intlFunc(messages.isNumber) : null;\n    },\n    minimum: function minimum(value, itemObj, intlFunc) {\n      return isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc);\n    },\n    maximum: function maximum(value, itemObj, intlFunc) {\n      return isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc);\n    }\n  },\n  integer: {\n    isInteger: function isInteger(value, itemObj, intlFunc) {\n      var intRegex = /^-?[0-9]+$/;\n      var isValid = !isNaN(value) && intRegex.test(value);\n      return !isValid ? intlFunc(messages.isInteger) : null;\n    },\n    minimum: function minimum(value, itemObj, intlFunc) {\n      return isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc);\n    },\n    maximum: function maximum(value, itemObj, intlFunc) {\n      return isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc);\n    }\n  }\n};\n\n/**\n * The string that comes my not be a valid JSON\n * @param {string} requestItem\n */\nvar tryParseJSON = function tryParseJSON(requestItem) {\n  var resultObj = null;\n  try {\n    resultObj = JSON.parse(requestItem);\n  } catch (e) {\n    try {\n      resultObj = JSON.parse(requestItem.replace(/'/g, '\"'));\n    } catch (e) {\n      resultObj = null;\n    }\n  }\n  return resultObj;\n};\n\n/**\n * Returns errors if obj has unique Items\n * @param {Object} field\n * @param {*} fieldData\n * @returns {Object[string]} - list of errors\n */\nvar hasUniqueItems = function hasUniqueItems(field, fieldData, formatMessage) {\n  var errors = [];\n  if (field.uniqueItems && fieldData && _uniq(fieldData).length !== fieldData.length) {\n    errors.push(formatMessage(messages.uniqueItems));\n  }\n  return errors;\n};\n\n/**\n * If required fields are undefined, return list of errors\n * @returns {Object[string]} - list of errors\n */\nvar validateRequiredFields = function validateRequiredFields(schema, formData, formatMessage, touchedField) {\n  var errors = {};\n  var fields = _isEmpty(touchedField) ? schema.required : _intersection(schema.required, _keys(touchedField));\n  _map(fields, function (requiredField) {\n    var _schema$properties$re, _schema$properties$re2;\n    var type = (_schema$properties$re = schema.properties[requiredField]) === null || _schema$properties$re === void 0 ? void 0 : _schema$properties$re.type;\n    var widget = (_schema$properties$re2 = schema.properties[requiredField]) === null || _schema$properties$re2 === void 0 ? void 0 : _schema$properties$re2.widget;\n    var isEmpty = !formData[requiredField];\n    if (!isEmpty) {\n      if (type === 'array') {\n        isEmpty = formData[requiredField] ? formData[requiredField].length === 0 : true;\n      } else if (type === 'string' && widget === 'richtext') {\n        var _formData$requiredFie, _formData$requiredFie2;\n        isEmpty = !(((_formData$requiredFie = formData[requiredField]) === null || _formData$requiredFie === void 0 ? void 0 : (_formData$requiredFie2 = _formData$requiredFie.data) === null || _formData$requiredFie2 === void 0 ? void 0 : _formData$requiredFie2.replace(/(<([^>]+)>)/g, '').length) > 0);\n      }\n    }\n    if (schema.properties[requiredField] && schema.properties[requiredField].type !== 'boolean' && !schema.properties[requiredField].readonly && isEmpty) {\n      var requiredFieldName = schema.properties[requiredField].title || requiredField;\n      errors[requiredFieldName] = [];\n      errors[requiredFieldName].push(formatMessage(messages.required));\n    }\n  });\n  return errors;\n};\n/**\n * Return list of errors if field constraints are not respected\n * (ex min, max, maxLength, email format, url format etc)\n * each potential criterion has a validation process in widgetValidation\n * !!ONLY fields with data will be tested (those undefined are ignored here)\n * @returns {Object[string]} - list of errors\n */\nvar _validateFieldsPerFieldset = function validateFieldsPerFieldset(schema, formData, formatMessage, touchedField) {\n  var errors = validateRequiredFields(schema, formData, formatMessage, touchedField);\n  _map(schema.properties, function (field, fieldId) {\n    var fieldWidgetType = field.widget || field.type;\n    var widgetValidationCriteria = widgetValidation[fieldWidgetType] ? Object.keys(widgetValidation[fieldWidgetType]) : [];\n    var fieldData = formData[fieldId];\n    // test each criterion ex maximum, isEmail, isUrl, maxLength etc\n    var fieldErrors = widgetValidationCriteria.map(function (widgetCriterion) {\n      var errorMessage = fieldData === undefined || fieldData === null ? null : widgetValidation[fieldWidgetType][widgetCriterion](fieldData, field, formatMessage);\n      return errorMessage;\n    }).filter(function (item) {\n      return !!item;\n    });\n    var uniqueErrors = hasUniqueItems(field, fieldData, formatMessage);\n    var mergedErrors = [].concat(_toConsumableArray(fieldErrors), _toConsumableArray(uniqueErrors));\n    if (mergedErrors.length > 0) {\n      errors[fieldId] = [].concat(_toConsumableArray(errors[fieldId] || []), _toConsumableArray(fieldErrors), _toConsumableArray(uniqueErrors));\n    }\n  });\n  return errors;\n};\n\n/**\n * Create the errors object from backend the same way it is done on Frontend validation\n * @param {string} requestError form the server\n * @returns {Object}\n */\nvar _giveServerErrorsToCorrespondingFields = function giveServerErrorsToCorrespondingFields(requestError) {\n  var errorsList = tryParseJSON(requestError);\n  var errors = {};\n  if (Array.isArray(errorsList) && errorsList.length > 0) {\n    errorsList.forEach(function (errorItem) {\n      errors[errorItem.field] = errors[errorItem.field] ? errors[errorItem.field].push(errorItem.message) : [errorItem.message];\n    });\n  }\n  return errors;\n};\n\n/**\n * The first Fieldset (Tab) that has any errors\n * will be selected\n * @param {Object[]} errors\n * @param {string} errors[].field\n * @param {Object} schema\n * @returns {number} activeIndex\n */\nvar getIndexOfFirstTabWithErrors = function getIndexOfFirstTabWithErrors(errors, schema) {\n  var activeIndex = 0;\n  schema.fieldsets.some(function (fieldSet, index) {\n    var foundfield = fieldSet.fields.some(function (fieldId) {\n      return errors[fieldId];\n    });\n    activeIndex = foundfield ? index : activeIndex;\n    return foundfield;\n  });\n  return activeIndex;\n};\nvar FormValidation = /*#__PURE__*/function () {\n  function FormValidation() {\n    _classCallCheck(this, FormValidation);\n  }\n  _createClass(FormValidation, null, [{\n    key: \"showFirstTabWithErrors\",\n    value:\n    /**\n     * The first Fieldset (Tab) that has any errors\n     * will be selected\n     * @param {Object} errors\n     * @param {Object} schema\n     * @returns {number} activeIndex\n     */\n    function showFirstTabWithErrors() {\n      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$errors = _ref.errors,\n        errors = _ref$errors === void 0 ? {} : _ref$errors,\n        _ref$schema = _ref.schema,\n        schema = _ref$schema === void 0 ? {\n          properties: {},\n          fieldsets: [],\n          required: []\n        } : _ref$schema;\n      return getIndexOfFirstTabWithErrors(errors, schema);\n    }\n    /**\n     * Create the errors object from backend the same way it is done on Frontend validation\n     * @param {string} requestError form the server\n     * @returns {Object}\n     */\n  }, {\n    key: \"giveServerErrorsToCorrespondingFields\",\n    value: function giveServerErrorsToCorrespondingFields() {\n      var requestError = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n      return _giveServerErrorsToCorrespondingFields(requestError);\n    }\n    /**\n     * Return validation result\n     * @param {Object} schema\n     * @param {Object} formData\n     * @param {function} formatMessage\n     * @returns {Object} errors\n     */\n  }, {\n    key: \"validateFieldsPerFieldset\",\n    value: function validateFieldsPerFieldset() {\n      var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref2$schema = _ref2.schema,\n        schema = _ref2$schema === void 0 ? {\n          properties: {},\n          fieldsets: [],\n          required: []\n        } : _ref2$schema,\n        _ref2$formData = _ref2.formData,\n        formData = _ref2$formData === void 0 ? {} : _ref2$formData,\n        _ref2$formatMessage = _ref2.formatMessage,\n        formatMessage = _ref2$formatMessage === void 0 ? function () {} : _ref2$formatMessage,\n        _ref2$touchedField = _ref2.touchedField,\n        touchedField = _ref2$touchedField === void 0 ? {} : _ref2$touchedField;\n      return _validateFieldsPerFieldset(schema, formData, formatMessage, touchedField);\n    }\n  }]);\n  return FormValidation;\n}();\nexport default FormValidation;","map":{"version":3,"names":["messages","validationMessage","isValid","maxCriterion","valueToCompare","intlFunc","len","isMaxPropertyValid","value","minCriterion","undefined","isMinPropertyValid","widgetValidation","email","isValidEmail","emailValue","emailObj","emailRegex","test","minLength","length","maxLength","url","isValidURL","urlValue","urlObj","urlRegex","password","passwordValue","passwordObj","string","itemObj","maxLengthj","number","isNumber","floatRegex","isNaN","minimum","maximum","integer","isInteger","intRegex","tryParseJSON","requestItem","resultObj","JSON","parse","e","replace","hasUniqueItems","field","fieldData","formatMessage","errors","uniqueItems","push","validateRequiredFields","schema","formData","touchedField","fields","required","requiredField","type","properties","widget","isEmpty","data","readonly","requiredFieldName","title","validateFieldsPerFieldset","fieldId","fieldWidgetType","widgetValidationCriteria","Object","keys","fieldErrors","map","widgetCriterion","errorMessage","filter","item","uniqueErrors","mergedErrors","giveServerErrorsToCorrespondingFields","requestError","errorsList","Array","isArray","forEach","errorItem","message","getIndexOfFirstTabWithErrors","activeIndex","fieldsets","some","fieldSet","index","foundfield","FormValidation"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/FormValidation/FormValidation.js"],"sourcesContent":["import { map, uniq, keys, intersection, isEmpty } from 'lodash';\nimport { messages } from '../MessageLabels/MessageLabels';\n\n/**\n * Will return the intl message if invalid\n * @param {boolean} isValid\n * @param {string} maxCriterion\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {Function} intlFunc\n */\nconst validationMessage = (isValid, maxCriterion, valueToCompare, intlFunc) =>\n  !isValid\n    ? intlFunc(messages[maxCriterion], {\n        len: valueToCompare,\n      })\n    : null;\n/**\n * Returns if based on the criterion the value is lower or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\nconst isMaxPropertyValid = (value, valueToCompare, minCriterion, intlFunc) => {\n  const isValid = valueToCompare !== undefined ? value <= valueToCompare : true;\n  return validationMessage(isValid, minCriterion, valueToCompare, intlFunc);\n};\n/**\n * Returns if based on the criterion the value is higher or equal\n * @param {string | number} value can compare '47' < 50\n * @param {string | number} valueToCompare can compare '47' < 50\n * @param {string} minCriterion\n * @param {Function} intlFunc\n */\nconst isMinPropertyValid = (value, valueToCompare, maxCriterion, intlFunc) => {\n  const isValid = valueToCompare !== undefined ? value >= valueToCompare : true;\n  return validationMessage(isValid, maxCriterion, valueToCompare, intlFunc);\n};\n\nconst widgetValidation = {\n  email: {\n    isValidEmail: (emailValue, emailObj, intlFunc) => {\n      // Email Regex taken from from WHATWG living standard:\n      // https://html.spec.whatwg.org/multipage/input.html#e-mail-state-(type=email)\n      const emailRegex = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\n      const isValid = emailRegex.test(emailValue);\n      return !isValid ? intlFunc(messages.isValidEmail) : null;\n    },\n    minLength: (emailValue, emailObj, intlFunc) =>\n      isMinPropertyValid(\n        emailValue.length,\n        emailObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (emailValue, emailObj, intlFunc) =>\n      isMaxPropertyValid(\n        emailValue.length,\n        emailObj.maxLength,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  url: {\n    isValidURL: (urlValue, urlObj, intlFunc) => {\n      const urlRegex = /^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([-.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^(http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?[a-z0-9]+([_.]{1}[a-z0-9]+)*\\.[a-z]{2,5}(:[0-9]{1,5})?(\\/.*)?|^((http:\\/\\/www\\.|https:\\/\\/www\\.|http:\\/\\/|https:\\/\\/)?([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$/gm;\n      const isValid = urlRegex.test(urlValue);\n      return !isValid ? intlFunc(messages.isValidURL) : null;\n    },\n    minLength: (urlValue, urlObj, intlFunc) =>\n      isMinPropertyValid(\n        urlValue.length,\n        urlObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (urlValue, urlObj, intlFunc) =>\n      isMaxPropertyValid(\n        urlValue.length,\n        urlObj.maxLength,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  password: {\n    minLength: (passwordValue, passwordObj, intlFunc) =>\n      isMinPropertyValid(\n        passwordValue.length,\n        passwordObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (passwordValue, passwordObj, intlFunc) =>\n      isMaxPropertyValid(\n        passwordValue.length,\n        passwordObj.maxLength,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  string: {\n    minLength: (value, itemObj, intlFunc) =>\n      isMinPropertyValid(\n        value.length,\n        itemObj.minLength,\n        'minLength',\n        intlFunc,\n      ),\n    maxLength: (value, itemObj, intlFunc) =>\n      isMaxPropertyValid(\n        value.length,\n        itemObj.maxLengthj,\n        'maxLength',\n        intlFunc,\n      ),\n  },\n  number: {\n    isNumber: (value, itemObj, intlFunc) => {\n      const floatRegex = /^[+-]?\\d+(\\.\\d+)?$/;\n      const isValid = !isNaN(value) && floatRegex.test(value);\n      return !isValid ? intlFunc(messages.isNumber) : null;\n    },\n    minimum: (value, itemObj, intlFunc) =>\n      isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc),\n    maximum: (value, itemObj, intlFunc) =>\n      isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc),\n  },\n  integer: {\n    isInteger: (value, itemObj, intlFunc) => {\n      const intRegex = /^-?[0-9]+$/;\n      const isValid = !isNaN(value) && intRegex.test(value);\n      return !isValid ? intlFunc(messages.isInteger) : null;\n    },\n    minimum: (value, itemObj, intlFunc) =>\n      isMinPropertyValid(value, itemObj.minimum, 'minimum', intlFunc),\n    maximum: (value, itemObj, intlFunc) =>\n      isMaxPropertyValid(value, itemObj.maximum, 'maximum', intlFunc),\n  },\n};\n\n/**\n * The string that comes my not be a valid JSON\n * @param {string} requestItem\n */\nconst tryParseJSON = (requestItem) => {\n  let resultObj = null;\n  try {\n    resultObj = JSON.parse(requestItem);\n  } catch (e) {\n    try {\n      resultObj = JSON.parse(requestItem.replace(/'/g, '\"'));\n    } catch (e) {\n      resultObj = null;\n    }\n  }\n  return resultObj;\n};\n\n/**\n * Returns errors if obj has unique Items\n * @param {Object} field\n * @param {*} fieldData\n * @returns {Object[string]} - list of errors\n */\nconst hasUniqueItems = (field, fieldData, formatMessage) => {\n  const errors = [];\n  if (\n    field.uniqueItems &&\n    fieldData &&\n    uniq(fieldData).length !== fieldData.length\n  ) {\n    errors.push(formatMessage(messages.uniqueItems));\n  }\n  return errors;\n};\n\n/**\n * If required fields are undefined, return list of errors\n * @returns {Object[string]} - list of errors\n */\nconst validateRequiredFields = (\n  schema,\n  formData,\n  formatMessage,\n  touchedField,\n) => {\n  const errors = {};\n  const fields = isEmpty(touchedField)\n    ? schema.required\n    : intersection(schema.required, keys(touchedField));\n  map(fields, (requiredField) => {\n    const type = schema.properties[requiredField]?.type;\n    const widget = schema.properties[requiredField]?.widget;\n\n    let isEmpty = !formData[requiredField];\n    if (!isEmpty) {\n      if (type === 'array') {\n        isEmpty = formData[requiredField]\n          ? formData[requiredField].length === 0\n          : true;\n      } else if (type === 'string' && widget === 'richtext') {\n        isEmpty = !(\n          formData[requiredField]?.data?.replace(/(<([^>]+)>)/g, '').length > 0\n        );\n      }\n    }\n    if (\n      schema.properties[requiredField] &&\n      schema.properties[requiredField].type !== 'boolean' &&\n      !schema.properties[requiredField].readonly &&\n      isEmpty\n    ) {\n      const requiredFieldName =\n        schema.properties[requiredField].title || requiredField;\n      errors[requiredFieldName] = [];\n      errors[requiredFieldName].push(formatMessage(messages.required));\n    }\n  });\n\n  return errors;\n};\n/**\n * Return list of errors if field constraints are not respected\n * (ex min, max, maxLength, email format, url format etc)\n * each potential criterion has a validation process in widgetValidation\n * !!ONLY fields with data will be tested (those undefined are ignored here)\n * @returns {Object[string]} - list of errors\n */\nconst validateFieldsPerFieldset = (\n  schema,\n  formData,\n  formatMessage,\n  touchedField,\n) => {\n  const errors = validateRequiredFields(\n    schema,\n    formData,\n    formatMessage,\n    touchedField,\n  );\n\n  map(schema.properties, (field, fieldId) => {\n    const fieldWidgetType = field.widget || field.type;\n    const widgetValidationCriteria = widgetValidation[fieldWidgetType]\n      ? Object.keys(widgetValidation[fieldWidgetType])\n      : [];\n    let fieldData = formData[fieldId];\n    // test each criterion ex maximum, isEmail, isUrl, maxLength etc\n    const fieldErrors = widgetValidationCriteria\n      .map((widgetCriterion) => {\n        const errorMessage =\n          fieldData === undefined || fieldData === null\n            ? null\n            : widgetValidation[fieldWidgetType][widgetCriterion](\n                fieldData,\n                field,\n                formatMessage,\n              );\n        return errorMessage;\n      })\n      .filter((item) => !!item);\n\n    const uniqueErrors = hasUniqueItems(field, fieldData, formatMessage);\n    const mergedErrors = [...fieldErrors, ...uniqueErrors];\n\n    if (mergedErrors.length > 0) {\n      errors[fieldId] = [\n        ...(errors[fieldId] || []),\n        ...fieldErrors,\n        ...uniqueErrors,\n      ];\n    }\n  });\n\n  return errors;\n};\n\n/**\n * Create the errors object from backend the same way it is done on Frontend validation\n * @param {string} requestError form the server\n * @returns {Object}\n */\nconst giveServerErrorsToCorrespondingFields = (requestError) => {\n  let errorsList = tryParseJSON(requestError);\n  const errors = {};\n\n  if (Array.isArray(errorsList) && errorsList.length > 0) {\n    errorsList.forEach((errorItem) => {\n      errors[errorItem.field] = errors[errorItem.field]\n        ? errors[errorItem.field].push(errorItem.message)\n        : [errorItem.message];\n    });\n  }\n  return errors;\n};\n\n/**\n * The first Fieldset (Tab) that has any errors\n * will be selected\n * @param {Object[]} errors\n * @param {string} errors[].field\n * @param {Object} schema\n * @returns {number} activeIndex\n */\nconst getIndexOfFirstTabWithErrors = (errors, schema) => {\n  let activeIndex = 0;\n\n  schema.fieldsets.some((fieldSet, index) => {\n    let foundfield = fieldSet.fields.some((fieldId) => errors[fieldId]);\n\n    activeIndex = foundfield ? index : activeIndex;\n    return foundfield;\n  });\n\n  return activeIndex;\n};\n\nclass FormValidation {\n  /**\n   * The first Fieldset (Tab) that has any errors\n   * will be selected\n   * @param {Object} errors\n   * @param {Object} schema\n   * @returns {number} activeIndex\n   */\n  static showFirstTabWithErrors({\n    errors = {},\n    schema = { properties: {}, fieldsets: [], required: [] },\n  } = {}) {\n    return getIndexOfFirstTabWithErrors(errors, schema);\n  }\n  /**\n   * Create the errors object from backend the same way it is done on Frontend validation\n   * @param {string} requestError form the server\n   * @returns {Object}\n   */\n  static giveServerErrorsToCorrespondingFields(requestError = '') {\n    return giveServerErrorsToCorrespondingFields(requestError);\n  }\n  /**\n   * Return validation result\n   * @param {Object} schema\n   * @param {Object} formData\n   * @param {function} formatMessage\n   * @returns {Object} errors\n   */\n  static validateFieldsPerFieldset({\n    schema = { properties: {}, fieldsets: [], required: [] },\n    formData = {},\n    formatMessage = () => {},\n    touchedField = {},\n  } = {}) {\n    return validateFieldsPerFieldset(\n      schema,\n      formData,\n      formatMessage,\n      touchedField,\n    );\n  }\n}\n\nexport default FormValidation;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}