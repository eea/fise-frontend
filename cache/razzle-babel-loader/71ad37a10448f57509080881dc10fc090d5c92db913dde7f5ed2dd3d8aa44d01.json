{"ast":null,"code":"import _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _defineProperty from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport { isCmsUi } from '@plone/volto/helpers';\nvar LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\nvar PROTECT_START = '@@loadProtector/START';\nvar PROTECT_END = '@@loadProtector/END';\nvar PROTECT_SKIPPED = '@@loadProtector/SKIPPED';\nvar GET_CONTENT_PENDING = 'GET_CONTENT_PENDING';\nvar GET_CONTENT_SUCCESS = 'GET_CONTENT_SUCCESS';\nvar GET_CONTENT_FAIL = 'GET_CONTENT_FAIL';\nvar RESET_CONTENT = 'RESET_CONTENT';\n\n// ---\n// The load protector middlewares have multiple purposes.\n//\n// 1. Maintained a delayed location that can be used to trigger an UI\n// change (such as scroll to top) after all content for the page has been\n// loaded.\n//\n// 2. When moving from a non content route to a content route, issue\n// a data reset before the content load operation. - However do not do\n// such a reset when navigating between two content routes.\n// ---\n\nexport var protectLoadStart = function protectLoadStart(_ref) {\n  var dispatch = _ref.dispatch,\n    getState = _ref.getState;\n  return function (next) {\n    return function (action) {\n      if (typeof action === 'function') {\n        return next(action);\n      }\n      switch (action.type) {\n        case LOCATION_CHANGE:\n          var location = action.payload.location;\n          var path = location.pathname;\n          var currentPath = getState().router.location.pathname;\n          var result = next(action);\n          if (isCmsUi(path)) {\n            // Next path: isCmsUI, Non Content. There is no\n            // loading here, so skip counting altogether.\n            // Will update the delayed location constantly.\n            dispatch({\n              type: PROTECT_SKIPPED,\n              location: location\n            });\n          } else {\n            dispatch({\n              type: PROTECT_START,\n              location: location,\n              // Only reset before the fetch, if we depart from\n              // a not isCmsUi, Content pass. However, reset will\n              // not occur if moving between two content paths,\n              // only the postponed location will be booked.\n              resetBeforeFetch: isCmsUi(currentPath)\n            });\n          }\n          return result;\n        default:\n          return next(action);\n      }\n    };\n  };\n};\n\n// Note that there is a bit of heuristics here. We assume that every action\n// like this is beginning/ending an action. If this logic fails then the counting\n// will be off, resulting either a premature or an indefinitely missing state change.\nvar isRequestAction = function isRequestAction(action) {\n  return action.type.endsWith('_PENDING');\n};\nvar isResponseAction = function isResponseAction(action) {\n  return action.type.endsWith('_SUCCESS') || action.type.endsWith('_FAIL');\n};\n\n// Action map defines an action to be emitted before the key action\nvar mapActions = _defineProperty({}, GET_CONTENT_PENDING, RESET_CONTENT);\nexport var protectLoadEnd = function protectLoadEnd(_ref2) {\n  var dispatch = _ref2.dispatch,\n    getState = _ref2.getState;\n  return function (next) {\n    return function (action) {\n      if (typeof action === 'function') {\n        return next(action);\n      }\n      var _getState$loadProtect = getState().loadProtector,\n        isCounting = _getState$loadProtect.isCounting,\n        resetBeforeFetch = _getState$loadProtect.resetBeforeFetch,\n        requestCount = _getState$loadProtect.requestCount;\n      if (resetBeforeFetch) {\n        var type = mapActions[action.type];\n        if (type) {\n          dispatch({\n            type: type\n          });\n        }\n      }\n      if (isCounting && requestCount === 1 && isResponseAction(action)) {\n        setTimeout(function () {\n          return dispatch({\n            type: PROTECT_END\n          });\n        }, 0);\n      }\n      return next(action);\n    };\n  };\n};\nexport function loadProtector() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var action = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  switch (action.type) {\n    case PROTECT_START:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: true,\n        resetBeforeFetch: action.resetBeforeFetch,\n        postponedLocation: action.location\n      });\n    case PROTECT_END:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false\n      });\n    case PROTECT_SKIPPED:\n      return _objectSpread(_objectSpread({}, state), {}, {\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n        postponedLocation: null,\n        location: action.location\n      });\n    case GET_CONTENT_SUCCESS:\n    case GET_CONTENT_FAIL:\n      if (state.isCounting) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: state.requestCount - 1,\n          postponedLocation: null,\n          location: state.postponedLocation\n        });\n      } else {\n        return state;\n      }\n    case RESET_CONTENT:\n      if (state.resetBeforeFetch) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          resetBeforeFetch: false\n        });\n      } else {\n        return state;\n      }\n    default:\n      var isCounting = state.isCounting,\n        requestCount = state.requestCount;\n      if (isCounting && isRequestAction(action)) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: requestCount + 1\n        });\n      } else if (isCounting && isResponseAction(action)) {\n        return _objectSpread(_objectSpread({}, state), {}, {\n          requestCount: requestCount - 1\n        });\n      } else {\n        return state;\n      }\n  }\n}","map":{"version":3,"names":["isCmsUi","LOCATION_CHANGE","PROTECT_START","PROTECT_END","PROTECT_SKIPPED","GET_CONTENT_PENDING","GET_CONTENT_SUCCESS","GET_CONTENT_FAIL","RESET_CONTENT","protectLoadStart","dispatch","getState","next","action","type","location","payload","path","pathname","currentPath","router","result","resetBeforeFetch","isRequestAction","endsWith","isResponseAction","mapActions","protectLoadEnd","loadProtector","isCounting","requestCount","setTimeout","state","postponedLocation"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/middleware/storeProtectLoadUtils.js"],"sourcesContent":["import { isCmsUi } from '@plone/volto/helpers';\n\nconst LOCATION_CHANGE = '@@router/LOCATION_CHANGE';\nconst PROTECT_START = '@@loadProtector/START';\nconst PROTECT_END = '@@loadProtector/END';\nconst PROTECT_SKIPPED = '@@loadProtector/SKIPPED';\nconst GET_CONTENT_PENDING = 'GET_CONTENT_PENDING';\nconst GET_CONTENT_SUCCESS = 'GET_CONTENT_SUCCESS';\nconst GET_CONTENT_FAIL = 'GET_CONTENT_FAIL';\nconst RESET_CONTENT = 'RESET_CONTENT';\n\n// ---\n// The load protector middlewares have multiple purposes.\n//\n// 1. Maintained a delayed location that can be used to trigger an UI\n// change (such as scroll to top) after all content for the page has been\n// loaded.\n//\n// 2. When moving from a non content route to a content route, issue\n// a data reset before the content load operation. - However do not do\n// such a reset when navigating between two content routes.\n// ---\n\nexport const protectLoadStart = ({ dispatch, getState }) => (next) => (\n  action,\n) => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  switch (action.type) {\n    case LOCATION_CHANGE:\n      const { location } = action.payload;\n      const { pathname: path } = location;\n      const currentPath = getState().router.location.pathname;\n      const result = next(action);\n      if (isCmsUi(path)) {\n        // Next path: isCmsUI, Non Content. There is no\n        // loading here, so skip counting altogether.\n        // Will update the delayed location constantly.\n        dispatch({\n          type: PROTECT_SKIPPED,\n          location,\n        });\n      } else {\n        dispatch({\n          type: PROTECT_START,\n          location,\n          // Only reset before the fetch, if we depart from\n          // a not isCmsUi, Content pass. However, reset will\n          // not occur if moving between two content paths,\n          // only the postponed location will be booked.\n          resetBeforeFetch: isCmsUi(currentPath),\n        });\n      }\n      return result;\n    default:\n      return next(action);\n  }\n};\n\n// Note that there is a bit of heuristics here. We assume that every action\n// like this is beginning/ending an action. If this logic fails then the counting\n// will be off, resulting either a premature or an indefinitely missing state change.\nconst isRequestAction = (action) => action.type.endsWith('_PENDING');\nconst isResponseAction = (action) =>\n  action.type.endsWith('_SUCCESS') || action.type.endsWith('_FAIL');\n\n// Action map defines an action to be emitted before the key action\nconst mapActions = {\n  [GET_CONTENT_PENDING]: RESET_CONTENT,\n};\n\nexport const protectLoadEnd = ({ dispatch, getState }) => (next) => (\n  action,\n) => {\n  if (typeof action === 'function') {\n    return next(action);\n  }\n  const {\n    isCounting,\n    resetBeforeFetch,\n    requestCount,\n  } = getState().loadProtector;\n  if (resetBeforeFetch) {\n    const type = mapActions[action.type];\n    if (type) {\n      dispatch({ type });\n    }\n  }\n  if (isCounting && requestCount === 1 && isResponseAction(action)) {\n    setTimeout(\n      () =>\n        dispatch({\n          type: PROTECT_END,\n        }),\n      0,\n    );\n  }\n  return next(action);\n};\n\nexport function loadProtector(state = {}, action = {}) {\n  switch (action.type) {\n    case PROTECT_START:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: true,\n        resetBeforeFetch: action.resetBeforeFetch,\n        postponedLocation: action.location,\n      };\n    case PROTECT_END:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n      };\n    case PROTECT_SKIPPED:\n      return {\n        ...state,\n        requestCount: 0,\n        isCounting: false,\n        resetBeforeFetch: false,\n        postponedLocation: null,\n        location: action.location,\n      };\n    case GET_CONTENT_SUCCESS:\n    case GET_CONTENT_FAIL:\n      if (state.isCounting) {\n        return {\n          ...state,\n          requestCount: state.requestCount - 1,\n          postponedLocation: null,\n          location: state.postponedLocation,\n        };\n      } else {\n        return state;\n      }\n    case RESET_CONTENT:\n      if (state.resetBeforeFetch) {\n        return {\n          ...state,\n          resetBeforeFetch: false,\n        };\n      } else {\n        return state;\n      }\n    default:\n      const { isCounting, requestCount } = state;\n      if (isCounting && isRequestAction(action)) {\n        return {\n          ...state,\n          requestCount: requestCount + 1,\n        };\n      } else if (isCounting && isResponseAction(action)) {\n        return {\n          ...state,\n          requestCount: requestCount - 1,\n        };\n      } else {\n        return state;\n      }\n  }\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}