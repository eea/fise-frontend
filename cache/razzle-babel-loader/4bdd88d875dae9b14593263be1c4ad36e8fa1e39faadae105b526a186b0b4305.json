{"ast":null,"code":"import _extends from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/extends.js\";\nimport _defineProperty from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _toConsumableArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nvar _jsxFileName = \"/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/Extensions/withBlockExtensions.js\",\n  _this = this;\nvar __jsx = React.createElement;\n/**\n * A HOC to inject a block extension by resolving the configured extension\n */\n\nimport React from 'react';\nimport config from '@plone/volto/registry';\n\n/**\n * Retrieves the extension (variation) settings from the provided\n * configuration, based on incoming data.\n */\nexport function resolveExtension(name, extensions, data) {\n  var selectedExtension = data[name];\n  var index = extensions.findIndex(function (conf) {\n    return conf.id === selectedExtension;\n  });\n  if (index === -1) {\n    index = extensions.findIndex(function (conf) {\n      return conf.isDefault;\n    });\n  }\n  return index !== -1 ? extensions[index] : undefined;\n}\n\n/**\n * A block can declare extensions and variations like:\n *\n * {\n *  variations: [\n *    {\n *      id: \"summary\",\n *      isDefault: true,\n *      template: Something\n *    }\n *  ],\n *  extensions: {\n *    'extensionA': {\n *      items: [\n *        // something similar to variations\n *      ]\n *    }\n *  }\n * }\n *\n * Exactly what an extension and what a variation represent is only up to the\n * block. A block should incorporate these extension mechanisms and it should\n * define what information is needed from them.\n *\n * resolveBlockExtensions will return an object with\n * `{ extensions, resolvedExtensions}`, where:\n *\n * - extensions is the blocksConfig extensions object for that block\n * - resolvedExtensions is an object with\n *   `{ variation, <someExtensionA>, <someExtensionB> }` and each of these\n *   fields hold the coresponding definition object from the block's\n *   configuration.\n */\nexport function resolveBlockExtensions(data, blocksConfig) {\n  var block_type = data['@type'];\n  var _ref = (blocksConfig === null || blocksConfig === void 0 ? void 0 : blocksConfig[block_type]) || config.blocks.blocksConfig[block_type],\n    _ref$extensions = _ref.extensions,\n    extensions = _ref$extensions === void 0 ? {} : _ref$extensions,\n    _ref$variations = _ref.variations,\n    variations = _ref$variations === void 0 ? [] : _ref$variations;\n  var resolvedExtensions = Object.assign.apply(Object, [{}].concat(_toConsumableArray(Object.keys(extensions).map(function (extensionName) {\n    return _defineProperty({}, extensionName, resolveExtension(extensionName, extensions[extensionName].items || [], data, block_type));\n  }))));\n  if (variations.length) {\n    var variation = data.variation ? variations.find(function (_ref3) {\n      var id = _ref3.id;\n      return id === data.variation;\n    }) : variations.find(function (_ref4) {\n      var isDefault = _ref4.isDefault;\n      return isDefault;\n    });\n    resolvedExtensions.variation = variation;\n  }\n  return {\n    extensions: extensions,\n    resolvedExtensions: resolvedExtensions\n  };\n}\nvar withBlockExtensions = function withBlockExtensions(WrappedComponent) {\n  return function (props) {\n    var data = props.data,\n      blocksConfig = props.blocksConfig;\n    var _resolveBlockExtensio = resolveBlockExtensions(data, blocksConfig),\n      extensions = _resolveBlockExtensio.extensions,\n      resolvedExtensions = _resolveBlockExtensio.resolvedExtensions;\n    return __jsx(WrappedComponent, _extends({}, resolvedExtensions, props, {\n      extensions: extensions,\n      __self: _this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 93,\n        columnNumber: 5\n      }\n    }));\n  };\n};\nexport default withBlockExtensions;","map":{"version":3,"names":["React","config","resolveExtension","name","extensions","data","selectedExtension","index","findIndex","conf","id","isDefault","undefined","resolveBlockExtensions","blocksConfig","block_type","blocks","variations","resolvedExtensions","Object","assign","keys","map","extensionName","items","length","variation","find","withBlockExtensions","WrappedComponent","props"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/Extensions/withBlockExtensions.js"],"sourcesContent":["/**\n * A HOC to inject a block extension by resolving the configured extension\n */\n\nimport React from 'react';\nimport config from '@plone/volto/registry';\n\n/**\n * Retrieves the extension (variation) settings from the provided\n * configuration, based on incoming data.\n */\nexport function resolveExtension(name, extensions, data) {\n  const selectedExtension = data[name];\n\n  let index = extensions.findIndex((conf) => conf.id === selectedExtension);\n\n  if (index === -1) {\n    index = extensions.findIndex((conf) => conf.isDefault);\n  }\n\n  return index !== -1 ? extensions[index] : undefined;\n}\n\n/**\n * A block can declare extensions and variations like:\n *\n * {\n *  variations: [\n *    {\n *      id: \"summary\",\n *      isDefault: true,\n *      template: Something\n *    }\n *  ],\n *  extensions: {\n *    'extensionA': {\n *      items: [\n *        // something similar to variations\n *      ]\n *    }\n *  }\n * }\n *\n * Exactly what an extension and what a variation represent is only up to the\n * block. A block should incorporate these extension mechanisms and it should\n * define what information is needed from them.\n *\n * resolveBlockExtensions will return an object with\n * `{ extensions, resolvedExtensions}`, where:\n *\n * - extensions is the blocksConfig extensions object for that block\n * - resolvedExtensions is an object with\n *   `{ variation, <someExtensionA>, <someExtensionB> }` and each of these\n *   fields hold the coresponding definition object from the block's\n *   configuration.\n */\nexport function resolveBlockExtensions(data, blocksConfig) {\n  const block_type = data['@type'];\n\n  const { extensions = {}, variations = [] } =\n    blocksConfig?.[block_type] || config.blocks.blocksConfig[block_type];\n\n  const resolvedExtensions = Object.assign(\n    {},\n    ...Object.keys(extensions).map((extensionName) => ({\n      [extensionName]: resolveExtension(\n        extensionName,\n        extensions[extensionName].items || [],\n        data,\n        block_type,\n      ),\n    })),\n  );\n\n  if (variations.length) {\n    const variation = data.variation\n      ? variations.find(({ id }) => id === data.variation)\n      : variations.find(({ isDefault }) => isDefault);\n    resolvedExtensions.variation = variation;\n  }\n\n  return { extensions, resolvedExtensions };\n}\n\nconst withBlockExtensions = (WrappedComponent) => (props) => {\n  const { data, blocksConfig } = props;\n\n  const { extensions, resolvedExtensions } = resolveBlockExtensions(\n    data,\n    blocksConfig,\n  );\n  return (\n    <WrappedComponent\n      {...resolvedExtensions}\n      {...props}\n      extensions={extensions}\n    />\n  );\n};\n\nexport default withBlockExtensions;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}