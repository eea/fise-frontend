{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport { jsx } from 'slate-hyperscript';\nimport { Text } from 'slate';\nimport { isWhitespace } from '@plone/volto-slate/utils';\nimport { TD, TH, COMMENT, ELEMENT_NODE, INLINE_ELEMENTS, TEXT_NODE } from '../constants';\nconst isInline = node => node && (node.nodeType === TEXT_NODE || INLINE_ELEMENTS.includes(node.nodeName));\n\n/**\n * Deserialize to an object or an Array.\n *\n * This returns a Slate Node or null.\n */\nexport const deserialize = (editor, el) => {\n  // console.log('deserialize el:', el);\n  const {\n    htmlTagsToSlate\n  } = editor;\n\n  // console.log('des:', el.nodeType, el);\n  if (el.nodeType === COMMENT) {\n    return null;\n  } else if (el.nodeType === TEXT_NODE) {\n    // instead of === '\\n' we use isWhitespace for when deserializing tables\n    // from Calc and other similar cases\n\n    // console.log('maybe whitespace', {\n    //   text: `-${el.textContent}-`,\n    //   prev: el.previousSibling,\n    //   next: el.nextSibling,\n    //   isPrev: isInline(el.previousSibling),\n    //   isNext: isInline(el.nextSibling),\n    //   prevName: el.previousSibling && el.previousSibling.nodeName,\n    //   nextName: el.nextSibling && el.nextSibling.nodeName,\n    // });\n\n    if (isWhitespace(el.textContent)) {\n      // console.log({\n      //   text: `-${el.textContent}-`,\n      //   prev: el.previousSibling,\n      //   next: el.nextSibling,\n      //   isPrev: isInline(el.previousSibling),\n      //   isNext: isInline(el.nextSibling),\n      //   prevName: el.previousSibling && el.previousSibling.nodeName,\n      //   nextName: el.nextSibling && el.nextSibling.nodeName,\n      // });\n      // if it's empty text between 2 tags, it should be ignored\n      return isInline(el.previousSibling) || isInline(el.nextSibling) ? {\n        text: el.textContent\n      } // perceptually multiple whitespace render as a single space\n      : null;\n    }\n    return {\n      text: el.textContent.replace(/\\n$/g, ' ').replace(/\\n/g, ' ').replace(/\\t/g, '')\n    };\n  } else if (el.nodeType !== ELEMENT_NODE) {\n    return null;\n  } else if (el.nodeName === 'BR') {\n    // TODO: is handling <br> like this ok in all cases ?\n    return {\n      text: '\\n'\n    };\n  }\n  if (el.getAttribute('data-slate-data')) {\n    return typeDeserialize(editor, el);\n  }\n  const {\n    nodeName\n  } = el;\n  if (htmlTagsToSlate[nodeName]) {\n    return htmlTagsToSlate[nodeName](editor, el);\n  }\n  return deserializeChildren(el, editor); // fallback deserializer\n};\n\nexport const typeDeserialize = (editor, el) => {\n  const jsData = el.getAttribute('data-slate-data');\n  const {\n    type,\n    data\n  } = JSON.parse(jsData);\n  return jsx('element', {\n    type,\n    data\n  }, deserializeChildren(el, editor));\n};\nexport const deserializeChildren = (parent, editor) => Array.from(parent.childNodes).map(el => deserialize(editor, el)).flat();\nexport const blockTagDeserializer = tagname => (editor, el) => {\n  // if (tagname === 'h2') debugger;\n  let children = deserializeChildren(el, editor).filter(n => n !== null);\n  if ([TD, TH].includes(tagname) && children.length > 0 && typeof children[0] === 'string') {\n    // TODO: should here be handled the cases when there are more strings in\n    // `children` or when there are besides strings other types of nodes too?\n    const p = {\n      type: 'div',\n      children: [{\n        text: ''\n      }]\n    };\n    p.children[0].text = children[0];\n    children = [p];\n  }\n\n  // normalizes block elements so that they're never empty\n  // Avoids a hard crash from the Slate editor\n  const hasValidChildren = children.length && children.find(c => !!c);\n  if (!hasValidChildren) {\n    children = [{\n      text: ''\n    }];\n  }\n  return jsx('element', {\n    type: tagname\n  }, children);\n};\nexport const bodyTagDeserializer = (editor, el) => {\n  return jsx('fragment', {}, deserializeChildren(el, editor));\n};\nexport const inlineTagDeserializer = attrs => (editor, el) => {\n  return deserializeChildren(el, editor).map(child => {\n    const res = Text.isText(child) || typeof child === 'string' ? jsx('text', attrs, child) : _objectSpread(_objectSpread({}, child), {}, {\n      attrs // pass the inline attrs as separate object\n    });\n\n    return res;\n  });\n};\nexport const spanTagDeserializer = (editor, el) => {\n  const style = el.getAttribute('style') || '';\n  let children = el.childNodes;\n  if (\n  // handle formatting from OpenOffice\n  children.length === 1 && children[0].nodeType === 3 && children[0].textContent === '\\n') {\n    return jsx('text', {}, ' ');\n  }\n  children = deserializeChildren(el, editor);\n\n  // whitespace is replaced by deserialize() with null;\n  children = children.map(c => c === null ? ' ' : c);\n\n  // TODO: handle sub/sup as <sub> and <sup>\n  // Handle Google Docs' <sub> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:sub') > -1) {\n    const attrs = {\n      sub: true\n    };\n    return children.map(child => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  // Handle Google Docs' <sup> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:super') > -1) {\n    const attrs = {\n      sup: true\n    };\n    return children.map(child => {\n      return jsx('text', attrs, child);\n    });\n  }\n  const res = children.find(c => typeof c !== 'string') ? children : jsx('text', {}, children);\n  return res;\n};\nexport const bTagDeserializer = (editor, el) => {\n  // Google Docs does weird things with <b> tag\n  return (el.getAttribute('id') || '').indexOf('docs-internal-guid') > -1 ? deserializeChildren(el, editor) : jsx('element', {\n    type: 'b'\n  }, deserializeChildren(el, editor));\n};\nexport const codeTagDeserializer = (editor, el) => {\n  return jsx('element', {\n    type: 'code'\n  }, el.textContent);\n};\nexport const preTagDeserializer = (editor, el) => {\n  // Based on Slate example implementation. Replaces <pre> tags with <code>.\n  // Comment: I don't know how good of an idea is this. I'd rather have two\n  // separate formats: \"preserve whitespace\" and \"code\". This feels like a hack\n  const {\n    nodeName\n  } = el;\n  let parent = el;\n  if (el.childNodes[0] && el.childNodes[0].nodeName === 'CODE') {\n    parent = el.childNodes[0];\n    return codeTagDeserializer(editor, parent);\n  }\n  return blockTagDeserializer(nodeName)(editor, parent);\n};\nexport default deserialize;","map":{"version":3,"names":["jsx","Text","isWhitespace","TD","TH","COMMENT","ELEMENT_NODE","INLINE_ELEMENTS","TEXT_NODE","isInline","node","nodeType","includes","nodeName","deserialize","editor","el","htmlTagsToSlate","textContent","previousSibling","nextSibling","text","replace","getAttribute","typeDeserialize","deserializeChildren","jsData","type","data","JSON","parse","parent","Array","from","childNodes","map","flat","blockTagDeserializer","tagname","children","filter","n","length","p","hasValidChildren","find","c","bodyTagDeserializer","inlineTagDeserializer","attrs","child","res","isText","spanTagDeserializer","style","indexOf","sub","sup","bTagDeserializer","codeTagDeserializer","preTagDeserializer"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/packages/volto-slate/src/editor/deserialize.js"],"sourcesContent":["import { jsx } from 'slate-hyperscript';\nimport { Text } from 'slate';\nimport { isWhitespace } from '@plone/volto-slate/utils';\nimport {\n  TD,\n  TH,\n  COMMENT,\n  ELEMENT_NODE,\n  INLINE_ELEMENTS,\n  TEXT_NODE,\n} from '../constants';\n\nconst isInline = (node) =>\n  node &&\n  (node.nodeType === TEXT_NODE || INLINE_ELEMENTS.includes(node.nodeName));\n\n/**\n * Deserialize to an object or an Array.\n *\n * This returns a Slate Node or null.\n */\nexport const deserialize = (editor, el) => {\n  // console.log('deserialize el:', el);\n  const { htmlTagsToSlate } = editor;\n\n  // console.log('des:', el.nodeType, el);\n  if (el.nodeType === COMMENT) {\n    return null;\n  } else if (el.nodeType === TEXT_NODE) {\n    // instead of === '\\n' we use isWhitespace for when deserializing tables\n    // from Calc and other similar cases\n\n    // console.log('maybe whitespace', {\n    //   text: `-${el.textContent}-`,\n    //   prev: el.previousSibling,\n    //   next: el.nextSibling,\n    //   isPrev: isInline(el.previousSibling),\n    //   isNext: isInline(el.nextSibling),\n    //   prevName: el.previousSibling && el.previousSibling.nodeName,\n    //   nextName: el.nextSibling && el.nextSibling.nodeName,\n    // });\n\n    if (isWhitespace(el.textContent)) {\n      // console.log({\n      //   text: `-${el.textContent}-`,\n      //   prev: el.previousSibling,\n      //   next: el.nextSibling,\n      //   isPrev: isInline(el.previousSibling),\n      //   isNext: isInline(el.nextSibling),\n      //   prevName: el.previousSibling && el.previousSibling.nodeName,\n      //   nextName: el.nextSibling && el.nextSibling.nodeName,\n      // });\n      // if it's empty text between 2 tags, it should be ignored\n      return isInline(el.previousSibling) || isInline(el.nextSibling)\n        ? { text: el.textContent } // perceptually multiple whitespace render as a single space\n        : null;\n    }\n    return {\n      text: el.textContent\n        .replace(/\\n$/g, ' ')\n        .replace(/\\n/g, ' ')\n        .replace(/\\t/g, ''),\n    };\n  } else if (el.nodeType !== ELEMENT_NODE) {\n    return null;\n  } else if (el.nodeName === 'BR') {\n    // TODO: is handling <br> like this ok in all cases ?\n    return { text: '\\n' };\n  }\n\n  if (el.getAttribute('data-slate-data')) {\n    return typeDeserialize(editor, el);\n  }\n\n  const { nodeName } = el;\n\n  if (htmlTagsToSlate[nodeName]) {\n    return htmlTagsToSlate[nodeName](editor, el);\n  }\n\n  return deserializeChildren(el, editor); // fallback deserializer\n};\n\nexport const typeDeserialize = (editor, el) => {\n  const jsData = el.getAttribute('data-slate-data');\n  const { type, data } = JSON.parse(jsData);\n  return jsx('element', { type, data }, deserializeChildren(el, editor));\n};\n\nexport const deserializeChildren = (parent, editor) =>\n  Array.from(parent.childNodes)\n    .map((el) => deserialize(editor, el))\n    .flat();\n\nexport const blockTagDeserializer = (tagname) => (editor, el) => {\n  // if (tagname === 'h2') debugger;\n  let children = deserializeChildren(el, editor).filter((n) => n !== null);\n\n  if (\n    [TD, TH].includes(tagname) &&\n    children.length > 0 &&\n    typeof children[0] === 'string'\n  ) {\n    // TODO: should here be handled the cases when there are more strings in\n    // `children` or when there are besides strings other types of nodes too?\n    const p = { type: 'div', children: [{ text: '' }] };\n    p.children[0].text = children[0];\n    children = [p];\n  }\n\n  // normalizes block elements so that they're never empty\n  // Avoids a hard crash from the Slate editor\n  const hasValidChildren = children.length && children.find((c) => !!c);\n  if (!hasValidChildren) {\n    children = [{ text: '' }];\n  }\n\n  return jsx('element', { type: tagname }, children);\n};\n\nexport const bodyTagDeserializer = (editor, el) => {\n  return jsx('fragment', {}, deserializeChildren(el, editor));\n};\n\nexport const inlineTagDeserializer = (attrs) => (editor, el) => {\n  return deserializeChildren(el, editor).map((child) => {\n    const res =\n      Text.isText(child) || typeof child === 'string'\n        ? jsx('text', attrs, child)\n        : {\n            ...child,\n            attrs, // pass the inline attrs as separate object\n          };\n    return res;\n  });\n};\n\nexport const spanTagDeserializer = (editor, el) => {\n  const style = el.getAttribute('style') || '';\n  let children = el.childNodes;\n  if (\n    // handle formatting from OpenOffice\n    children.length === 1 &&\n    children[0].nodeType === 3 &&\n    children[0].textContent === '\\n'\n  ) {\n    return jsx('text', {}, ' ');\n  }\n  children = deserializeChildren(el, editor);\n\n  // whitespace is replaced by deserialize() with null;\n  children = children.map((c) => (c === null ? ' ' : c));\n\n  // TODO: handle sub/sup as <sub> and <sup>\n  // Handle Google Docs' <sub> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:sub') > -1) {\n    const attrs = { sub: true };\n    return children.map((child) => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  // Handle Google Docs' <sup> formatting\n  if (style.replace(/\\s/g, '').indexOf('vertical-align:super') > -1) {\n    const attrs = { sup: true };\n    return children.map((child) => {\n      return jsx('text', attrs, child);\n    });\n  }\n\n  const res = children.find((c) => typeof c !== 'string')\n    ? children\n    : jsx('text', {}, children);\n  return res;\n};\n\nexport const bTagDeserializer = (editor, el) => {\n  // Google Docs does weird things with <b> tag\n  return (el.getAttribute('id') || '').indexOf('docs-internal-guid') > -1\n    ? deserializeChildren(el, editor)\n    : jsx('element', { type: 'b' }, deserializeChildren(el, editor));\n};\n\nexport const codeTagDeserializer = (editor, el) => {\n  return jsx('element', { type: 'code' }, el.textContent);\n};\n\nexport const preTagDeserializer = (editor, el) => {\n  // Based on Slate example implementation. Replaces <pre> tags with <code>.\n  // Comment: I don't know how good of an idea is this. I'd rather have two\n  // separate formats: \"preserve whitespace\" and \"code\". This feels like a hack\n  const { nodeName } = el;\n  let parent = el;\n\n  if (el.childNodes[0] && el.childNodes[0].nodeName === 'CODE') {\n    parent = el.childNodes[0];\n    return codeTagDeserializer(editor, parent);\n  }\n\n  return blockTagDeserializer(nodeName)(editor, parent);\n};\n\nexport default deserialize;\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}