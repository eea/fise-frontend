{"ast":null,"code":"import _map from \"lodash/map\";\nimport _castArray from \"lodash/castArray\";\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport { Editor, Path, Point, Range, Transforms } from 'slate';\n\n/**\n * Get range from {@link getPointBefore} to the end point of `at`.\n */\nexport const getRangeBefore = (editor, at, options) => {\n  const anchor = getPointBefore(editor, at, options);\n  if (!anchor) return;\n  const focus = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  return {\n    anchor,\n    focus\n  };\n};\n\n/**\n * Autoformat in the middle of a block\n */\nexport const autoformatInlineBlock = (editor, {\n  type,\n  markup,\n  preFormat,\n  format\n}) => {\n  const markupRange = getRangeBefore(editor, editor.selection, {\n    matchString: markup,\n    skipInvalid: true\n  });\n  if (markupRange) {\n    autoformatBlock(editor, type, markupRange, {\n      preFormat: () => {\n        editor.insertBreak();\n        if (preFormat) {\n          preFormat(editor);\n        }\n      },\n      format\n    });\n    return true;\n  }\n};\n\n/**\n * {@link Editor.before} with additional options.\n * TODO: support for sequence of any characters.\n */\nexport const getPointBefore = (editor, at, options) => {\n  var _options$matchString;\n  if (!options || !options.match && !options.matchString) {\n    return Editor.before(editor, at, options);\n  }\n  let beforeAt = at;\n  let previousBeforePoint = Editor.point(editor, at, {\n    edge: 'end'\n  });\n  const stackLength = (((_options$matchString = options.matchString) === null || _options$matchString === void 0 ? void 0 : _options$matchString.length) || 0) + 1;\n  const stack = Array(stackLength);\n  const unitOffset = !options.unit || options.unit === 'offset';\n  let count = 0;\n  while (true) {\n    var _options$match;\n    const beforePoint = Editor.before(editor, beforeAt, options);\n\n    // not found\n    if (!beforePoint) return;\n\n    // different path\n    if (!options.multiPaths && !Path.equals(beforePoint.path, previousBeforePoint.path)) {\n      return;\n    }\n    const beforeString = Editor.string(editor, {\n      anchor: beforePoint,\n      focus: previousBeforePoint\n    });\n    const matchString = _castArray(options.matchString);\n    let beforeStringToMatch = beforeString;\n    if (unitOffset && stackLength) {\n      stack.unshift({\n        point: beforePoint,\n        text: beforeString\n      });\n      stack.pop();\n      beforeStringToMatch = _map(stack.slice(0, -1), 'text').join('');\n    }\n    if (matchString.includes(beforeStringToMatch) || (_options$match = options.match) !== null && _options$match !== void 0 && _options$match.call(options, {\n      beforeString: beforeStringToMatch,\n      beforePoint,\n      at\n    })) {\n      if (options.afterMatch) {\n        if (stackLength && unitOffset) {\n          var _stack;\n          return (_stack = stack[stack.length - 1]) === null || _stack === void 0 ? void 0 : _stack.point;\n        }\n        return previousBeforePoint;\n      }\n      return beforePoint;\n    }\n    previousBeforePoint = beforePoint;\n    beforeAt = beforePoint;\n    count += 1;\n    if (!options.skipInvalid) {\n      if (!matchString || count > matchString.length) return;\n    }\n  }\n};\nexport const autoformatInline = (editor, {\n  type,\n  between,\n  markup,\n  ignoreTrim\n}) => {\n  const selection = editor.selection;\n  const startMarkup = between ? between[0] : markup;\n  const endMarkup = between ? between[1] : '';\n  let endMarkupPointBefore = selection.anchor;\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup\n    });\n    if (!endMarkupPointBefore) return false;\n  }\n  const startMarkupPointAfter = getPointBefore(editor, endMarkupPointBefore, {\n    matchString: startMarkup,\n    skipInvalid: true,\n    afterMatch: true\n  });\n  if (!startMarkupPointAfter) return false;\n\n  // found\n\n  const markupRange = {\n    anchor: startMarkupPointAfter,\n    focus: endMarkupPointBefore\n  };\n  if (!ignoreTrim) {\n    const markupText = getText(editor, markupRange);\n    if (markupText.trim() !== markupText) return false;\n  }\n\n  // delete end markup\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup\n    });\n    Transforms.delete(editor, {\n      at: {\n        anchor: endMarkupPointBefore,\n        focus: selection.anchor\n      }\n    });\n  }\n\n  // add mark to the text between the markups\n  Transforms.select(editor, markupRange);\n  editor.addMark(type, true);\n  Transforms.collapse(editor, {\n    edge: 'end'\n  });\n  editor.removeMark(type);\n\n  // delete start markup\n  const startMarkupPointBefore = getPointBefore(editor, selection, {\n    matchString: startMarkup,\n    skipInvalid: true\n  });\n  Transforms.delete(editor, {\n    at: {\n      anchor: startMarkupPointBefore,\n      focus: startMarkupPointAfter\n    }\n  });\n  return true;\n};\nexport const autoformatBlock = (editor, type, at, {\n  preFormat,\n  format\n}) => {\n  Transforms.delete(editor, {\n    at\n  });\n  if (preFormat) {\n    preFormat(editor);\n  }\n  if (!format) {\n    Transforms.setNodes(editor, {\n      type\n    }, {\n      match: n => Editor.isBlock(editor, n)\n    });\n  } else {\n    format(editor);\n  }\n};\n\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\nexport const isCollapsed = range => !!range && Range.isCollapsed(range);\n\n/**\n * See {@link Editor.string}.\n * If `at` is not defined, return an empty string.\n */\nexport const getText = (editor, at) => {\n  var _ref;\n  return (_ref = at && Editor.string(editor, at)) !== null && _ref !== void 0 ? _ref : '';\n};\n\n/**\n * Get the bloc {\n * k above a location (default: selection).\n * If not found, return the editor entry.\n */\nexport const getBlockAbove = (editor, options = {}) => Editor.above(editor, _objectSpread({\n  match: n => Editor.isBlock(editor, n)\n}, options)) || [editor, []];\n\n/**\n * Get the point from a location (default: selection).\n * If the location is a range, get the anchor point.\n * If the location is a path, get the point at this path with offset 0.\n * If `focus` is true, get the focus point.\n */\nexport const getPointFromLocation = (editor, {\n  at = editor.selection,\n  focus\n} = {}) => {\n  let point;\n  if (Range.isRange(at)) point = !focus ? at.anchor : at.focus;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = {\n    path: at,\n    offset: 0\n  };\n  return point;\n};\n\n/**\n * Get the range from the start of the block above a location (default: selection) to the location.\n */\nexport const getRangeFromBlockStart = (editor, options = {}) => {\n  const [, path] = getBlockAbove(editor, options);\n  const start = Editor.start(editor, path);\n  const focus = getPointFromLocation(editor, options);\n  if (!focus) return;\n  return {\n    anchor: start,\n    focus\n  };\n};\n\n/**\n * Enables support for autoformatting actions.\n * Once a markup rule is validated, it does not check the following rules.\n */\nexport const withAutoformat = ({\n  rules\n}) => editor => {\n  const {\n    insertText\n  } = editor;\n  editor.insertText = text => {\n    if (!isCollapsed(editor.selection)) return insertText(text);\n    for (const {\n      trigger = ' ',\n      type,\n      markup,\n      preFormat,\n      format,\n      mode,\n      between,\n      ignoreTrim,\n      insertTrigger\n    } of rules) {\n      const triggers = _castArray(trigger);\n\n      // Check trigger\n      if (!triggers.includes(text)) continue;\n      const markups = _castArray(markup);\n      const rangeFromBlockStart = getRangeFromBlockStart(editor);\n      const textFromBlockStart = getText(editor, rangeFromBlockStart);\n      const valid = () => insertTrigger && insertText(text);\n      if (markups.includes(textFromBlockStart)) {\n        // Start of the block\n        autoformatBlock(editor, type, rangeFromBlockStart, {\n          preFormat,\n          format\n        });\n        return valid();\n      }\n      if (mode === 'inline-block') {\n        if (autoformatInlineBlock(editor, {\n          preFormat,\n          markup,\n          format,\n          type\n        })) {\n          return valid();\n        }\n      }\n      if (mode === 'inline') {\n        if (autoformatInline(editor, {\n          type,\n          between,\n          ignoreTrim,\n          markup: Array.isArray(markup) ? markup[0] : markup\n        })) {\n          return valid();\n        }\n      }\n    }\n    insertText(text);\n  };\n  return editor;\n};","map":{"version":3,"names":["Editor","Path","Point","Range","Transforms","getRangeBefore","editor","at","options","anchor","getPointBefore","focus","point","edge","autoformatInlineBlock","type","markup","preFormat","format","markupRange","selection","matchString","skipInvalid","autoformatBlock","insertBreak","match","before","beforeAt","previousBeforePoint","stackLength","length","stack","Array","unitOffset","unit","count","beforePoint","multiPaths","equals","path","beforeString","string","beforeStringToMatch","unshift","text","pop","slice","join","includes","afterMatch","autoformatInline","between","ignoreTrim","startMarkup","endMarkup","endMarkupPointBefore","startMarkupPointAfter","markupText","getText","trim","delete","select","addMark","collapse","removeMark","startMarkupPointBefore","setNodes","n","isBlock","isCollapsed","range","getBlockAbove","above","getPointFromLocation","isRange","isPoint","isPath","offset","getRangeFromBlockStart","start","withAutoformat","rules","insertText","trigger","mode","insertTrigger","triggers","markups","rangeFromBlockStart","textFromBlockStart","valid","isArray"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/editor/plugins/Markdown/extensions.js"],"sourcesContent":["import { castArray, map } from 'lodash';\nimport { Editor, Path, Point, Range, Transforms } from 'slate';\n\n/**\n * Get range from {@link getPointBefore} to the end point of `at`.\n */\nexport const getRangeBefore = (editor, at, options) => {\n  const anchor = getPointBefore(editor, at, options);\n  if (!anchor) return;\n\n  const focus = Editor.point(editor, at, { edge: 'end' });\n\n  return {\n    anchor,\n    focus,\n  };\n};\n\n/**\n * Autoformat in the middle of a block\n */\nexport const autoformatInlineBlock = (\n  editor,\n  { type, markup, preFormat, format },\n) => {\n  const markupRange = getRangeBefore(editor, editor.selection, {\n    matchString: markup,\n    skipInvalid: true,\n  });\n\n  if (markupRange) {\n    autoformatBlock(editor, type, markupRange, {\n      preFormat: () => {\n        editor.insertBreak();\n        if (preFormat) {\n          preFormat(editor);\n        }\n      },\n      format,\n    });\n\n    return true;\n  }\n};\n\n/**\n * {@link Editor.before} with additional options.\n * TODO: support for sequence of any characters.\n */\nexport const getPointBefore = (editor, at, options) => {\n  if (!options || (!options.match && !options.matchString)) {\n    return Editor.before(editor, at, options);\n  }\n\n  let beforeAt = at;\n  let previousBeforePoint = Editor.point(editor, at, { edge: 'end' });\n\n  const stackLength = (options.matchString?.length || 0) + 1;\n  const stack = Array(stackLength);\n\n  const unitOffset = !options.unit || options.unit === 'offset';\n\n  let count = 0;\n  while (true) {\n    const beforePoint = Editor.before(editor, beforeAt, options);\n\n    // not found\n    if (!beforePoint) return;\n\n    // different path\n    if (\n      !options.multiPaths &&\n      !Path.equals(beforePoint.path, previousBeforePoint.path)\n    ) {\n      return;\n    }\n\n    const beforeString = Editor.string(editor, {\n      anchor: beforePoint,\n      focus: previousBeforePoint,\n    });\n\n    const matchString = castArray(options.matchString);\n\n    let beforeStringToMatch = beforeString;\n\n    if (unitOffset && stackLength) {\n      stack.unshift({\n        point: beforePoint,\n        text: beforeString,\n      });\n      stack.pop();\n\n      beforeStringToMatch = map(stack.slice(0, -1), 'text').join('');\n    }\n\n    if (\n      matchString.includes(beforeStringToMatch) ||\n      options.match?.({ beforeString: beforeStringToMatch, beforePoint, at })\n    ) {\n      if (options.afterMatch) {\n        if (stackLength && unitOffset) {\n          return stack[stack.length - 1]?.point;\n        }\n        return previousBeforePoint;\n      }\n      return beforePoint;\n    }\n\n    previousBeforePoint = beforePoint;\n    beforeAt = beforePoint;\n\n    count += 1;\n\n    if (!options.skipInvalid) {\n      if (!matchString || count > matchString.length) return;\n    }\n  }\n};\n\nexport const autoformatInline = (\n  editor,\n  { type, between, markup, ignoreTrim },\n) => {\n  const selection = editor.selection;\n\n  const startMarkup = between ? between[0] : markup;\n  const endMarkup = between ? between[1] : '';\n\n  let endMarkupPointBefore = selection.anchor;\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup,\n    });\n    if (!endMarkupPointBefore) return false;\n  }\n\n  const startMarkupPointAfter = getPointBefore(editor, endMarkupPointBefore, {\n    matchString: startMarkup,\n    skipInvalid: true,\n    afterMatch: true,\n  });\n\n  if (!startMarkupPointAfter) return false;\n\n  // found\n\n  const markupRange = {\n    anchor: startMarkupPointAfter,\n    focus: endMarkupPointBefore,\n  };\n\n  if (!ignoreTrim) {\n    const markupText = getText(editor, markupRange);\n    if (markupText.trim() !== markupText) return false;\n  }\n\n  // delete end markup\n  if (endMarkup) {\n    endMarkupPointBefore = getPointBefore(editor, selection, {\n      matchString: endMarkup,\n    });\n    Transforms.delete(editor, {\n      at: {\n        anchor: endMarkupPointBefore,\n        focus: selection.anchor,\n      },\n    });\n  }\n\n  // add mark to the text between the markups\n  Transforms.select(editor, markupRange);\n  editor.addMark(type, true);\n  Transforms.collapse(editor, { edge: 'end' });\n  editor.removeMark(type);\n\n  // delete start markup\n  const startMarkupPointBefore = getPointBefore(editor, selection, {\n    matchString: startMarkup,\n    skipInvalid: true,\n  });\n  Transforms.delete(editor, {\n    at: {\n      anchor: startMarkupPointBefore,\n      focus: startMarkupPointAfter,\n    },\n  });\n\n  return true;\n};\n\nexport const autoformatBlock = (editor, type, at, { preFormat, format }) => {\n  Transforms.delete(editor, { at });\n\n  if (preFormat) {\n    preFormat(editor);\n  }\n\n  if (!format) {\n    Transforms.setNodes(\n      editor,\n      { type },\n      { match: (n) => Editor.isBlock(editor, n) },\n    );\n  } else {\n    format(editor);\n  }\n};\n\n/**\n * See {@link Range.isCollapsed}.\n * Return false if `range` is not defined.\n */\nexport const isCollapsed = (range) => !!range && Range.isCollapsed(range);\n\n/**\n * See {@link Editor.string}.\n * If `at` is not defined, return an empty string.\n */\nexport const getText = (editor, at) => (at && Editor.string(editor, at)) ?? '';\n\n/**\n * Get the bloc {\n * k above a location (default: selection).\n * If not found, return the editor entry.\n */\nexport const getBlockAbove = (editor, options = {}) =>\n  Editor.above(editor, {\n    match: (n) => Editor.isBlock(editor, n),\n    ...options,\n  }) || [editor, []];\n\n/**\n * Get the point from a location (default: selection).\n * If the location is a range, get the anchor point.\n * If the location is a path, get the point at this path with offset 0.\n * If `focus` is true, get the focus point.\n */\nexport const getPointFromLocation = (\n  editor,\n  { at = editor.selection, focus } = {},\n) => {\n  let point;\n  if (Range.isRange(at)) point = !focus ? at.anchor : at.focus;\n  if (Point.isPoint(at)) point = at;\n  if (Path.isPath(at)) point = { path: at, offset: 0 };\n\n  return point;\n};\n\n/**\n * Get the range from the start of the block above a location (default: selection) to the location.\n */\nexport const getRangeFromBlockStart = (editor, options = {}) => {\n  const [, path] = getBlockAbove(editor, options);\n\n  const start = Editor.start(editor, path);\n\n  const focus = getPointFromLocation(editor, options);\n\n  if (!focus) return;\n\n  return { anchor: start, focus };\n};\n\n/**\n * Enables support for autoformatting actions.\n * Once a markup rule is validated, it does not check the following rules.\n */\nexport const withAutoformat = ({ rules }) => (editor) => {\n  const { insertText } = editor;\n\n  editor.insertText = (text) => {\n    if (!isCollapsed(editor.selection)) return insertText(text);\n\n    for (const {\n      trigger = ' ',\n      type,\n      markup,\n      preFormat,\n      format,\n      mode,\n      between,\n      ignoreTrim,\n      insertTrigger,\n    } of rules) {\n      const triggers = castArray(trigger);\n\n      // Check trigger\n      if (!triggers.includes(text)) continue;\n\n      const markups = castArray(markup);\n\n      const rangeFromBlockStart = getRangeFromBlockStart(editor);\n      const textFromBlockStart = getText(editor, rangeFromBlockStart);\n\n      const valid = () => insertTrigger && insertText(text);\n\n      if (markups.includes(textFromBlockStart)) {\n        // Start of the block\n        autoformatBlock(editor, type, rangeFromBlockStart, {\n          preFormat,\n          format,\n        });\n        return valid();\n      }\n\n      if (mode === 'inline-block') {\n        if (\n          autoformatInlineBlock(editor, { preFormat, markup, format, type })\n        ) {\n          return valid();\n        }\n      }\n\n      if (mode === 'inline') {\n        if (\n          autoformatInline(editor, {\n            type,\n            between,\n            ignoreTrim,\n            markup: Array.isArray(markup) ? markup[0] : markup,\n          })\n        ) {\n          return valid();\n        }\n      }\n    }\n\n    insertText(text);\n  };\n\n  return editor;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}