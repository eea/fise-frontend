{"ast":null,"code":"import _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { Editor, Transforms, Node } from 'slate'; // Range,\n\n/**\n * @description Creates or updates an existing $elementType. It also takes care\n * of the saved selection and uses PathRef.\n *\n * @param {Editor} editor The Slate editor for the context\n * @param {object} data Relevant data for this element\n *\n * @returns {boolean} true if an element was possibly inserted, false otherwise\n * (currently we do not check here if the element was already applied to the\n * editor)\n */\nexport var _insertElement = function _insertElement(elementType) {\n  return function (editor, data) {\n    if (editor.getSavedSelection()) {\n      var selection = editor.selection || editor.getSavedSelection();\n      var rangeRef = Editor.rangeRef(editor, selection);\n      var res = Array.from(Editor.nodes(editor, {\n        match: function match(n) {\n          return n.type === elementType;\n        },\n        mode: 'highest',\n        at: selection\n      }));\n      if (res.length) {\n        var _res$ = _slicedToArray(res[0], 2),\n          path = _res$[1];\n        Transforms.setNodes(editor, {\n          data: data\n        }, {\n          at: path ? path : null,\n          match: path ? function (n) {\n            return n.type === elementType;\n          } : null\n        });\n      } else {\n        Transforms.wrapNodes(editor, {\n          type: elementType,\n          data: data\n        }, {\n          split: true,\n          at: selection,\n          match: function match(node) {\n            return Node.string(node).length !== 0;\n          }\n        } //,\n        );\n      }\n\n      var sel = JSON.parse(JSON.stringify(rangeRef.current));\n      Transforms.select(editor, sel);\n      editor.setSavedSelection(sel);\n      return true;\n    }\n    return false;\n  };\n};\n\n/**\n * Will unwrap a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - current node\n */\nexport var _unwrapElement = function _unwrapElement(elementType) {\n  return function (editor) {\n    var selection = editor.selection || editor.getSavedSelection();\n    var ref = Editor.rangeRef(editor, selection);\n    Transforms.select(editor, selection);\n    Transforms.unwrapNodes(editor, {\n      match: function match(n) {\n        return Array.isArray(elementType) ? elementType.includes(n.type) : n.type === elementType;\n      },\n      at: selection\n    });\n    var current = ref.current;\n    ref.unref();\n    return current;\n  };\n};\nexport var _isActiveElement = function _isActiveElement(elementType) {\n  return function (editor) {\n    var selection = editor.selection || editor.getSavedSelection();\n    var found;\n    try {\n      found = Array.from(Editor.nodes(editor, {\n        match: function match(n) {\n          return n.type === elementType;\n        },\n        at: selection\n      }) || []);\n    } catch (e) {\n      // eslint-disable-next-line\n      // console.warn('Error in finding active element', e);\n      return false;\n    }\n    if (found.length) return true;\n    if (selection) {\n      var path = selection.anchor.path;\n      var isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n      if (isAtStart) {\n        try {\n          found = Editor.previous(editor, {\n            at: path\n            // match: (n) => n.type === MENTION,\n          });\n        } catch (ex) {\n          found = [];\n        }\n        if (found && found[0] && found[0].type === elementType) {\n          return true;\n        }\n      }\n    }\n    return false;\n  };\n};\n\n/**\n * Will look for a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - found node\n */\nexport var _getActiveElement = function _getActiveElement(elementType) {\n  return function (editor) {\n    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';\n    var selection = editor.selection || editor.getSavedSelection();\n    var found = [];\n    try {\n      found = Array.from(Editor.nodes(editor, {\n        match: function match(n) {\n          return Array.isArray(elementType) ? elementType.includes(n.type) : n.type === elementType;\n        },\n        at: selection\n      }));\n    } catch (e) {\n      return null;\n    }\n    if (found.length) return found[0];\n    if (!selection) return null;\n    if (direction === 'any' || direction === 'backward') {\n      var path = selection.anchor.path;\n      var isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n      if (isAtStart) {\n        var _found;\n        try {\n          _found = Editor.previous(editor, {\n            at: path\n          });\n        } catch (ex) {\n          // eslint-disable-next-line no-console\n          console.warn('Unable to find previous node', editor, path);\n          return;\n        }\n        if (_found && _found[0] && _found[0].type === elementType) {\n          if (Array.isArray(elementType) && elementType.includes(_found[0].type) || _found[0].type === elementType) {\n            return _found;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n    if (direction === 'any' || direction === 'forward') {\n      var _path = selection.anchor.path;\n      var _isAtStart = selection.anchor.offset === 0 && selection.focus.offset === 0;\n      if (_isAtStart) {\n        var _found2;\n        try {\n          _found2 = Editor.next(editor, {\n            at: _path\n          });\n        } catch (e) {\n          // eslint-disable-next-line\n          console.warn('Unable to find next node', editor, _path);\n          return;\n        }\n        if (_found2 && _found2[0] && _found2[0].type === elementType) {\n          if (Array.isArray(elementType) && elementType.includes(_found2[0].type) || _found2[0].type === elementType) {\n            return _found2;\n          }\n        } else {\n          return null;\n        }\n      }\n    }\n    return null;\n  };\n};","map":{"version":3,"names":["Editor","Transforms","Node","_insertElement","elementType","editor","data","getSavedSelection","selection","rangeRef","res","Array","from","nodes","match","n","type","mode","at","length","path","setNodes","wrapNodes","split","node","string","sel","JSON","parse","stringify","current","select","setSavedSelection","_unwrapElement","ref","unwrapNodes","isArray","includes","unref","_isActiveElement","found","e","anchor","isAtStart","offset","focus","previous","ex","_getActiveElement","direction","console","warn","next"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/components/ElementEditor/utils.js"],"sourcesContent":["import { Editor, Transforms, Node } from 'slate'; // Range,\n\n/**\n * @description Creates or updates an existing $elementType. It also takes care\n * of the saved selection and uses PathRef.\n *\n * @param {Editor} editor The Slate editor for the context\n * @param {object} data Relevant data for this element\n *\n * @returns {boolean} true if an element was possibly inserted, false otherwise\n * (currently we do not check here if the element was already applied to the\n * editor)\n */\nexport const _insertElement = (elementType) => (editor, data) => {\n  if (editor.getSavedSelection()) {\n    const selection = editor.selection || editor.getSavedSelection();\n\n    const rangeRef = Editor.rangeRef(editor, selection);\n\n    const res = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => n.type === elementType,\n        mode: 'highest',\n        at: selection,\n      }),\n    );\n\n    if (res.length) {\n      const [, path] = res[0];\n      Transforms.setNodes(\n        editor,\n        { data },\n        {\n          at: path ? path : null,\n          match: path ? (n) => n.type === elementType : null,\n        },\n      );\n    } else {\n      Transforms.wrapNodes(\n        editor,\n        { type: elementType, data },\n        {\n          split: true,\n          at: selection,\n          match: (node) => {\n            return Node.string(node).length !== 0;\n          },\n        }, //,\n      );\n    }\n\n    const sel = JSON.parse(JSON.stringify(rangeRef.current));\n    Transforms.select(editor, sel);\n    editor.setSavedSelection(sel);\n\n    return true;\n  }\n\n  return false;\n};\n\n/**\n * Will unwrap a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - current node\n */\nexport const _unwrapElement = (elementType) => (editor) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  const ref = Editor.rangeRef(editor, selection);\n\n  Transforms.select(editor, selection);\n  Transforms.unwrapNodes(editor, {\n    match: (n) =>\n      Array.isArray(elementType)\n        ? elementType.includes(n.type)\n        : n.type === elementType,\n    at: selection,\n  });\n\n  const current = ref.current;\n  ref.unref();\n\n  return current;\n};\n\nexport const _isActiveElement = (elementType) => (editor) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found;\n  try {\n    found = Array.from(\n      Editor.nodes(editor, {\n        match: (n) => n.type === elementType,\n        at: selection,\n      }) || [],\n    );\n  } catch (e) {\n    // eslint-disable-next-line\n    // console.warn('Error in finding active element', e);\n    return false;\n  }\n  if (found.length) return true;\n\n  if (selection) {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      try {\n        found = Editor.previous(editor, {\n          at: path,\n          // match: (n) => n.type === MENTION,\n        });\n      } catch (ex) {\n        found = [];\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Will look for a node that has as type the one received or one from an array\n * @param {string|Object[]} elementType - this can be a string or an array of strings\n * @returns {Object|null} - found node\n */\nexport const _getActiveElement = (elementType) => (\n  editor,\n  direction = 'any',\n) => {\n  const selection = editor.selection || editor.getSavedSelection();\n  let found = [];\n\n  try {\n    found = Array.from(\n      Editor.nodes(editor, {\n        match: (n) =>\n          Array.isArray(elementType)\n            ? elementType.includes(n.type)\n            : n.type === elementType,\n        at: selection,\n      }),\n    );\n  } catch (e) {\n    return null;\n  }\n\n  if (found.length) return found[0];\n\n  if (!selection) return null;\n\n  if (direction === 'any' || direction === 'backward') {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.previous(editor, {\n          at: path,\n        });\n      } catch (ex) {\n        // eslint-disable-next-line no-console\n        console.warn('Unable to find previous node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (\n          (Array.isArray(elementType) && elementType.includes(found[0].type)) ||\n          found[0].type === elementType\n        ) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n\n  if (direction === 'any' || direction === 'forward') {\n    const { path } = selection.anchor;\n    const isAtStart =\n      selection.anchor.offset === 0 && selection.focus.offset === 0;\n\n    if (isAtStart) {\n      let found;\n      try {\n        found = Editor.next(editor, {\n          at: path,\n        });\n      } catch (e) {\n        // eslint-disable-next-line\n        console.warn('Unable to find next node', editor, path);\n        return;\n      }\n      if (found && found[0] && found[0].type === elementType) {\n        if (\n          (Array.isArray(elementType) && elementType.includes(found[0].type)) ||\n          found[0].type === elementType\n        ) {\n          return found;\n        }\n      } else {\n        return null;\n      }\n    }\n  }\n\n  return null;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}