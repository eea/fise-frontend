{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nimport { withRouter } from 'react-router';\nimport { connect } from 'react-redux';\nimport config from '@plone/volto/registry';\nimport { matchAllRoutes } from './utils';\nimport { load, loadSuccess, loadFail, beginGlobalLoad, endGlobalLoad } from '@plone/volto/actions/asyncConnect/asyncConnect';\nimport { isPromise, getMutableState, getImmutableState } from './utils';\nimport { AsyncConnectWithContext } from './AsyncConnect';\nexport { loadOnServer, loadAsyncConnect } from './ssr';\n\n// options is: { location, store: { dispatch }, route, match, routes }\nconst wrapWithDispatch = (Component, asyncItems = []) => {\n  return [{\n    key: 'voltoLoadAsyncProps',\n    promise: options => {\n      const {\n        store: {\n          dispatch\n        },\n        location: {\n          pathname\n        }\n      } = options;\n      const foundAsyncItems = applyExtenders(asyncItems, pathname);\n      const connects = foundAsyncItems.map(item => {\n        const {\n          key\n        } = item;\n        if (!key) return item;\n        const next = item.promise(options);\n        if (isPromise(next)) {\n          dispatch(load(key));\n          // add action dispatchers\n          next.then(data => dispatch(loadSuccess(key, data))).catch(err => dispatch(loadFail(key, err)));\n        } else if (next) {\n          dispatch(loadSuccess(key, next));\n        }\n        return _objectSpread(_objectSpread({}, item), {}, {\n          promise: next\n        });\n      });\n      Component.reduxAsyncConnect = connects;\n      return connects;\n    }\n  }];\n};\nconst applyExtenders = (asyncItems, pathname) => {\n  const {\n    asyncPropsExtenders = []\n  } = config.settings;\n  const extenders = matchAllRoutes(asyncPropsExtenders, pathname);\n  const foundAsyncItems = extenders.reduce((acc, extender) => extender.route.extend(acc), asyncItems);\n  let uniqueAsyncItems = foundAsyncItems.reduce((a, d) => {\n    if (!a.some(el => el.key === d.key)) {\n      a.push(d);\n    }\n    return a;\n  }, []);\n  return uniqueAsyncItems;\n};\n\n/**\n * A replacement for redux-connect's asyncConnect.\n *\n * It was needed because asyncConnect works as a direct wrapper on top of\n * a Component, so the config registry is not yet initialized. To solve this\n * problem we replace the original reduxAsyncConnect implementation (which was\n * a list of asyncConnected \"object promises\") with as single promise exposed\n * as { key: 'voltoLoadAsyncProps', promise: ... }.\n *\n * In more details, the original asyncConnect worked by replacing all our\n * \"object promises\" with a special version that's integrated with its own\n * Redux actions. We do another wrap, which takes the initial passed \"object\n * promises\", finds registered, per route, \"extenders\", calls these extenders\n * with the \"object promises\" and that's our \"object promises\" (which it calls\n * internally \"asyncItems\").\n */\nexport function asyncConnect(asyncItems, mapStateToProps, mapDispatchToProps, mergeProps, options) {\n  return Component => {\n    Component.reduxAsyncConnect = wrapWithDispatch(Component, asyncItems);\n    const finalMapStateToProps = (state, ownProps) => {\n      const {\n        pathname\n      } = state.router.location;\n      const foundAsyncItems = applyExtenders(asyncItems, pathname);\n      const mutableState = getMutableState(state);\n      const asyncStateToProps = foundAsyncItems.reduce((result, {\n        key\n      }) => {\n        if (!key) {\n          return result;\n        }\n        return _objectSpread(_objectSpread({}, result), {}, {\n          [key]: mutableState.reduxAsyncConnect[key]\n        });\n      }, {});\n      if (typeof mapStateToProps !== 'function') {\n        return asyncStateToProps;\n      }\n      return _objectSpread(_objectSpread({}, mapStateToProps(getImmutableState(mutableState), ownProps)), asyncStateToProps);\n    };\n    return connect(finalMapStateToProps, mapDispatchToProps, mergeProps, options)(Component);\n  };\n}\nexport const ReduxAsyncConnect = connect(null, {\n  beginGlobalLoad,\n  endGlobalLoad\n})(withRouter(AsyncConnectWithContext));","map":{"version":3,"names":["withRouter","connect","config","matchAllRoutes","load","loadSuccess","loadFail","beginGlobalLoad","endGlobalLoad","isPromise","getMutableState","getImmutableState","AsyncConnectWithContext","loadOnServer","loadAsyncConnect","wrapWithDispatch","Component","asyncItems","key","promise","options","store","dispatch","location","pathname","foundAsyncItems","applyExtenders","connects","map","item","next","then","data","catch","err","reduxAsyncConnect","asyncPropsExtenders","settings","extenders","reduce","acc","extender","route","extend","uniqueAsyncItems","a","d","some","el","push","asyncConnect","mapStateToProps","mapDispatchToProps","mergeProps","finalMapStateToProps","state","ownProps","router","mutableState","asyncStateToProps","result","ReduxAsyncConnect"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/helpers/AsyncConnect/index.js"],"sourcesContent":["import { withRouter } from 'react-router';\nimport { connect } from 'react-redux';\nimport config from '@plone/volto/registry';\nimport { matchAllRoutes } from './utils';\n\nimport {\n  load,\n  loadSuccess,\n  loadFail,\n  beginGlobalLoad,\n  endGlobalLoad,\n} from '@plone/volto/actions/asyncConnect/asyncConnect';\n\nimport { isPromise, getMutableState, getImmutableState } from './utils';\nimport { AsyncConnectWithContext } from './AsyncConnect';\nexport { loadOnServer, loadAsyncConnect } from './ssr';\n\n// options is: { location, store: { dispatch }, route, match, routes }\nconst wrapWithDispatch = (Component, asyncItems = []) => {\n  return [\n    {\n      key: 'voltoLoadAsyncProps',\n      promise: (options) => {\n        const {\n          store: { dispatch },\n          location: { pathname },\n        } = options;\n\n        const foundAsyncItems = applyExtenders(asyncItems, pathname);\n\n        const connects = foundAsyncItems.map((item) => {\n          const { key } = item;\n          if (!key) return item;\n          const next = item.promise(options);\n\n          if (isPromise(next)) {\n            dispatch(load(key));\n            // add action dispatchers\n            next\n              .then((data) => dispatch(loadSuccess(key, data)))\n              .catch((err) => dispatch(loadFail(key, err)));\n          } else if (next) {\n            dispatch(loadSuccess(key, next));\n          }\n          return {\n            ...item,\n            promise: next,\n          };\n        });\n\n        Component.reduxAsyncConnect = connects;\n        return connects;\n      },\n    },\n  ];\n};\n\nconst applyExtenders = (asyncItems, pathname) => {\n  const { asyncPropsExtenders = [] } = config.settings;\n  const extenders = matchAllRoutes(asyncPropsExtenders, pathname);\n\n  const foundAsyncItems = extenders.reduce(\n    (acc, extender) => extender.route.extend(acc),\n    asyncItems,\n  );\n\n  let uniqueAsyncItems = foundAsyncItems.reduce((a, d) => {\n    if (!a.some((el) => el.key === d.key)) {\n      a.push(d);\n    }\n    return a;\n  }, []);\n\n  return uniqueAsyncItems;\n};\n\n/**\n * A replacement for redux-connect's asyncConnect.\n *\n * It was needed because asyncConnect works as a direct wrapper on top of\n * a Component, so the config registry is not yet initialized. To solve this\n * problem we replace the original reduxAsyncConnect implementation (which was\n * a list of asyncConnected \"object promises\") with as single promise exposed\n * as { key: 'voltoLoadAsyncProps', promise: ... }.\n *\n * In more details, the original asyncConnect worked by replacing all our\n * \"object promises\" with a special version that's integrated with its own\n * Redux actions. We do another wrap, which takes the initial passed \"object\n * promises\", finds registered, per route, \"extenders\", calls these extenders\n * with the \"object promises\" and that's our \"object promises\" (which it calls\n * internally \"asyncItems\").\n */\nexport function asyncConnect(\n  asyncItems,\n  mapStateToProps,\n  mapDispatchToProps,\n  mergeProps,\n  options,\n) {\n  return (Component) => {\n    Component.reduxAsyncConnect = wrapWithDispatch(Component, asyncItems);\n\n    const finalMapStateToProps = (state, ownProps) => {\n      const { pathname } = state.router.location;\n      const foundAsyncItems = applyExtenders(asyncItems, pathname);\n      const mutableState = getMutableState(state);\n      const asyncStateToProps = foundAsyncItems.reduce((result, { key }) => {\n        if (!key) {\n          return result;\n        }\n\n        return {\n          ...result,\n          [key]: mutableState.reduxAsyncConnect[key],\n        };\n      }, {});\n\n      if (typeof mapStateToProps !== 'function') {\n        return asyncStateToProps;\n      }\n\n      return {\n        ...mapStateToProps(getImmutableState(mutableState), ownProps),\n        ...asyncStateToProps,\n      };\n    };\n\n    return connect(\n      finalMapStateToProps,\n      mapDispatchToProps,\n      mergeProps,\n      options,\n    )(Component);\n  };\n}\n\nexport const ReduxAsyncConnect = connect(null, {\n  beginGlobalLoad,\n  endGlobalLoad,\n})(withRouter(AsyncConnectWithContext));\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}