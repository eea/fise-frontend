{"ast":null,"code":"import _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { Editor, Range, Transforms, Path } from 'slate';\nimport config from '@plone/volto/registry';\nexport function isCursorInList(editor) {\n  var slate = config.settings.slate;\n  var result = Editor.above(editor, {\n    match: function match(n) {\n      return n.type === slate.listItemType;\n    }\n  });\n  if (!result) {\n    return false;\n  }\n  var _result = _slicedToArray(result, 1),\n    listItemWithSelection = _result[0];\n\n  // whether the selection is inside a list item\n  var listItemCase = Range.isCollapsed(editor.selection) && listItemWithSelection;\n  return listItemCase;\n}\nexport function isCursorAtListBlockStart(editor) {\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    var anchor = editor.selection.anchor;\n    return anchor.offset > 0 ? false : anchor.path.length === 3 && anchor.path.reduce(function (acc, x) {\n      return acc + x;\n    }, 0) === 0;\n  }\n}\nvar getPreviousSiblingPath = function getPreviousSiblingPath(path) {\n  // Doesn't raise an error if no previous sibling exists\n  var last = path[path.length - 1];\n  if (last <= 0) {\n    return null;\n  }\n  return path.slice(0, -1).concat(last - 1);\n};\nexport function mergeWithPreviousList(editor, listPath) {\n  var slate = config.settings.slate;\n  var prevSiblingPath = getPreviousSiblingPath(listPath);\n  var _Editor$node = Editor.node(editor, listPath),\n    _Editor$node2 = _slicedToArray(_Editor$node, 1),\n    currentList = _Editor$node2[0];\n  if (prevSiblingPath) {\n    var _Editor$node3 = Editor.node(editor, prevSiblingPath),\n      _Editor$node4 = _slicedToArray(_Editor$node3, 1),\n      prevSibling = _Editor$node4[0];\n    if (slate.listTypes.includes(prevSibling.type)) {\n      Transforms.mergeNodes(editor, {\n        // match: (node) => slate.listTypes.includes(node.type),\n        match: function match(node) {\n          return node === prevSibling || node === currentList;\n        },\n        mode: 'highest',\n        at: listPath\n      });\n    }\n  }\n}\nexport function mergeWithNextList(editor, listPath) {\n  var slate = config.settings.slate;\n  var _Editor$node5 = Editor.node(editor, listPath),\n    _Editor$node6 = _slicedToArray(_Editor$node5, 1),\n    currentList = _Editor$node6[0];\n  var _Editor$parent = Editor.parent(editor, listPath),\n    _Editor$parent2 = _slicedToArray(_Editor$parent, 1),\n    parent = _Editor$parent2[0];\n  if (parent.children.length - 1 > listPath[listPath.length - 1]) {\n    var nextSiblingPath = Path.next(listPath);\n    var _Editor$node7 = Editor.node(editor, nextSiblingPath),\n      _Editor$node8 = _slicedToArray(_Editor$node7, 1),\n      nextSibling = _Editor$node8[0];\n    if (slate.listTypes.includes(nextSibling.type)) {\n      Transforms.mergeNodes(editor, {\n        match: function match(node) {\n          return node === currentList || node === nextSibling;\n        },\n        at: nextSiblingPath,\n        mode: 'highest'\n      });\n    }\n  }\n}\nexport function getCurrentListItem(editor) {\n  var slate = config.settings.slate;\n  var _Editor$nodes = Editor.nodes(editor, {\n      at: editor.selection.anchor.path,\n      match: function match(n) {\n        return n.type === slate.listItemType;\n      },\n      mode: 'lowest'\n    }),\n    _Editor$nodes2 = _slicedToArray(_Editor$nodes, 1),\n    match = _Editor$nodes2[0];\n  return match || []; // empty entry if nothing is found\n}","map":{"version":3,"names":["Editor","Range","Transforms","Path","config","isCursorInList","editor","slate","settings","result","above","match","n","type","listItemType","listItemWithSelection","listItemCase","isCollapsed","selection","isCursorAtListBlockStart","anchor","offset","path","length","reduce","acc","x","getPreviousSiblingPath","last","slice","concat","mergeWithPreviousList","listPath","prevSiblingPath","node","currentList","prevSibling","listTypes","includes","mergeNodes","mode","at","mergeWithNextList","parent","children","nextSiblingPath","next","nextSibling","getCurrentListItem","nodes"],"sources":["/home/tooler/code/work/forests-frontend/src/develop/volto-slate/src/utils/lists.js"],"sourcesContent":["import { Editor, Range, Transforms, Path } from 'slate';\nimport config from '@plone/volto/registry';\n\nexport function isCursorInList(editor) {\n  const { slate } = config.settings;\n\n  const result = Editor.above(editor, {\n    match: (n) => n.type === slate.listItemType,\n  });\n\n  if (!result) {\n    return false;\n  }\n\n  const [listItemWithSelection] = result;\n\n  // whether the selection is inside a list item\n  const listItemCase =\n    Range.isCollapsed(editor.selection) && listItemWithSelection;\n\n  return listItemCase;\n}\n\nexport function isCursorAtListBlockStart(editor) {\n  if (editor.selection && Range.isCollapsed(editor.selection)) {\n    const { anchor } = editor.selection;\n    return anchor.offset > 0\n      ? false\n      : anchor.path.length === 3 &&\n          anchor.path.reduce((acc, x) => acc + x, 0) === 0;\n  }\n}\n\nconst getPreviousSiblingPath = function (path) {\n  // Doesn't raise an error if no previous sibling exists\n  const last = path[path.length - 1];\n\n  if (last <= 0) {\n    return null;\n  }\n\n  return path.slice(0, -1).concat(last - 1);\n};\n\nexport function mergeWithPreviousList(editor, listPath) {\n  const { slate } = config.settings;\n  const prevSiblingPath = getPreviousSiblingPath(listPath);\n  const [currentList] = Editor.node(editor, listPath);\n  if (prevSiblingPath) {\n    const [prevSibling] = Editor.node(editor, prevSiblingPath);\n\n    if (slate.listTypes.includes(prevSibling.type)) {\n      Transforms.mergeNodes(editor, {\n        // match: (node) => slate.listTypes.includes(node.type),\n        match: (node) => node === prevSibling || node === currentList,\n        mode: 'highest',\n        at: listPath,\n      });\n    }\n  }\n}\n\nexport function mergeWithNextList(editor, listPath) {\n  const { slate } = config.settings;\n  const [currentList] = Editor.node(editor, listPath);\n  const [parent] = Editor.parent(editor, listPath);\n\n  if (parent.children.length - 1 > listPath[listPath.length - 1]) {\n    const nextSiblingPath = Path.next(listPath);\n    const [nextSibling] = Editor.node(editor, nextSiblingPath);\n\n    if (slate.listTypes.includes(nextSibling.type)) {\n      Transforms.mergeNodes(editor, {\n        match: (node) => {\n          return node === currentList || node === nextSibling;\n        },\n        at: nextSiblingPath,\n        mode: 'highest',\n      });\n    }\n  }\n}\n\nexport function getCurrentListItem(editor) {\n  const { slate } = config.settings;\n  const [match] = Editor.nodes(editor, {\n    at: editor.selection.anchor.path,\n    match: (n) => n.type === slate.listItemType,\n    mode: 'lowest',\n  });\n  return match || []; // empty entry if nothing is found\n}\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}