{"ast":null,"code":"const _excluded = [\"connectDropTarget\", \"connectDragSource\", \"connectDragPreview\"];\nvar _jsxFileName = \"/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/components/manage/Form/Field.jsx\";\nvar __jsx = React.createElement;\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n/**\n * Field component.\n * @module components/manage/Form/Field\n */\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { injectIntl } from 'react-intl';\nimport config from '@plone/volto/registry';\nimport { injectLazyLibs } from '@plone/volto/helpers/Loadable/Loadable';\nconst MODE_HIDDEN = 'hidden'; //hidden mode. If mode is hidden, field is not rendered\n/**\n * Get default widget\n * @method getViewDefault\n * @returns {string} Widget component.\n */\nconst getWidgetDefault = () => config.widgets.default;\n\n/**\n * Get widget by field's `id` attribute\n * @method getWidgetById\n * @param {string} id Id\n * @returns {string} Widget component.\n */\nconst getWidgetByFieldId = id => config.widgets.id[id] || null;\n\n/**\n * Get widget by factory attribute\n * @method getWidgetByFactory\n * @param {string} id Id\n * @returns {string} Widget component.\n */\nconst getWidgetByFactory = factory => {\n  var _config$widgets$facto;\n  return ((_config$widgets$facto = config.widgets.factory) === null || _config$widgets$facto === void 0 ? void 0 : _config$widgets$facto[factory]) || null;\n};\n\n/**\n * Get widget by field's `widget` attribute\n * @method getWidgetByName\n * @param {string} widget Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByName = widget => typeof widget === 'string' ? config.widgets.widget[widget] || getWidgetDefault() : null;\n\n/**\n * Get widget by tagged values\n * @param {object} widgetOptions\n * @returns {string} Widget component.\n *\n\ndirectives.widget(\n    'fieldname',\n    frontendOptions={\n        \"widget\": 'specialwidget',\n        \"version\": 'extra'\n    })\n\n */\nconst getWidgetFromTaggedValues = widgetOptions => {\n  var _widgetOptions$fronte;\n  return typeof (widgetOptions === null || widgetOptions === void 0 ? void 0 : (_widgetOptions$fronte = widgetOptions.frontendOptions) === null || _widgetOptions$fronte === void 0 ? void 0 : _widgetOptions$fronte.widget) === 'string' ? config.widgets.widget[widgetOptions.frontendOptions.widget] : null;\n};\n\n/**\n * Get widget props from tagged values\n * @param {object} widgetOptions\n * @returns {string} Widget component.\n *\n\ndirectives.widget(\n    \"fieldname\",\n    frontendOptions={\n        \"widget\": \"specialwidget\",\n        \"widgetProps\": {\"prop1\": \"specialprop\"}\n    })\n\n */\nconst getWidgetPropsFromTaggedValues = widgetOptions => {\n  var _widgetOptions$fronte2;\n  return typeof (widgetOptions === null || widgetOptions === void 0 ? void 0 : (_widgetOptions$fronte2 = widgetOptions.frontendOptions) === null || _widgetOptions$fronte2 === void 0 ? void 0 : _widgetOptions$fronte2.widgetProps) === 'object' ? widgetOptions.frontendOptions.widgetProps : null;\n};\n\n/**\n * Get widget by field's `vocabulary` attribute\n * @method getWidgetByVocabulary\n * @param {string} vocabulary Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByVocabulary = vocabulary => vocabulary && vocabulary['@id'] ? config.widgets.vocabulary[vocabulary['@id'].replace(/^.*\\/@vocabularies\\//, '')] : null;\n\n/**\n * Get widget by field's hints `vocabulary` attribute in widgetOptions\n * @method getWidgetByVocabularyFromHint\n * @param {string} props Widget props\n * @returns {string} Widget component.\n */\nconst getWidgetByVocabularyFromHint = props => props.widgetOptions && props.widgetOptions.vocabulary ? config.widgets.vocabulary[props.widgetOptions.vocabulary['@id'].replace(/^.*\\/@vocabularies\\//, '')] : null;\n\n/**\n * Get widget by field's `choices` attribute\n * @method getWidgetByChoices\n * @param {string} choices Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByChoices = props => {\n  if (props.choices) {\n    return config.widgets.choices;\n  }\n  if (props.vocabulary) {\n    // If vocabulary exists, then it means it's a choice field in disguise with\n    // no widget specified that probably contains a string then we force it\n    // to be a select widget instead\n    return config.widgets.choices;\n  }\n  return null;\n};\n\n/**\n * Get widget by field's `type` attribute\n * @method getWidgetByType\n * @param {string} type Type\n * @returns {string} Widget component.\n */\nconst getWidgetByType = type => config.widgets.type[type] || null;\n\n/**\n * Field component class.\n * @function Field\n * @param {Object} props Properties.\n * @returns {string} Markup of the component.\n */\nconst UnconnectedField = (props, {\n  intl\n}) => {\n  const Widget = getWidgetByFieldId(props.id) || getWidgetFromTaggedValues(props.widgetOptions) || getWidgetByName(props.widget) || getWidgetByChoices(props) || getWidgetByVocabulary(props.vocabulary) || getWidgetByVocabularyFromHint(props) || getWidgetByFactory(props.factory) || getWidgetByType(props.type) || getWidgetDefault();\n  if (props.mode === MODE_HIDDEN) {\n    return null;\n  }\n\n  // Adding the widget props from tagged values (if any)\n  const widgetProps = _objectSpread(_objectSpread({}, props), getWidgetPropsFromTaggedValues(props.widgetOptions));\n  if (props.onOrder) {\n    const {\n      DropTarget,\n      DragSource\n    } = props.reactDnd;\n    const WrappedWidget = DropTarget('field', {\n      hover(properties, monitor) {\n        const dragOrder = monitor.getItem().order;\n        const hoverOrder = properties.order;\n        if (dragOrder === hoverOrder) {\n          return;\n        }\n        properties.onOrder(dragOrder, hoverOrder - dragOrder);\n        monitor.getItem().order = hoverOrder;\n      }\n    }, connect => ({\n      connectDropTarget: connect.dropTarget()\n    }))(DragSource('field', {\n      beginDrag(properties) {\n        return {\n          id: properties.label,\n          order: properties.order\n        };\n      }\n    }, (connect, monitor) => ({\n      connectDragSource: connect.dragSource(),\n      connectDragPreview: connect.dragPreview(),\n      isDragging: monitor.isDragging()\n    }))(_ref => {\n      let {\n          connectDropTarget,\n          connectDragSource,\n          connectDragPreview\n        } = _ref,\n        rest = _objectWithoutProperties(_ref, _excluded);\n      return connectDropTarget(connectDragSource(connectDragPreview(__jsx(\"div\", {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 218,\n          columnNumber: 17\n        }\n      }, __jsx(Widget, _extends({}, rest, {\n        __self: this,\n        __source: {\n          fileName: _jsxFileName,\n          lineNumber: 219,\n          columnNumber: 19\n        }\n      }))))));\n    }));\n    return __jsx(WrappedWidget, _extends({}, widgetProps, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 226,\n        columnNumber: 12\n      }\n    }));\n  }\n  return __jsx(Widget, _extends({}, widgetProps, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 228,\n      columnNumber: 10\n    }\n  }));\n};\nconst DndConnectedField = injectLazyLibs(['reactDnd'])(UnconnectedField);\nconst Field = props => props.onOrder ? __jsx(DndConnectedField, _extends({}, props, {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 235,\n    columnNumber: 5\n  }\n})) : __jsx(UnconnectedField, _extends({}, props, {\n  __self: this,\n  __source: {\n    fileName: _jsxFileName,\n    lineNumber: 237,\n    columnNumber: 5\n  }\n}));\n\n/**\n * Property types.\n * @property {Object} propTypes Property types.\n * @static\n */\nField.propTypes = {\n  widget: PropTypes.string,\n  vocabulary: PropTypes.shape({\n    '@id': PropTypes.string\n  }),\n  choices: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  type: PropTypes.string,\n  id: PropTypes.string.isRequired,\n  focus: PropTypes.bool,\n  onOrder: PropTypes.func\n};\n\n/**\n * Default properties.\n * @property {Object} defaultProps Default properties.\n * @static\n */\nField.defaultProps = {\n  widget: null,\n  vocabulary: null,\n  choices: null,\n  type: 'string',\n  focus: false,\n  onOrder: null\n};\nexport default injectIntl(Field);","map":{"version":3,"names":["React","PropTypes","injectIntl","config","injectLazyLibs","MODE_HIDDEN","getWidgetDefault","widgets","default","getWidgetByFieldId","id","getWidgetByFactory","factory","getWidgetByName","widget","getWidgetFromTaggedValues","widgetOptions","frontendOptions","getWidgetPropsFromTaggedValues","widgetProps","getWidgetByVocabulary","vocabulary","replace","getWidgetByVocabularyFromHint","props","getWidgetByChoices","choices","getWidgetByType","type","UnconnectedField","intl","Widget","mode","onOrder","DropTarget","DragSource","reactDnd","WrappedWidget","hover","properties","monitor","dragOrder","getItem","order","hoverOrder","connect","connectDropTarget","dropTarget","beginDrag","label","connectDragSource","dragSource","connectDragPreview","dragPreview","isDragging","rest","DndConnectedField","Field","propTypes","string","shape","arrayOf","isRequired","focus","bool","func","defaultProps"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/components/manage/Form/Field.jsx"],"sourcesContent":["/**\n * Field component.\n * @module components/manage/Form/Field\n */\n\nimport React from 'react';\nimport PropTypes from 'prop-types';\nimport { injectIntl } from 'react-intl';\nimport config from '@plone/volto/registry';\nimport { injectLazyLibs } from '@plone/volto/helpers/Loadable/Loadable';\n\nconst MODE_HIDDEN = 'hidden'; //hidden mode. If mode is hidden, field is not rendered\n/**\n * Get default widget\n * @method getViewDefault\n * @returns {string} Widget component.\n */\nconst getWidgetDefault = () => config.widgets.default;\n\n/**\n * Get widget by field's `id` attribute\n * @method getWidgetById\n * @param {string} id Id\n * @returns {string} Widget component.\n */\nconst getWidgetByFieldId = (id) => config.widgets.id[id] || null;\n\n/**\n * Get widget by factory attribute\n * @method getWidgetByFactory\n * @param {string} id Id\n * @returns {string} Widget component.\n */\nconst getWidgetByFactory = (factory) =>\n  config.widgets.factory?.[factory] || null;\n\n/**\n * Get widget by field's `widget` attribute\n * @method getWidgetByName\n * @param {string} widget Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByName = (widget) =>\n  typeof widget === 'string'\n    ? config.widgets.widget[widget] || getWidgetDefault()\n    : null;\n\n/**\n * Get widget by tagged values\n * @param {object} widgetOptions\n * @returns {string} Widget component.\n *\n\ndirectives.widget(\n    'fieldname',\n    frontendOptions={\n        \"widget\": 'specialwidget',\n        \"version\": 'extra'\n    })\n\n */\nconst getWidgetFromTaggedValues = (widgetOptions) =>\n  typeof widgetOptions?.frontendOptions?.widget === 'string'\n    ? config.widgets.widget[widgetOptions.frontendOptions.widget]\n    : null;\n\n/**\n * Get widget props from tagged values\n * @param {object} widgetOptions\n * @returns {string} Widget component.\n *\n\ndirectives.widget(\n    \"fieldname\",\n    frontendOptions={\n        \"widget\": \"specialwidget\",\n        \"widgetProps\": {\"prop1\": \"specialprop\"}\n    })\n\n */\nconst getWidgetPropsFromTaggedValues = (widgetOptions) =>\n  typeof widgetOptions?.frontendOptions?.widgetProps === 'object'\n    ? widgetOptions.frontendOptions.widgetProps\n    : null;\n\n/**\n * Get widget by field's `vocabulary` attribute\n * @method getWidgetByVocabulary\n * @param {string} vocabulary Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByVocabulary = (vocabulary) =>\n  vocabulary && vocabulary['@id']\n    ? config.widgets.vocabulary[\n        vocabulary['@id'].replace(/^.*\\/@vocabularies\\//, '')\n      ]\n    : null;\n\n/**\n * Get widget by field's hints `vocabulary` attribute in widgetOptions\n * @method getWidgetByVocabularyFromHint\n * @param {string} props Widget props\n * @returns {string} Widget component.\n */\nconst getWidgetByVocabularyFromHint = (props) =>\n  props.widgetOptions && props.widgetOptions.vocabulary\n    ? config.widgets.vocabulary[\n        props.widgetOptions.vocabulary['@id'].replace(\n          /^.*\\/@vocabularies\\//,\n          '',\n        )\n      ]\n    : null;\n\n/**\n * Get widget by field's `choices` attribute\n * @method getWidgetByChoices\n * @param {string} choices Widget\n * @returns {string} Widget component.\n */\nconst getWidgetByChoices = (props) => {\n  if (props.choices) {\n    return config.widgets.choices;\n  }\n\n  if (props.vocabulary) {\n    // If vocabulary exists, then it means it's a choice field in disguise with\n    // no widget specified that probably contains a string then we force it\n    // to be a select widget instead\n    return config.widgets.choices;\n  }\n\n  return null;\n};\n\n/**\n * Get widget by field's `type` attribute\n * @method getWidgetByType\n * @param {string} type Type\n * @returns {string} Widget component.\n */\nconst getWidgetByType = (type) => config.widgets.type[type] || null;\n\n/**\n * Field component class.\n * @function Field\n * @param {Object} props Properties.\n * @returns {string} Markup of the component.\n */\nconst UnconnectedField = (props, { intl }) => {\n  const Widget =\n    getWidgetByFieldId(props.id) ||\n    getWidgetFromTaggedValues(props.widgetOptions) ||\n    getWidgetByName(props.widget) ||\n    getWidgetByChoices(props) ||\n    getWidgetByVocabulary(props.vocabulary) ||\n    getWidgetByVocabularyFromHint(props) ||\n    getWidgetByFactory(props.factory) ||\n    getWidgetByType(props.type) ||\n    getWidgetDefault();\n\n  if (props.mode === MODE_HIDDEN) {\n    return null;\n  }\n\n  // Adding the widget props from tagged values (if any)\n  const widgetProps = {\n    ...props,\n    ...getWidgetPropsFromTaggedValues(props.widgetOptions),\n  };\n\n  if (props.onOrder) {\n    const { DropTarget, DragSource } = props.reactDnd;\n    const WrappedWidget = DropTarget(\n      'field',\n      {\n        hover(properties, monitor) {\n          const dragOrder = monitor.getItem().order;\n          const hoverOrder = properties.order;\n\n          if (dragOrder === hoverOrder) {\n            return;\n          }\n          properties.onOrder(dragOrder, hoverOrder - dragOrder);\n\n          monitor.getItem().order = hoverOrder;\n        },\n      },\n      (connect) => ({\n        connectDropTarget: connect.dropTarget(),\n      }),\n    )(\n      DragSource(\n        'field',\n        {\n          beginDrag(properties) {\n            return {\n              id: properties.label,\n              order: properties.order,\n            };\n          },\n        },\n        (connect, monitor) => ({\n          connectDragSource: connect.dragSource(),\n          connectDragPreview: connect.dragPreview(),\n          isDragging: monitor.isDragging(),\n        }),\n      )(\n        ({\n          connectDropTarget,\n          connectDragSource,\n          connectDragPreview,\n          ...rest\n        }) =>\n          connectDropTarget(\n            connectDragSource(\n              connectDragPreview(\n                <div>\n                  <Widget {...rest} />\n                </div>,\n              ),\n            ),\n          ),\n      ),\n    );\n    return <WrappedWidget {...widgetProps} />;\n  }\n  return <Widget {...widgetProps} />;\n};\n\nconst DndConnectedField = injectLazyLibs(['reactDnd'])(UnconnectedField);\n\nconst Field = (props) =>\n  props.onOrder ? (\n    <DndConnectedField {...props} />\n  ) : (\n    <UnconnectedField {...props} />\n  );\n\n/**\n * Property types.\n * @property {Object} propTypes Property types.\n * @static\n */\nField.propTypes = {\n  widget: PropTypes.string,\n  vocabulary: PropTypes.shape({ '@id': PropTypes.string }),\n  choices: PropTypes.arrayOf(PropTypes.arrayOf(PropTypes.string)),\n  type: PropTypes.string,\n  id: PropTypes.string.isRequired,\n  focus: PropTypes.bool,\n  onOrder: PropTypes.func,\n};\n\n/**\n * Default properties.\n * @property {Object} defaultProps Default properties.\n * @static\n */\nField.defaultProps = {\n  widget: null,\n  vocabulary: null,\n  choices: null,\n  type: 'string',\n  focus: false,\n  onOrder: null,\n};\n\nexport default injectIntl(Field);\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}