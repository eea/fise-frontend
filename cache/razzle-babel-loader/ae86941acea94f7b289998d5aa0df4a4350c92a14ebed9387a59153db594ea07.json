{"ast":null,"code":"import _identity from \"lodash/identity\";\nimport _toPairs from \"lodash/toPairs\";\nimport _pickBy from \"lodash/pickBy\";\nimport _map from \"lodash/map\";\nimport _join from \"lodash/join\";\nimport _isArray from \"lodash/isArray\";\nimport _concat from \"lodash/concat\";\nimport _compact from \"lodash/compact\";\nimport { RESET_SEARCH_CONTENT, SEARCH_CONTENT } from '@plone/volto/constants/ActionTypes';\n\n/**\n * Search content function.\n * @function searchContent\n * @param {string} url Url to use as base.\n * @param {Object} options Search options.\n * @param {string} subrequest Key of the subrequest.\n * @returns {Object} Search content action.\n */\nexport function searchContent(url, options, subrequest = null) {\n  let queryArray = [];\n  options = _pickBy(options, _identity);\n  const arrayOptions = _pickBy(options, item => _isArray(item));\n  queryArray = _concat(queryArray, options ? _join(_map(_toPairs(_pickBy(options, item => !_isArray(item))), item => {\n    if (item[0] === 'SearchableText') {\n      // Adds the wildcard to the SearchableText param\n      item[1] = `${item[1]}*`;\n    }\n    return _join(item, '=');\n  }), '&') : '');\n  queryArray = _concat(queryArray, arrayOptions ? _join(_map(_pickBy(arrayOptions), (item, key) => _join(item.map(value => `${key}:list=${value}`), '&')), '&') : '');\n  const querystring = _join(_compact(queryArray), '&');\n  return {\n    type: SEARCH_CONTENT,\n    subrequest,\n    request: {\n      op: 'get',\n      path: `${url}/@search${querystring ? `?${querystring}` : ''}`\n    }\n  };\n}\n\n/**\n * Reset search content function.\n * @function resetSearchContent\n * @param {string} subrequest Key of the subrequest.\n * @returns {Object} Search content action.\n */\nexport function resetSearchContent(subrequest = null) {\n  return {\n    type: RESET_SEARCH_CONTENT,\n    subrequest\n  };\n}","map":{"version":3,"names":["RESET_SEARCH_CONTENT","SEARCH_CONTENT","searchContent","url","options","subrequest","queryArray","arrayOptions","item","key","map","value","querystring","type","request","op","path","resetSearchContent"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/@plone/volto/src/actions/search/search.js"],"sourcesContent":["/**\n * Search actions.\n * @module actions/search/search\n */\n\nimport {\n  compact,\n  concat,\n  isArray,\n  join,\n  map,\n  pickBy,\n  toPairs,\n  identity,\n} from 'lodash';\n\nimport {\n  RESET_SEARCH_CONTENT,\n  SEARCH_CONTENT,\n} from '@plone/volto/constants/ActionTypes';\n\n/**\n * Search content function.\n * @function searchContent\n * @param {string} url Url to use as base.\n * @param {Object} options Search options.\n * @param {string} subrequest Key of the subrequest.\n * @returns {Object} Search content action.\n */\nexport function searchContent(url, options, subrequest = null) {\n  let queryArray = [];\n  options = pickBy(options, identity);\n  const arrayOptions = pickBy(options, (item) => isArray(item));\n\n  queryArray = concat(\n    queryArray,\n    options\n      ? join(\n          map(toPairs(pickBy(options, (item) => !isArray(item))), (item) => {\n            if (item[0] === 'SearchableText') {\n              // Adds the wildcard to the SearchableText param\n              item[1] = `${item[1]}*`;\n            }\n            return join(item, '=');\n          }),\n          '&',\n        )\n      : '',\n  );\n\n  queryArray = concat(\n    queryArray,\n    arrayOptions\n      ? join(\n          map(pickBy(arrayOptions), (item, key) =>\n            join(\n              item.map((value) => `${key}:list=${value}`),\n              '&',\n            ),\n          ),\n          '&',\n        )\n      : '',\n  );\n\n  const querystring = join(compact(queryArray), '&');\n\n  return {\n    type: SEARCH_CONTENT,\n    subrequest,\n    request: {\n      op: 'get',\n      path: `${url}/@search${querystring ? `?${querystring}` : ''}`,\n    },\n  };\n}\n\n/**\n * Reset search content function.\n * @function resetSearchContent\n * @param {string} subrequest Key of the subrequest.\n * @returns {Object} Search content action.\n */\nexport function resetSearchContent(subrequest = null) {\n  return {\n    type: RESET_SEARCH_CONTENT,\n    subrequest,\n  };\n}\n"],"mappings":";;;;;;;;AAgBA,SACEA,oBAAoB,EACpBC,cAAc,QACT,oCAAoC;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAa,CAACC,GAAG,EAAEC,OAAO,EAAEC,UAAU,GAAG,IAAI,EAAE;EAC7D,IAAIC,UAAU,GAAG,EAAE;EACnBF,OAAO,GAAG,QAAOA,OAAO,YAAW;EACnC,MAAMG,YAAY,GAAG,QAAOH,OAAO,EAAGI,IAAI,IAAK,SAAQA,IAAI,CAAC,CAAC;EAE7DF,UAAU,GAAG,QACXA,UAAU,EACVF,OAAO,GACH,MACE,KAAI,SAAQ,QAAOA,OAAO,EAAGI,IAAI,IAAK,CAAC,SAAQA,IAAI,CAAC,CAAC,CAAC,EAAGA,IAAI,IAAK;IAChE,IAAIA,IAAI,CAAC,CAAC,CAAC,KAAK,gBAAgB,EAAE;MAChC;MACAA,IAAI,CAAC,CAAC,CAAC,GAAI,GAAEA,IAAI,CAAC,CAAC,CAAE,GAAE;IACzB;IACA,OAAO,MAAKA,IAAI,EAAE,GAAG,CAAC;EACxB,CAAC,CAAC,EACF,GAAG,CACJ,GACD,EAAE,CACP;EAEDF,UAAU,GAAG,QACXA,UAAU,EACVC,YAAY,GACR,MACE,KAAI,QAAOA,YAAY,CAAC,EAAE,CAACC,IAAI,EAAEC,GAAG,KAClC,MACED,IAAI,CAACE,GAAG,CAAEC,KAAK,IAAM,GAAEF,GAAI,SAAQE,KAAM,EAAC,CAAC,EAC3C,GAAG,CACJ,CACF,EACD,GAAG,CACJ,GACD,EAAE,CACP;EAED,MAAMC,WAAW,GAAG,MAAK,SAAQN,UAAU,CAAC,EAAE,GAAG,CAAC;EAElD,OAAO;IACLO,IAAI,EAAEZ,cAAc;IACpBI,UAAU;IACVS,OAAO,EAAE;MACPC,EAAE,EAAE,KAAK;MACTC,IAAI,EAAG,GAAEb,GAAI,WAAUS,WAAW,GAAI,IAAGA,WAAY,EAAC,GAAG,EAAG;IAC9D;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,SAASK,kBAAkB,CAACZ,UAAU,GAAG,IAAI,EAAE;EACpD,OAAO;IACLQ,IAAI,EAAEb,oBAAoB;IAC1BK;EACF,CAAC;AACH"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}