{"ast":null,"code":"import _slicedToArray from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _objectSpread from \"/home/tooler/code/work/forests-frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport isUrl from 'is-url';\nimport imageExtensions from 'image-extensions';\nimport { blockTagDeserializer } from 'volto-slate/editor/deserialize';\nimport { getBaseUrl } from '@plone/volto/helpers';\nimport { v4 as uuid } from 'uuid';\nimport { Transforms } from 'slate';\nimport { IMAGE } from 'volto-slate/constants';\nexport var insertImage = function insertImage(editor, url) {\n  var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref$typeImg = _ref.typeImg,\n    typeImg = _ref$typeImg === void 0 ? IMAGE : _ref$typeImg;\n  var image = {\n    type: typeImg,\n    url: url,\n    children: [{\n      text: ''\n    }]\n  };\n  Transforms.insertNodes(editor, image);\n};\nexport var isImageUrl = function isImageUrl(url) {\n  if (!isUrl(url)) return false;\n  var ext = new URL(url).pathname.split('.').pop();\n  return imageExtensions.includes(ext);\n};\nexport var onImageLoad = function onImageLoad(editor, reader) {\n  return function () {\n    var data = reader.result;\n\n    // if (url) insertImage(editor, url);\n    var fields = data.match(/^data:(.*);(.*),(.*)$/);\n    var blockProps = editor.getBlockProps();\n    var block = blockProps.block,\n      uploadContent = blockProps.uploadContent,\n      pathname = blockProps.pathname;\n\n    // TODO: we need a way to get the uploaded image URL\n    // This would be easier if we would have block transformers-based image\n    // blocks\n    var url = getBaseUrl(pathname);\n    var uploadId = uuid();\n    var uploadFileName = \"clipboard-\".concat(uploadId);\n    var uploadTitle = \"Clipboard image\";\n    var content = {\n      '@type': 'Image',\n      title: uploadTitle,\n      image: {\n        data: fields[3],\n        encoding: fields[2],\n        'content-type': fields[1],\n        filename: uploadFileName\n      }\n    };\n    uploadContent(url, content, block).then(function (data) {\n      var dlUrl = data.image.download;\n      insertImage(editor, dlUrl);\n    });\n  };\n};\nexport var withDeserializers = function withDeserializers(editor) {\n  var _editor$dataTransferH;\n  editor.htmlTagsToSlate = _objectSpread(_objectSpread({}, editor.htmlTagsToSlate), {}, {\n    // We don't want H1 tags when pasting, we rewrite them as H2\n    H1: blockTagDeserializer('h2')\n  });\n  var handleFiles = ((_editor$dataTransferH = editor.dataTransferHandlers) === null || _editor$dataTransferH === void 0 ? void 0 : _editor$dataTransferH.files) || function () {\n    return true;\n  };\n  editor.dataTransferHandlers = _objectSpread(_objectSpread({}, editor.dataTransferHandlers), {}, {\n    files: function files(_files) {\n      var unprocessed = [];\n      var _iterator = _createForOfIteratorHelper(_files),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var file = _step.value;\n          var reader = new FileReader();\n          var _file$type$split = file.type.split('/'),\n            _file$type$split2 = _slicedToArray(_file$type$split, 1),\n            mime = _file$type$split2[0];\n          if (mime === 'image') {\n            reader.addEventListener('load', onImageLoad(editor, reader));\n            reader.readAsDataURL(file);\n          } else {\n            unprocessed.push(file);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return handleFiles(unprocessed);\n    }\n  });\n  return editor;\n};","map":{"version":3,"names":["isUrl","imageExtensions","blockTagDeserializer","getBaseUrl","v4","uuid","Transforms","IMAGE","insertImage","editor","url","typeImg","image","type","children","text","insertNodes","isImageUrl","ext","URL","pathname","split","pop","includes","onImageLoad","reader","data","result","fields","match","blockProps","getBlockProps","block","uploadContent","uploadId","uploadFileName","uploadTitle","content","title","encoding","filename","then","dlUrl","download","withDeserializers","htmlTagsToSlate","H1","handleFiles","dataTransferHandlers","files","unprocessed","file","FileReader","mime","addEventListener","readAsDataURL","push"],"sources":["/home/tooler/code/work/forests-frontend/node_modules/volto-slate/src/blocks/Text/extensions/withDeserializers.js"],"sourcesContent":["import isUrl from 'is-url';\nimport imageExtensions from 'image-extensions';\nimport { blockTagDeserializer } from 'volto-slate/editor/deserialize';\nimport { getBaseUrl } from '@plone/volto/helpers';\nimport { v4 as uuid } from 'uuid';\nimport { Transforms } from 'slate';\n\nimport { IMAGE } from 'volto-slate/constants';\n\nexport const insertImage = (editor, url, { typeImg = IMAGE } = {}) => {\n  const image = { type: typeImg, url, children: [{ text: '' }] };\n  Transforms.insertNodes(editor, image);\n};\n\nexport const isImageUrl = (url) => {\n  if (!isUrl(url)) return false;\n\n  const ext = new URL(url).pathname.split('.').pop();\n\n  return imageExtensions.includes(ext);\n};\n\nexport const onImageLoad = (editor, reader) => () => {\n  const data = reader.result;\n\n  // if (url) insertImage(editor, url);\n  const fields = data.match(/^data:(.*);(.*),(.*)$/);\n  const blockProps = editor.getBlockProps();\n  const { block, uploadContent, pathname } = blockProps;\n\n  // TODO: we need a way to get the uploaded image URL\n  // This would be easier if we would have block transformers-based image\n  // blocks\n  const url = getBaseUrl(pathname);\n  const uploadId = uuid();\n  const uploadFileName = `clipboard-${uploadId}`;\n  const uploadTitle = `Clipboard image`;\n  const content = {\n    '@type': 'Image',\n    title: uploadTitle,\n    image: {\n      data: fields[3],\n      encoding: fields[2],\n      'content-type': fields[1],\n      filename: uploadFileName,\n    },\n  };\n\n  uploadContent(url, content, block).then((data) => {\n    const dlUrl = data.image.download;\n    insertImage(editor, dlUrl);\n  });\n};\n\nexport const withDeserializers = (editor) => {\n  editor.htmlTagsToSlate = {\n    ...editor.htmlTagsToSlate,\n\n    // We don't want H1 tags when pasting, we rewrite them as H2\n    H1: blockTagDeserializer('h2'),\n  };\n\n  const handleFiles = editor.dataTransferHandlers?.files || (() => true);\n\n  editor.dataTransferHandlers = {\n    ...editor.dataTransferHandlers,\n    files: (files) => {\n      const unprocessed = [];\n      for (const file of files) {\n        const reader = new FileReader();\n        const [mime] = file.type.split('/');\n        if (mime === 'image') {\n          reader.addEventListener('load', onImageLoad(editor, reader));\n          reader.readAsDataURL(file);\n        } else {\n          unprocessed.push(file);\n        }\n      }\n\n      return handleFiles(unprocessed);\n    },\n  };\n\n  return editor;\n};\n"],"mappings":"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"},"metadata":{"react-intl":{"messages":[]}},"sourceType":"module","externalDependencies":[]}